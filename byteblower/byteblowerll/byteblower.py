# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _byteblower
else:
    import _byteblower

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_SwigPyIterator

    def value(self):
        return _byteblower.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _byteblower.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _byteblower.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _byteblower.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _byteblower.SwigPyIterator_equal(self, x)

    def copy(self):
        return _byteblower.SwigPyIterator_copy(self)

    def next(self):
        return _byteblower.SwigPyIterator_next(self)

    def __next__(self):
        return _byteblower.SwigPyIterator___next__(self)

    def previous(self):
        return _byteblower.SwigPyIterator_previous(self)

    def advance(self, n):
        return _byteblower.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _byteblower.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _byteblower.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _byteblower.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _byteblower.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _byteblower.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _byteblower.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _byteblower:
_byteblower.SwigPyIterator_swigregister(SwigPyIterator)

class ByteBlowerAPIException(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _byteblower.ByteBlowerAPIException_swiginit(self, _byteblower.new_ByteBlowerAPIException())
    __swig_destroy__ = _byteblower.delete_ByteBlowerAPIException

    def getPublicName(self):
        return _byteblower.ByteBlowerAPIException_getPublicName(self)

    def getInfo(self):
        return _byteblower.ByteBlowerAPIException_getInfo(self)

    def getMessage(self):
        return _byteblower.ByteBlowerAPIException_getMessage(self)

    def what(self):
        return _byteblower.ByteBlowerAPIException_what(self)

    def setServer(self, server):
        return _byteblower.ByteBlowerAPIException_setServer(self, server)

    def setPublicName(self, name):
        return _byteblower.ByteBlowerAPIException_setPublicName(self, name)

    def setPrivateName(self, name):
        return _byteblower.ByteBlowerAPIException_setPrivateName(self, name)

    def setInfo(self, info):
        return _byteblower.ByteBlowerAPIException_setInfo(self, info)

# Register ByteBlowerAPIException in _byteblower:
_byteblower.ByteBlowerAPIException_swigregister(ByteBlowerAPIException)


def Demangle(inName):
    return _byteblower.Demangle(inName)
class TechnicalError(ByteBlowerAPIException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TechnicalError_swiginit(self, _byteblower.new_TechnicalError(*args))
    __swig_destroy__ = _byteblower.delete_TechnicalError

# Register TechnicalError in _byteblower:
_byteblower.TechnicalError_swigregister(TechnicalError)

class DomainError(ByteBlowerAPIException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.DomainError_swiginit(self, _byteblower.new_DomainError(*args))
    __swig_destroy__ = _byteblower.delete_DomainError

# Register DomainError in _byteblower:
_byteblower.DomainError_swigregister(DomainError)

class ConfigError(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ConfigError_swiginit(self, _byteblower.new_ConfigError(*args))
    __swig_destroy__ = _byteblower.delete_ConfigError

# Register ConfigError in _byteblower:
_byteblower.ConfigError_swigregister(ConfigError)

class InitializationError(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.InitializationError_swiginit(self, _byteblower.new_InitializationError(*args))
    __swig_destroy__ = _byteblower.delete_InitializationError

# Register InitializationError in _byteblower:
_byteblower.InitializationError_swigregister(InitializationError)

class InProgressError(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.InProgressError_swiginit(self, _byteblower.new_InProgressError(*args))
    __swig_destroy__ = _byteblower.delete_InProgressError

# Register InProgressError in _byteblower:
_byteblower.InProgressError_swigregister(InProgressError)

class AddressResolutionFailed(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.AddressResolutionFailed_swiginit(self, _byteblower.new_AddressResolutionFailed(*args))
    __swig_destroy__ = _byteblower.delete_AddressResolutionFailed

# Register AddressResolutionFailed in _byteblower:
_byteblower.AddressResolutionFailed_swigregister(AddressResolutionFailed)

class DHCPFailed(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.DHCPFailed_swiginit(self, _byteblower.new_DHCPFailed(*args))
    __swig_destroy__ = _byteblower.delete_DHCPFailed

# Register DHCPFailed in _byteblower:
_byteblower.DHCPFailed_swigregister(DHCPFailed)

class RouterRequired(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.RouterRequired_swiginit(self, _byteblower.new_RouterRequired(*args))
    __swig_destroy__ = _byteblower.delete_RouterRequired

# Register RouterRequired in _byteblower:
_byteblower.RouterRequired_swigregister(RouterRequired)

class RouterSolicitationFailed(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.RouterSolicitationFailed_swiginit(self, _byteblower.new_RouterSolicitationFailed(*args))
    __swig_destroy__ = _byteblower.delete_RouterSolicitationFailed

# Register RouterSolicitationFailed in _byteblower:
_byteblower.RouterSolicitationFailed_swigregister(RouterSolicitationFailed)

class TCPAlreadyConnected(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPAlreadyConnected_swiginit(self, _byteblower.new_TCPAlreadyConnected(*args))
    __swig_destroy__ = _byteblower.delete_TCPAlreadyConnected

# Register TCPAlreadyConnected in _byteblower:
_byteblower.TCPAlreadyConnected_swigregister(TCPAlreadyConnected)

class TCPConnectionRefused(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionRefused_swiginit(self, _byteblower.new_TCPConnectionRefused(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionRefused

# Register TCPConnectionRefused in _byteblower:
_byteblower.TCPConnectionRefused_swigregister(TCPConnectionRefused)

class TCPConnectionTimout(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionTimout_swiginit(self, _byteblower.new_TCPConnectionTimout(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionTimout

# Register TCPConnectionTimout in _byteblower:
_byteblower.TCPConnectionTimout_swigregister(TCPConnectionTimout)

class TCPConnectionResetByPeer(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionResetByPeer_swiginit(self, _byteblower.new_TCPConnectionResetByPeer(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionResetByPeer

# Register TCPConnectionResetByPeer in _byteblower:
_byteblower.TCPConnectionResetByPeer_swigregister(TCPConnectionResetByPeer)

class TCPConnectionAborted(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionAborted_swiginit(self, _byteblower.new_TCPConnectionAborted(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionAborted

# Register TCPConnectionAborted in _byteblower:
_byteblower.TCPConnectionAborted_swigregister(TCPConnectionAborted)

class PortNumberAlreadyUsed(ConfigError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.PortNumberAlreadyUsed_swiginit(self, _byteblower.new_PortNumberAlreadyUsed(*args))
    __swig_destroy__ = _byteblower.delete_PortNumberAlreadyUsed

# Register PortNumberAlreadyUsed in _byteblower:
_byteblower.PortNumberAlreadyUsed_swigregister(PortNumberAlreadyUsed)

class ByteBlowerServerUnreachable(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ByteBlowerServerUnreachable_swiginit(self, _byteblower.new_ByteBlowerServerUnreachable(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerUnreachable

# Register ByteBlowerServerUnreachable in _byteblower:
_byteblower.ByteBlowerServerUnreachable_swigregister(ByteBlowerServerUnreachable)

class MeetingPointUnreachable(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.MeetingPointUnreachable_swiginit(self, _byteblower.new_MeetingPointUnreachable(*args))
    __swig_destroy__ = _byteblower.delete_MeetingPointUnreachable

# Register MeetingPointUnreachable in _byteblower:
_byteblower.MeetingPointUnreachable_swigregister(MeetingPointUnreachable)

class ByteBlowerServerIncompatible(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ByteBlowerServerIncompatible_swiginit(self, _byteblower.new_ByteBlowerServerIncompatible(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerIncompatible

# Register ByteBlowerServerIncompatible in _byteblower:
_byteblower.ByteBlowerServerIncompatible_swigregister(ByteBlowerServerIncompatible)

class UnsupportedFeature(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.UnsupportedFeature_swiginit(self, _byteblower.new_UnsupportedFeature(*args))
    __swig_destroy__ = _byteblower.delete_UnsupportedFeature

# Register UnsupportedFeature in _byteblower:
_byteblower.UnsupportedFeature_swigregister(UnsupportedFeature)

class ResponseTimeout(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ResponseTimeout_swiginit(self, _byteblower.new_ResponseTimeout(*args))
    __swig_destroy__ = _byteblower.delete_ResponseTimeout

# Register ResponseTimeout in _byteblower:
_byteblower.ResponseTimeout_swigregister(ResponseTimeout)

EXCENTIS_ARCHLIB_HAVE_COMPAT_WARNINGS = _byteblower.EXCENTIS_ARCHLIB_HAVE_COMPAT_WARNINGS
EXCENTIS_COMPAT_HAS_CXX0X = _byteblower.EXCENTIS_COMPAT_HAS_CXX0X
EXCENTIS_COMPAT_HAS_CPP0X = _byteblower.EXCENTIS_COMPAT_HAS_CPP0X
EXCENTIS_COMPAT_HAS_CXX11 = _byteblower.EXCENTIS_COMPAT_HAS_CXX11
class DataSize(object):
    r"""

    Represents a data size.  The DataSize can be expressed in multiple formats.

    Example

    TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bytes):
        _byteblower.DataSize_swiginit(self, _byteblower.new_DataSize(bytes))

    def BytesGet(self):
        r"""


        :return: The size in bytes
        :rtype: long

        Example

        TODO

        """
        return _byteblower.DataSize_BytesGet(self)

    def KibiBytesGet(self):
        r"""


        :return: The size in kibibytes
        :rtype: long

        Example

        TODO

        """
        return _byteblower.DataSize_KibiBytesGet(self)

    def MebiBytesGet(self):
        r"""


        :return: The size in mebibytes
        :rtype: long

        Example

        TODO

        """
        return _byteblower.DataSize_MebiBytesGet(self)

    def GibiBytesGet(self):
        r"""


        :return: The size in gibibytes
        :rtype: long


        Example

        TODO


        """
        return _byteblower.DataSize_GibiBytesGet(self)

    def toString(self):
        r"""



        :return: A human readable format of the size
        :rtype: str

        Example

        TODO

        """
        return _byteblower.DataSize_toString(self)
    __swig_destroy__ = _byteblower.delete_DataSize

# Register DataSize in _byteblower:
_byteblower.DataSize_swigregister(DataSize)
cvar = _byteblower.cvar
MAX_U_INT16 = cvar.MAX_U_INT16
MAX_U_INT32 = cvar.MAX_U_INT32
MAX_U_INT64 = cvar.MAX_U_INT64
MAX_INT16 = cvar.MAX_INT16
MAX_INT32 = cvar.MAX_INT32
MAX_INT64 = cvar.MAX_INT64

class Duration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ns):
        _byteblower.Duration_swiginit(self, _byteblower.new_Duration(ns))

    def NanosecondsGet(self):
        return _byteblower.Duration_NanosecondsGet(self)

    def MicrosecondsGet(self):
        return _byteblower.Duration_MicrosecondsGet(self)

    def MillisecondsGet(self):
        return _byteblower.Duration_MillisecondsGet(self)

    def SecondsGet(self):
        return _byteblower.Duration_SecondsGet(self)

    def toString(self):
        return _byteblower.Duration_toString(self)
    __swig_destroy__ = _byteblower.delete_Duration

# Register Duration in _byteblower:
_byteblower.Duration_swigregister(Duration)

ResultDataType_Cumulative = _byteblower.ResultDataType_Cumulative
ResultDataType_Interval = _byteblower.ResultDataType_Interval
class DataRate(object):
    r"""

    Represents a data rate.  The datarate can be expressed in multiple formats.

    Example

    .. code-block:: python

       httpResultData = httpClient.ResultHistoryGet().CumulativeLatestGet()
       dataRate = httpResultData.RxByteCountRateGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, inSize, inDuration):
        _byteblower.DataRate_swiginit(self, _byteblower.new_DataRate(inSize, inDuration))

    def toString(self):
        r"""

        Returns the bytes per second in a readable string format

        :return: A human readable format of the speed
        :rtype: str

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.toString())


        """
        return _byteblower.DataRate_toString(self)

    def ByteRateGet(self):
        r"""

        Returns the bytes per second of the http session

        :return: The speed in bytes per second
        :rtype: long


        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.ByteRateGet())


        """
        return _byteblower.DataRate_ByteRateGet(self)

    def BitRateGet(self):
        r"""

        Returns the bits per second of the http session

        :return: The speed in bits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.BitRateGet())


        """
        return _byteblower.DataRate_BitRateGet(self)

    def KbpsGet(self):
        r"""

        Returns the kilobits per second of the http session

        :return: The speed in kilobits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.KbpsGet())


        """
        return _byteblower.DataRate_KbpsGet(self)

    def MbpsGet(self):
        r"""

        Returns the megabits per second of the http session

        :return: The speed in megabits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.MbpsGet())


        """
        return _byteblower.DataRate_MbpsGet(self)

    def GbpsGet(self):
        r"""

        Returns the gigabits per second of the http session

        :return: The speed in gigabits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.GbpsGet())


        """
        return _byteblower.DataRate_GbpsGet(self)

    def bitrate(self):
        r"""


        .. deprecated: 2.x
           Use :meth:`BitRateGet` instead

        :return: The speed in bits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.bitrate())


        """
        return _byteblower.DataRate_bitrate(self)

    def byterate(self):
        r"""


        .. deprecated: 2.x
           Use :meth:`ByteRateGet` instead

        :return: The speed in bytes per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.byterate())


        """
        return _byteblower.DataRate_byterate(self)
    __swig_destroy__ = _byteblower.delete_DataRate

# Register DataRate in _byteblower:
_byteblower.DataRate_swigregister(DataRate)

FrameTagType_TimeStamp = _byteblower.FrameTagType_TimeStamp
FrameTagType_SequenceNumber = _byteblower.FrameTagType_SequenceNumber
TimeStampFormat_Microseconds = _byteblower.TimeStampFormat_Microseconds
TimeStampFormat_Microseconds_CRC = _byteblower.TimeStampFormat_Microseconds_CRC
TimeStampFormat_TenNanoseconds = _byteblower.TimeStampFormat_TenNanoseconds
SequenceNumberFormat_SequenceNumber_0 = _byteblower.SequenceNumberFormat_SequenceNumber_0
SequenceNumberFormat_SequenceNumber_0_CRC = _byteblower.SequenceNumberFormat_SequenceNumber_0_CRC
LinkStatus_Offline = _byteblower.LinkStatus_Offline
LinkStatus_Online = _byteblower.LinkStatus_Online
LinkStatus_Unplugged = _byteblower.LinkStatus_Unplugged
LinkStatus_Unknown = _byteblower.LinkStatus_Unknown

def ConvertLinkStatusToString(inLinkStatus):
    return _byteblower.ConvertLinkStatusToString(inLinkStatus)

def ParseLinkStatus(arg1):
    return _byteblower.ParseLinkStatus(arg1)
LinkType_Ethernet = _byteblower.LinkType_Ethernet
LinkType_USB = _byteblower.LinkType_USB

def ConvertLinkTypeToString(inLinkType):
    return _byteblower.ConvertLinkTypeToString(inLinkType)

def ParseLinkType(arg1):
    return _byteblower.ParseLinkType(arg1)
PhysicalInterfaceType_Trunk = _byteblower.PhysicalInterfaceType_Trunk
PhysicalInterfaceType_NonTrunk = _byteblower.PhysicalInterfaceType_NonTrunk
PhysicalInterfaceType_NonTrunkUSB = _byteblower.PhysicalInterfaceType_NonTrunkUSB

def ConvertPhysicalInterfaceTypeToString(inType):
    return _byteblower.ConvertPhysicalInterfaceTypeToString(inType)

def ParsePhysicalInterfaceType(inString):
    return _byteblower.ParsePhysicalInterfaceType(inString)
IGMPVersion_IGMPv1 = _byteblower.IGMPVersion_IGMPv1
IGMPVersion_IGMPv2 = _byteblower.IGMPVersion_IGMPv2
IGMPVersion_IGMPv3 = _byteblower.IGMPVersion_IGMPv3

def ParseIGMPVersion(inIGMPVersion):
    return _byteblower.ParseIGMPVersion(inIGMPVersion)

def IGMPVersionToString(inIGMPVersion):
    return _byteblower.IGMPVersionToString(inIGMPVersion)
MLDVersion_MLDv1 = _byteblower.MLDVersion_MLDv1
MLDVersion_MLDv2 = _byteblower.MLDVersion_MLDv2

def ParseMLDVersion(inMLDVersion):
    return _byteblower.ParseMLDVersion(inMLDVersion)

def MLDVersionToString(inMLDVersion):
    return _byteblower.MLDVersionToString(inMLDVersion)
MulticastSourceFilter_Exclude = _byteblower.MulticastSourceFilter_Exclude
MulticastSourceFilter_Include = _byteblower.MulticastSourceFilter_Include

def ParseMulticastFilter(inMulticastFilter):
    return _byteblower.ParseMulticastFilter(inMulticastFilter)

def MulticastFilterToString(inMulticastFilter):
    return _byteblower.MulticastFilterToString(inMulticastFilter)
RetransmissionPolicy_Unknown = _byteblower.RetransmissionPolicy_Unknown
RetransmissionPolicy_RfcSuggested = _byteblower.RetransmissionPolicy_RfcSuggested
RetransmissionPolicy_FixedTiming = _byteblower.RetransmissionPolicy_FixedTiming
TimeUnit_Seconds = _byteblower.TimeUnit_Seconds
TimeUnit_Milliseconds = _byteblower.TimeUnit_Milliseconds
TimeUnit_Microseconds = _byteblower.TimeUnit_Microseconds
TimeUnit_Nanoseconds = _byteblower.TimeUnit_Nanoseconds

def ConvertTimeUnitToString(inTimeUnit):
    return _byteblower.ConvertTimeUnitToString(inTimeUnit)

def ParseTimeUnitFromString(arg1):
    return _byteblower.ParseTimeUnitFromString(arg1)

def ToNanoseconds(unit):
    return _byteblower.ToNanoseconds(unit)
DescriptionFormat_PlainText = _byteblower.DescriptionFormat_PlainText
class AbstractObject(object):
    r"""

    Base class for most of the ByteBlowerobjects

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def ParentGet(self):
        r"""

        Returns the parent object.

        """
        return _byteblower.AbstractObject_ParentGet(self)

    def DescriptionGet(self, *args):
        r"""

        Gets a textual description for the current object

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        Gets a textual description for the current object

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.AbstractObject_DescriptionGet(self, *args)

    def Refresh(self):
        r"""

        Retrieves the latest data from the server for this object.

        """
        return _byteblower.AbstractObject_Refresh(self)

# Register AbstractObject in _byteblower:
_byteblower.AbstractObject_swigregister(AbstractObject)

class AbstractRefreshableResult(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_AbstractRefreshableResult

# Register AbstractRefreshableResult in _byteblower:
_byteblower.AbstractRefreshableResult_swigregister(AbstractRefreshableResult)

class ByteBlowerInterface(AbstractObject):
    r"""


    Example

    .. code-block:: python

    	interface = bbServer.InterfaceGetByName('trunk-1-14')
        packetDump = interface.PacketDumpCreate()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPhysicalInterface(self):
        return _byteblower.ByteBlowerInterface_GetPhysicalInterface(self)

    def NameGet(self):
        r"""

        Returns the name of the ByteBlower Interface 

        :return: Name of the ByteBlower Interface
        :rtype: str  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

            print(interface.NameGet())


        """
        return _byteblower.ByteBlowerInterface_NameGet(self)

    def SpeedGet(self):
        r"""



        :return: TODO??
        :rtype: long

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(interface.SpeedGet())


        """
        return _byteblower.ByteBlowerInterface_SpeedGet(self)

    def PortIdGet(self):
        r"""



        :return: The id of the first ByteBlower port on this interface

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(interface.PortIdGet())


        """
        return _byteblower.ByteBlowerInterface_PortIdGet(self)

    def PortCountGet(self):
        r"""



        :return: number of ports on this ByteBlowerInterface
        :rtype: long

        Example

        .. code-block:: python
        	:emphasize-lines: 1

            print(interface.PortCountGet())


        """
        return _byteblower.ByteBlowerInterface_PortCountGet(self)

    def PortGet(self):
        r"""



        :return: A list of ByteBlower ports on this interface
        :rtype: ByteBlowerPortList

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	portList = interface.PortGet()


        """
        return _byteblower.ByteBlowerInterface_PortGet(self)

    def PortCreate(self):
        r"""


        Creates a new ByteBlower port on this ByteBlowerInterface.  

        :return: ByteBlowerPort
        :rtype: unknown

        Example

        .. code-block:: python
        	:emphasize-lines: 1

            port = interface.PortCreate()


        """
        return _byteblower.ByteBlowerInterface_PortCreate(self)

    def PortDestroy(self, inPort):
        r"""


        :param port: ByteBlowerPort object that you want to destroy from the interface`.  


        Example

        .. code-block:: python
        	:emphasize-lines: 1

           interface.PortDestroy(port)


        """
        return _byteblower.ByteBlowerInterface_PortDestroy(self, inPort)

    def PacketDumpCreate(self):
        r"""



        :return: returns a PacketDump object
        :rtype: PacketDump

        Example

        .. code-block:: python
           :emphasize-lines: 1

            packetDump = interface.PacketDumpCreate()


        """
        return _byteblower.ByteBlowerInterface_PacketDumpCreate(self)

    def PacketDumpDestroy(self, packet_dump):
        r"""


        Destroys a PacketDump on this interface
        :param: PacketDump object that you want to destroy from the interface`.  
        Example

        .. code-block:: python
           :emphasize-lines: 1

        	packetDump = interface.PacketDumpCreate()
            interface.PacketDumpDestroy(packetDump)


        """
        return _byteblower.ByteBlowerInterface_PacketDumpDestroy(self, packet_dump)

    def SwitchIdGet(self):
        r"""

        Returns the ID of the switch where the ByteBlower Interface ?? Deprecated??

        :return: Id of the switch where the ByteBlower Interface is connected
        :rtype: int

        Example

        .. code-block:: python
        	:emphasize-lines: 1



        """
        return _byteblower.ByteBlowerInterface_SwitchIdGet(self)

# Register ByteBlowerInterface in _byteblower:
_byteblower.ByteBlowerInterface_swigregister(ByteBlowerInterface)

class ByteBlower(AbstractObject):
    r"""

    Singleton class that is the entry point to start using the ByteBlower API.  

    Typically, this is the first class you will use when writing a ByteBlower test 
    script. Use this class to connect to ByteBlower servers, to start or stop all 
    configured ByteBlower ports across those servers, and to control the logging 
    behavior.

    Retrieve the singleton ByteBlower *object* using the static method 
    :meth:`InstanceGet`.

    This class contains some static convenience methods. 
    They are wrappers around the corresponding non-static methods of the singleton 
    object.  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DefaultTimeout = _byteblower.ByteBlower_DefaultTimeout

    @staticmethod
    def InstanceGet():
        r"""

        Creates or returns the ByteBlower API singleton instance.  

        This object is the entry point to start working with the ByteBlower Python API.  

        If no ByteBlower instance is created yet, this method creates one and returns the object. If the instance exists already, it is simply returned.
        Any other static call will implicitly instantiate this singleton object.  

        :return:  ByteBlower singleton instance.  

        Example

        .. code-block:: python

           instance = bb.InstanceGet()


        """
        return _byteblower.ByteBlower_InstanceGet()

    def APIVersionGet(self):
        r"""

        Returns the version of the API.  

        .. versionadded:: 2.6.0  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(bb.APIVersionGet())
           # returns 2.10.0


        """
        return _byteblower.ByteBlower_APIVersionGet(self)

    def ServerAdd(self, *args):
        r"""

        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        :return:  A :class:`.ByteBlowerServer` object that represents the server connection.  

        :raises: :exc:`.ByteBlowerServerUnreachable`: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises: :exc:`.ByteBlowerServerIncompatible` When the ByteBlower server daemon is running an incompatible version.  

        :raises: <python_error>: Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  

        :raises: :exc:`NotImplementedError` When the *<port>* parameter is provided and
                 is no integer.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           bb = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        :return:  A :class:`.ByteBlowerServer` object that represents the server connection.  

        :raises: :exc:`.ByteBlowerServerUnreachable`: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises: :exc:`.ByteBlowerServerIncompatible` When the ByteBlower server daemon is running an incompatible version.  

        :raises: <python_error>: Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  

        :raises: :exc:`NotImplementedError` When the *<port>* parameter is provided and
                 is no integer.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           bb = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        :return:  A :class:`.ByteBlowerServer` object that represents the server connection.  

        :raises: :exc:`.ByteBlowerServerUnreachable`: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises: :exc:`.ByteBlowerServerIncompatible` When the ByteBlower server daemon is running an incompatible version.  

        :raises: <python_error>: Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  

        :raises: :exc:`NotImplementedError` When the *<port>* parameter is provided and
                 is no integer.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           bb = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_ServerAdd(self, *args)

    def ServerGet(self):
        r"""

        Returns all server connections within this API instance.  

        See :meth:`ServerAdd` for more information.  

        :return: a :class:`.ByteBlowerServerList` object

        Example

        .. code-block:: python
        	:emphasize-lines: 1
             server = bb.ServerGet()


        """
        return _byteblower.ByteBlower_ServerGet(self)

    def ServerRemove(self, inByteBlowerServer):
        return _byteblower.ByteBlower_ServerRemove(self, inByteBlowerServer)

    def ServerRemoveAll(self):
        return _byteblower.ByteBlower_ServerRemoveAll(self)

    def MeetingPointAdd(self, *args):
        r"""

        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  

        :raises: :exc:`.MeetingPointUnreachable` - When the  MeetingPoint server daemon
                 could not be reached. 
                 Typical causes are an incorrect or unreachable DNS name or IP address or a MeetingPoint server daemon that
                 is not running (on purpose or due to a software  issue).  
        :raises: <python_error> - Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  
        :raises: :exc:`NotImplementedError` - When the *<port>* 
                 parameter is provided and is no integer.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  

        :raises: :exc:`.MeetingPointUnreachable` - When the  MeetingPoint server daemon
                 could not be reached. 
                 Typical causes are an incorrect or unreachable DNS name or IP address or a MeetingPoint server daemon that
                 is not running (on purpose or due to a software  issue).  
        :raises: <python_error> - Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  
        :raises: :exc:`NotImplementedError` - When the *<port>* 
                 parameter is provided and is no integer.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  

        :raises: :exc:`.MeetingPointUnreachable` - When the  MeetingPoint server daemon
                 could not be reached. 
                 Typical causes are an incorrect or unreachable DNS name or IP address or a MeetingPoint server daemon that
                 is not running (on purpose or due to a software  issue).  
        :raises: <python_error> - Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  
        :raises: :exc:`NotImplementedError` - When the *<port>* 
                 parameter is provided and is no integer.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_MeetingPointAdd(self, *args)

    def MeetingPointGet(self):
        r"""

        Returns all Meeting Point connections within this API instance.  

        See :meth:`MeetingPointAdd` for more information  

        .. versionadded:: 2.6.0  

        :return: :class:`.MeetingPointList` with objects created within this API 
                 instance. Can be empty  

        Example

        .. code-block:: python

           meetingPoint = bb.MeetingPointGet()


        """
        return _byteblower.ByteBlower_MeetingPointGet(self)

    def MeetingPointRemove(self, inMeetingPoint):
        return _byteblower.ByteBlower_MeetingPointRemove(self, inMeetingPoint)

    def MeetingPointRemoveAll(self):
        return _byteblower.ByteBlower_MeetingPointRemoveAll(self)

    def ServerCount(self):
        return _byteblower.ByteBlower_ServerCount(self)

    def PortsStart(self, inPorts):
        r"""

        Starts all traffic streams and application schedules on the specified ByteBlower ports.  

        More specifically, for each traffic stream and schedulable object on the specified ports, the configured *time to wait* kicks off and when this time has passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or sending out a multicast join message or HTTP request. See :class:`.Stream` and :meth:`SchedulesStart` for more information.  

        Streams or schedulable objects that are already scheduled and streams that are already active are ignored. Schedulable objects that are already stopped are scheduled again. See :meth:`SchedulesStart` for more information.  

        If a port does not contain any streams or schedules, nothing happens for that port.   

        :param ports: :class:`.ByteBlowerPortList`

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<ports>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<ports>* is no ByteBlowerPort object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.PortsStart()



        """
        return _byteblower.ByteBlower_PortsStart(self, inPorts)

    def PortsStop(self, inPorts):
        r"""

        Stops all traffic streams and application schedules on the specified ByteBlower ports.  

        More specifically, all traffic streams and schedulable objects that are currently scheduled are cancelled and all active traffic streams are stopped. Since schedulable objects are only active for an instant, aborting these is not possible.  

        For more information about schedulable objects, see :meth:`SchedulesStart`.  

        Streams and schedules that are not running are ignored. This may be because they have not yet started or because they are already finished or stopped.  

        If a port does not contain any streams or schedules, nothing happens for that port.  

        :param args:  Zero, one or more ByteBlowerPort objects on which to abort traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject -  When one of the items in *<ports>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<ports>* is no ByteBlowerPort object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.PortsStop()



        """
        return _byteblower.ByteBlower_PortsStop(self, inPorts)

    def PortsStartAll(self):
        return _byteblower.ByteBlower_PortsStartAll(self)

    def PortsStopAll(self):
        return _byteblower.ByteBlower_PortsStopAll(self)

    def WirelessEndpointsStart(self, inWirelessEndpoints):
        r"""

        Starts all traffic streams and application schedules on the specified Wireless Endpoints.  

        More specifically, for each traffic stream and trigger object on the specified 
        endpoints, the configured *time to wait* kicks off and when this time has 
        passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or HTTP request. See 
        :class:`.StreamMobile` for more information.  If a wireless endpoint does not 
        contain any streams or schedules, nothing happens for that Wireless Endpoint.  

        :param wirelessEndpoints: a :class:`.WirelessEndpointList` object with zero, one or more WirelessEndpoint objects on which to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  


        """
        return _byteblower.ByteBlower_WirelessEndpointsStart(self, inWirelessEndpoints)

    def WirelessEndpointsStartAndWait(self, inWirelessEndpoints):
        r"""

        Starts all traffic streams and application schedules on the specified Wireless Endpoints And waits until the devices are started.  

        More specifically, for each traffic stream and trigger object on the specified endpoints, the configured *time to wait* kicks off and when this time has passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or HTTP request. See :class:`.StreamMobile` for more information.  

        If a wireless endpoint does not contain any streams or schedules, nothing happens for that Wireless Endpoint.  

        :param wireless_endpoints: Zero, one or more WirelessEndpont objects on which to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	bb.WirelessEndpointsStartAndWait()



        """
        return _byteblower.ByteBlower_WirelessEndpointsStartAndWait(self, inWirelessEndpoints)

    def WirelessEndpointsPrepare(self, inWirelessEndpoints):
        r"""

        Prepares all the specified Wireless Endpoints.  

        If a wireless endpoint does not contain any
        streams or schedules, nothing happens for that
        Wireless Endpoint.  

        :param wirelessEndpoints: a :class:`.WirelessEndpointList` object with zero, one or more WirelessEndpoint objects on which  to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in  *<wirelessEndpoints>* are spread across multiple MeetingPoints.  


        """
        return _byteblower.ByteBlower_WirelessEndpointsPrepare(self, inWirelessEndpoints)

    def WirelessEndpointsPrepareAsync(self, inWirelessEndpoints):
        r"""

        Prepares all the specified Wireless Endpoints in an asynchronious way.  

        If a wireless endpoint does not contain any streams or schedules, nothing happens for that Wireless Endpoint.  

        :param wirelessEndpoints: a :class:`.WirelessEndpointList` object with zero, one or more ByteBlowerPort objects on which to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.WirelessEndpointsPrepareAsync()



        """
        return _byteblower.ByteBlower_WirelessEndpointsPrepareAsync(self, inWirelessEndpoints)

    def ResultsRefresh(self, inResults):
        r"""

        Refreshes multiple result objects.  

        .. versionadded:: 2.2

        Sometimes you want to refresh a lot of results-objects at the same time. You can refresh all those objects in one API call. The results will be batched per server and then refreshed.  

        :return: nothing  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.ResultsRefresh()



        """
        return _byteblower.ByteBlower_ResultsRefresh(self, inResults)

    def SchedulesStart(self, inSchedules):
        r"""

        Starts the specified schedulable objects.  

        More specifically, all specified schedulable objects have their *time to wait* period kick off simultaneously and when this time has passed the corresponding action is performed.  

        Typical actions include sending out a multicast join message or an HTTP request. All schedulable objects are listed below.  

        Schedulable objects that are already scheduled are ignored. Schedulable objects that are already finished or cancelled are scheduled again.  

        While re-scheduling them will always succeed (and this method will return without error), executing them multiple times may result in error states in other places. For example, a :class:`HttpClient` can only manage one HTTP session and will refuse to send out a second HTTP request.   

        Different kinds of schedulable objects exist throughout the API. They are returned by methods such as :meth:`Igmpv1MemberSession.ScheduleAdd`.   

        After creating and configuring such schedules, they can be scheduled by either passing them to this method or by passing the port(s) on which they were created to :meth:`PortsStart`.  

        The following schedulable object types are available in the API:

        - :class:`IgmpScheduleIpMulticastListen`
        - :class:`IgmpSchedule.Join`
        - :class:`IgmpSchedule.Leave`  

        .. note:: Bug 
                  HTTP requests are not yet available as a schedulable object and cannot be used with this method. 

        :param schedules: Zero, one or more schedulable objects to start.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<schedules>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<schedules>* is no schedulable object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.SchedulesStart()



        """
        return _byteblower.ByteBlower_SchedulesStart(self, inSchedules)

    def SchedulesStop(self, inSchedules):
        r"""

        Stops the specified schedulable objects.  

        More specifically, all specified schedulable objects that are currently 
        scheduled are cancelled. Schedulable objects are only active for an instant, so
        actually aborting them is not possible.  

        For more information about schedulable objects, see :meth:`SchedulesStart`.  

        Schedules that are not running are ignored. This may be because they have not
        yet started or because they are already finished or cancelled.  

        :param inSchedules: Zero, one or more schedulable objects to abort.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items
                 in *<schedules>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items 
                 in *<schedules>* is no schedulable object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1
        	bb.SchedulesStop()



        """
        return _byteblower.ByteBlower_SchedulesStop(self, inSchedules)

    def ScheduleGroupCreate(self):
        r"""

        Create a ScheduleGroup.  

        :return: :class:`ScheduleGroup`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.ScheduleGroupCreate()


        """
        return _byteblower.ByteBlower_ScheduleGroupCreate(self)

    def ScheduleGroupGet(self):
        r"""

        Returns all existing ScheduleGroup.  

        :return: :class:`ScheduleGroupList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	scheduleGroup = bb.ScheduleGroupGet('byteblower-1.lab.byteblower.com')

        """
        return _byteblower.ByteBlower_ScheduleGroupGet(self)

    @staticmethod
    def DestroyInstance():
        return _byteblower.ByteBlower_DestroyInstance()

# Register ByteBlower in _byteblower:
_byteblower.ByteBlower_swigregister(ByteBlower)

def ByteBlower_InstanceGet():
    r"""

    Creates or returns the ByteBlower API singleton instance.  

    This object is the entry point to start working with the ByteBlower Python API.  

    If no ByteBlower instance is created yet, this method creates one and returns the object. If the instance exists already, it is simply returned.
    Any other static call will implicitly instantiate this singleton object.  

    :return:  ByteBlower singleton instance.  

    Example

    .. code-block:: python

       instance = bb.InstanceGet()


    """
    return _byteblower.ByteBlower_InstanceGet()

def ByteBlower_DestroyInstance():
    return _byteblower.ByteBlower_DestroyInstance()


def BB():
    return _byteblower.BB()
class User(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NameGet(self):
        return _byteblower.User_NameGet(self)

    def InterfaceGet(self):
        return _byteblower.User_InterfaceGet(self)

# Register User in _byteblower:
_byteblower.User_swigregister(User)

class UserMobile(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NameGet(self):
        return _byteblower.UserMobile_NameGet(self)

    def UUIDGet(self):
        return _byteblower.UserMobile_UUIDGet(self)

# Register UserMobile in _byteblower:
_byteblower.UserMobile_swigregister(UserMobile)

class StreamResultSnapshot(AbstractRefreshableResult):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.TimestampGet())

        """
        return _byteblower.StreamResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this snapshot  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_snapshot.TimestampFirstGet())

        """
        return _byteblower.StreamResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_snapshot.TimestampLastGet())

        """
        return _byteblower.StreamResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.  

        Example

        This example gets the transmitted packets  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.PacketCountGet())

        """
        return _byteblower.StreamResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.  

        Example
        This example gets the transmitted bytes  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.ByteCountGet())

        """
        return _byteblower.StreamResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size transmitted in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.5.0  

        Example


        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.FramesizeMaximumGet()) 


        """
        return _byteblower.StreamResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest frame size transmitted in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.5.0  

        Example

        This example gets the smallest frame size transmitted in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.FramesizeMinimumGet())

        """
        return _byteblower.StreamResultSnapshot_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.IntervalDurationGet())

        """
        return _byteblower.StreamResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.  

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.RefreshTimestampGet())

        """
        return _byteblower.StreamResultSnapshot_RefreshTimestampGet(self)

# Register StreamResultSnapshot in _byteblower:
_byteblower.StreamResultSnapshot_swigregister(StreamResultSnapshot)

class StreamResultData(AbstractObject):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.TimestampGet())


        """
        return _byteblower.StreamResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is 
                 unavailable  

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Gets the timestamp of the first transmitted packet in this snapshot

            print(streamData.TimestampLastGet())

        """
        return _byteblower.StreamResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  


        Example

        This example gets the timestamp [NS] of the last transmitted packet in this snapshot  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.TimestampLastGet())

        """
        return _byteblower.StreamResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.  

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the transmitted packets

            print(streamData.PacketCountGet())

        """
        return _byteblower.StreamResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.  

        Example

        This example gets the transmitted bytes  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.ByteCountGet())


        """
        return _byteblower.StreamResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest framesize transmitted in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.6.4  

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the largest framesize transmitted in this snapshot

            print(streamData.FramesizeMaximumGet())

        """
        return _byteblower.StreamResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest framesize transmitted in this snapshot  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.6.4  


        Example 

        This example gets the smallest framesize transmitted in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.FramesizeMinimumGet())


        """
        return _byteblower.StreamResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.IntervalDurationGet())


        """
        return _byteblower.StreamResultData_IntervalDurationGet(self)

# Register StreamResultData in _byteblower:
_byteblower.StreamResultData_swigregister(StreamResultData)

class StreamResultList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamResultList___bool__(self)

    def __len__(self):
        return _byteblower.StreamResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamResultList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StreamResultList_pop(self)

    def append(self, x):
        return _byteblower.StreamResultList_append(self, x)

    def empty(self):
        return _byteblower.StreamResultList_empty(self)

    def size(self):
        return _byteblower.StreamResultList_size(self)

    def swap(self, v):
        return _byteblower.StreamResultList_swap(self, v)

    def begin(self):
        return _byteblower.StreamResultList_begin(self)

    def end(self):
        return _byteblower.StreamResultList_end(self)

    def rbegin(self):
        return _byteblower.StreamResultList_rbegin(self)

    def rend(self):
        return _byteblower.StreamResultList_rend(self)

    def clear(self):
        return _byteblower.StreamResultList_clear(self)

    def get_allocator(self):
        return _byteblower.StreamResultList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StreamResultList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StreamResultList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.StreamResultList_swiginit(self, _byteblower.new_StreamResultList(*args))

    def push_back(self, x):
        return _byteblower.StreamResultList_push_back(self, x)

    def front(self):
        return _byteblower.StreamResultList_front(self)

    def back(self):
        return _byteblower.StreamResultList_back(self)

    def assign(self, n, x):
        return _byteblower.StreamResultList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StreamResultList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StreamResultList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StreamResultList_reserve(self, n)

    def capacity(self):
        return _byteblower.StreamResultList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StreamResultList

# Register StreamResultList in _byteblower:
_byteblower.StreamResultList_swigregister(StreamResultList)

class StreamResultHistory(AbstractRefreshableResult):
    r"""

    Sender-side transmit result history.  

    The history contains the sender information in time since the object is created
    or refreshed. 

    ..note :: The information is not updated until :meth:`Refresh` is called  

    A Stream history result object can be created via a :class:`Stream`, using
    :meth:`Stream.ResultHistoryGet`  

    .. note:: See History result for more information  

    .. versionadded:: 2.1.0  

    Example

    Get the counters per *sampling interval* for the stream result history.  

    .. code-block:: python
       :emphasize-lines: 3

    	stream_result_history = stream.ResultHistoryGet()
    	print(stream_snapshot.TimestampFirstGet())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.  

        :return: int Duration in nanoseconds  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.SamplingIntervalDurationGet())

        """
        return _byteblower.StreamResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.SamplingBufferLengthGet())

        """
        return _byteblower.StreamResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.  

        .. warning:: The previously collected history will be invalidated.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            stream_result_history.SamplingIntervalDurationSet(3000000)

        """
        return _byteblower.StreamResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            stream_result_history.SamplingBufferLengthSet(5)

        """
        return _byteblower.StreamResultHistory_SamplingBufferLengthSet(self, inLength)

    def Clear(self):
        r"""

        Clear the history.  

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can
        execute this method. Both Interval and Cumulative counter lists will be 
        cleared.

        Example

        Clear the History.  

        .. code-block:: python
           :emphasize-lines: 1

        	stream_result_history.Clear()

        """
        return _byteblower.StreamResultHistory_Clear(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be 
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.StreamResultDataList` containing the Cumulative counters  

        Example
        This example gets the available accumulated results  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_result_history.CumulativeGet()[0].DescriptionGet())  

        """
        return _byteblower.StreamResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.  

        :param index: index

        :return: :class:`.StreamResultData` cumulative counter object at the specified
                 index  

        Example

        This example gets the available cumulative counters at index 1  

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           print(stream_snapshot.CumulativeGetByIndex(1).DescriptionGet())

        """
        return _byteblower.StreamResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.  

        :param timestamp: int : timestamp in nanoseconds

        :return: :class:`.StreamResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_result_history.CumulativeGetByTime(1432805398000000000))

        """
        return _byteblower.StreamResultHistory_CumulativeGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.  

        :return: :class:`.StreamResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Cumulative counter object  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.CumulativeLatestGet().DescriptionGet())

        """
        return _byteblower.StreamResultHistory_CumulativeLatestGet(self)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.  

        :return:  The length of the cumulative list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_result_history.CumulativeLengthGet())

        """
        return _byteblower.StreamResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.  

        Each result object contains interval counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.StreamResultDataList` containing the Interval counters  

        Example

        This example gets the available interval results  

        .. code-block:: python
           :emphasize-lines: 1

        	stream_result_history.IntervalGet()

        """
        return _byteblower.StreamResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.  

        :param index: index

        :return: :class:`S.tream.ResultData` interval counter object at the specified
                 index  

        Example

        This example gets the available interval counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalGetByIndex(1).DescriptionGet())

        """
        return _byteblower.StreamResultHistory_IntervalGetByIndex(self, index)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.  

        :param timestamp: int: timestamp in nanoseconds

        :return: :class:`.StreamResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns   

        .. code-block:: python
           :emphasize-lines: 1

        	interval = stream_result_history.IntervalGetByTime(1432805398000000000)

        """
        return _byteblower.StreamResultHistory_IntervalGetByTime(self, timestamp)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.  

        :return: :class:`.StreamResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Interval counter object  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalLatestGet().DescriptionGet())

        """
        return _byteblower.StreamResultHistory_IntervalLatestGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.  

        :return:  The length of the interval list  

        Example


        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalLengthGet())

        """
        return _byteblower.StreamResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.  

        This is the timestamp on the server when the last :meth:`Refresh` was called.  

        :return: Timestamp in nanoseconds since epoch  

        Example

        This example gets the Refresh timestamp  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.RefreshTimestampGet())

        """
        return _byteblower.StreamResultHistory_RefreshTimestampGet(self)

# Register StreamResultHistory in _byteblower:
_byteblower.StreamResultHistory_swigregister(StreamResultHistory)

class StreamRuntimeStatus(AbstractRefreshableResult):
    r"""

    Status information about a Stream

    A stream has some runtime status information:

    Is the stream running (:meth:`StatusGet`)?

    If not, was there an error (:meth:`ErrorStatusGet`)?

    If so, where did the error came from (:meth:`ErrorSourceGet`)?

    Example

    .. code-block:: python

       # stream is configured to transmit for 1 second

       status = stream.StatusGet()
       print('Stream stopped?', status.StatusGet() == TransmitStatus.INACTIVE)

       stream.Start()

       status.Refresh()
       print('Stream started?', status.StatusGet() == TransmitStatus.ACTIVE)   

       time.sleep(1)

       status.Refresh()
       print('Stream stopped?', status.StatusGet() == TransmitStatus.INACTIVE)   


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    transmit_error_status_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_status_UNKNOWN
    transmit_error_status_NONE = _byteblower.StreamRuntimeStatus_transmit_error_status_NONE
    transmit_error_status_OUT_OF_RESOURCES = _byteblower.StreamRuntimeStatus_transmit_error_status_OUT_OF_RESOURCES
    transmit_error_source_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_source_UNKNOWN
    transmit_error_source_NONE = _byteblower.StreamRuntimeStatus_transmit_error_source_NONE
    transmit_error_source_INTERFACE_HARDWARE = _byteblower.StreamRuntimeStatus_transmit_error_source_INTERFACE_HARDWARE
    transmit_error_source_SCHEDULING_CONFLICT = _byteblower.StreamRuntimeStatus_transmit_error_source_SCHEDULING_CONFLICT
    transmit_error_source_TXUSER = _byteblower.StreamRuntimeStatus_transmit_error_source_TXUSER
    transmit_status_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_status_UNKNOWN
    transmit_status_INACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_INACTIVE
    transmit_status_ACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_ACTIVE

    def StatusGet(self):
        r"""

        Returns the stream status.  

        This way one can determine if a stream is still running or whether the stream 
        finished

        :return: The current status of the stream.
        :rtype: :class:`TransmitStatus`  

        """
        return _byteblower.StreamRuntimeStatus_StatusGet(self)

    def ErrorStatusGet(self):
        r"""

        Returns error information.

        A stream can finish without issues, but can also run into error conditions.
        One of those error conditions is e.g. *Out-Of-Resources*.   This means that
        one tries to transmit e.g. more than 1Gbps over a 1Gbps link.

        :return: The error information of the stream if applicable.
        :rtype: :class:`TransmitErrorStatus`

        """
        return _byteblower.StreamRuntimeStatus_ErrorStatusGet(self)

    def ErrorSourceGet(self):
        r"""

        Returns error source information.  

        If :meth:`ErrorStatusGet` does not return :attr:`TransmitErrorStatus.NONE`, the
        returned value of this method will indicate a reason why the error state is 
        returned.

        :return: The source of the error.
        :rtype:  :class:`TransmitErrorSource`

        """
        return _byteblower.StreamRuntimeStatus_ErrorSourceGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the information was last queried on the server.

        :return: The timestamp since epoch in nanoseconds
        :rtype: int

        .. code-block:: python
           :emphasize-lines: 3, 8

           # ...
           status_object = stream.StatusGet()
           print(status_object.RefreshTimestampGet())
           # Prints: 1559736027345545000

           time.sleep(1)

           print(status_object.RefreshTimestampGet())
           # Prints: 1559736028345545000

        """
        return _byteblower.StreamRuntimeStatus_RefreshTimestampGet(self)

# Register StreamRuntimeStatus in _byteblower:
_byteblower.StreamRuntimeStatus_swigregister(StreamRuntimeStatus)


def ConvertRuntimeTransmitStatus(inStatus):
    return _byteblower.ConvertRuntimeTransmitStatus(inStatus)

def ConvertRuntimeTransmitErrorStatus(inStatus):
    return _byteblower.ConvertRuntimeTransmitErrorStatus(inStatus)

def ConvertRuntimeTransmitErrorSource(inSource):
    return _byteblower.ConvertRuntimeTransmitErrorSource(inSource)
class Stream(AbstractObject):
    r"""

    A ByteBlower stream is an object representing a stream of ByteBlower frames (Frame) used for transmission on a ByteBlower port.

    A ByteBlower stream contains the following data:

    Frames
        A list of Frame objects

    NumberOfFrames
        The number of frames the stream should  transmit

    InterFrameGap
        The inter frame gap between 2 transmitted frames

    InitialTimeToWait
        An initial time to wait, if needed

    TimingModifier
        A timing modifier

    Example

    .. code-block:: python
       :emphasize-lines: 1
       :caption: A typical stream usage flow

       stream = port.TxStreamAdd()
       stream.NumberOfFramesSet(1000)
       stream.InterFrameGapSet(1000000)

       frame = stream.FrameAdd()
       # Configure the frame ...

       stream.Start()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        r"""

        Returns the parent ByteBlower Port on which the stream was created

        :return: The parent port
        :rtype: :class:`.ByteBlowerPort`

        .. todo:: Shouldn't we remove this function, it is not available in the TCL
                  API either

        """
        return _byteblower.Stream_PortGet(self)

    def NumberOfFramesGet(self):
        r"""

        Gets the configured number of frames the stream needs to transmit

        :return: The configured number of frames
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames configured on the stram.

           print(stream.NumberOfFramesGet())


        """
        return _byteblower.Stream_NumberOfFramesGet(self)

    def NumberOfFramesSet(self, nof):
        r"""

        Sets the number of frames the stream needs to transmit.

        This defines the number of frames a stream will send. -1 means continues.

        :param count: The number of frames to set. Use -1 to send infinitely.
        :type count: int

        .. note:: when count is set -1, keep in mind to stop the stream using
                  :meth:`Stop`

        Example

        This example sets the frame count of the stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the number frames to transmit to 1000

           stream.NumberOfFramesAdd(1000)

        """
        return _byteblower.Stream_NumberOfFramesSet(self, nof)

    def InterFrameGapGet(self):
        r"""

        Returns the inter-frame gap for the stream.

        :return: The inter-frame gap is returned in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: print the inter frame gap of the stream

           print(stream.InterFrameGapGet())


        """
        return _byteblower.Stream_InterFrameGapGet(self)

    def InterFrameGapSet(self, interFrameGap):
        r"""

        Sets the inter-frame gap for the stream.

        :param duration: Duration in nanoseconds
        :type duration: int

        Example

        This example sets the inter-frame gap on a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure the stream to send 10 frames per second

           stream.InterFrameGapSet(inter_frame_gap)

        """
        return _byteblower.Stream_InterFrameGapSet(self, interFrameGap)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the time to wait before the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int

        Example

        This example gets the current initial time to wait from a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Print the initial time to wait for a stream

           print(stream.InitialTimeToWaitGet())

        """
        return _byteblower.Stream_InitialTimeToWaitGet(self)

    def InitialTimeToWaitSet(self, initTimeToWait):
        r"""

        Sets a delay before sending the first frame.

        :param duration: The duration in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: sets initial time to wait to 2 seconds

           stream.InitialTimeToWaitSet(wait)

        """
        return _byteblower.Stream_InitialTimeToWaitSet(self, initTimeToWait)

    def Start(self):
        r"""

        Starts the stream.

        The stream will be started when this method is called. This will also cause the
        results for the stream and attached frames to be cleared. The objects of the
        types below will thus be cleared.

        - :class:`.StreamResultSnapshot`
        - :class:`.StreamResultHistory`
        - :class:`.FrameResultSnapshot`
        - :class:`.FrameResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1


           stream.Start()

        """
        return _byteblower.Stream_Start(self)

    def Stop(self):
        r"""

        Stops the stream.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.Stop()

        """
        return _byteblower.Stream_Stop(self)

    def ResultClear(self):
        r"""

        Resets the current result counters to zero and empties the ResultHistory.

        .. versionadded:: 2.1.0

        Calling this method causes the :class:`StreamResultSnapshot` and the
        :class:`.StreamResultHistory` to be reset.

        All counters will be set to zero and all historic data in the history will be
        removed.

        Example

        .. code-block:: python
           :emphasize-lines: 6
           :caption: shows how ResultClear() affects the results from ResultGet()

           stream.ResultClear()


        """
        return _byteblower.Stream_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: The current cumulative stream result counters
        :rtype: :class:`.StreamResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultGet().DescriptionGet())

        """
        return _byteblower.Stream_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        :return: :class:`.StreamResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultHistoryGet().DescriptionGet())

        """
        return _byteblower.Stream_ResultHistoryGet(self)

    def FrameAdd(self):
        r"""

        Adds a frame to the stream.

        :return: The freshly added frame
        :rtype: :class:`.Frame`

        Example

        This example adds a frame to a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Add a frame to the stream.

           frame = stream.FrameAdd()

        """
        return _byteblower.Stream_FrameAdd(self)

    def FrameGet(self):
        r"""

        Returns list of frames on this stream.

        :return: A list of added frames.
        :rtype: :class:`FrameList`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Iterate over the added frames and print their description

           for frame in stream.FrameGet():
               print(frame.DescriptionGet())

        """
        return _byteblower.Stream_FrameGet(self)

    def FrameDestroy(self, inFrame):
        r"""

        Removes a frame from the stream

        :param frame: The frame object to remove
        :type frame: :class:`.Frame`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Iterate over the added frames and print their description

           stream.FrameDestroy(frame1)



        """
        return _byteblower.Stream_FrameDestroy(self, inFrame)

    def RandomSizeModifierAdd(self):
        r"""

        Adds a Random Size modifier to the stream

        .. deprecated:: 2.3.0
           This is deprecated.  Please use :meth:`.Frame.ModifierSizeRandomSet`

        .. note:: The name for this function is actually wrong.  A new size modifier
                  will replace existing size modifiers

        :return: The freshly created random size modifier
        :rtype: :class:`.StreamRandomSizeModifier`

        """
        return _byteblower.Stream_RandomSizeModifierAdd(self)

    def GrowingSizeModifierAdd(self):
        r"""

        Adds a Growing Size modifier to the stream

        .. deprecated:: 2.3.0
           This is deprecated.  Please use :meth:`.Frame.ModifierSizeGrowingSet`

        .. note:: The name for this function is actually wrong.  A new size modifier
                  will replace existing size modifiers

        :return: The freshly created growing size modifier
        :rtype: :class:`.StreamGrowingSizeModifier`


        """
        return _byteblower.Stream_GrowingSizeModifierAdd(self)

    def MultipleBurstModifierAdd(self):
        r"""

        Sets a burst modifier on the stream.

        This timing modifier will cause the stream to send *bursty* traffic.
        See :class:`MultipleBurstModifier` for configurable parameters.

        .. note:: The actual name of this method is wrong, a new modifier will remove a previous one.

        :return: The freshly created modifier
        :rtype: :class:`.MultipleBurstModifier`

        """
        return _byteblower.Stream_MultipleBurstModifierAdd(self)

    def NormalDistributionTimingModifierAdd(self):
        r"""

        Sets a normal distribution modifier on the stream.

        See :class:`NormalDistributionTimingModifier` for configurable parameters.

        .. note:: The actual name of this method is wrong, a new modifier will remove a previous one.

        :return: The freshly created modifier
        :rtype: :class:`.NormalDistributionTimingModifier`

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints the number of frames configured on the stram.

           normalDistribution = port.NormalDistributionTimingModifierAdd()


        """
        return _byteblower.Stream_NormalDistributionTimingModifierAdd(self)

    def ModifierFrameGet(self):
        r"""

        Gets the configured frame modifiers

        .. deprecated: 2.3.0
           Instead of creating frame modifying objects on the stream, create them on
           the :class:`Frame` directly.
           See: :meth:`.Frame.ModifierSizeGrowingGet` and
           :meth:`Frame.ModifierSizeRandomGet`

        :return: The current frame modifier.
        :rtype: if 'growing', A :class:`StreamGrowingSizeModifier` object.
                If 'random',  A :class:`StreamRandomSizeModifier` object.

        :return: The configured modifiers

        """
        return _byteblower.Stream_ModifierFrameGet(self)

    def ModifierFrameDestroy(self):
        r"""

        Destroys a frame modifier (e.g. size-modfier).

        .. deprecated: 2.3.0
           Instead of creating frame modifying objects on the stream, create them on
           the :class:`Frame` directly

        :param modifier: Modifier to remove
        :type modifier: Modifier

        """
        return _byteblower.Stream_ModifierFrameDestroy(self)

    def ModifierTimingGet(self):
        r"""

        Gets the configured timing modifier

        :return: Configured timing modifier
        :rtype: :class:`NormalDistributionTimingModifier` or a :class:`MultipleBurstModifier`

        """
        return _byteblower.Stream_ModifierTimingGet(self)

    def ModifierTimingDestroy(self):
        r"""

        Removes a timing modifier

        :param modifier: Modifier to remove
        :type modifier: :class:`NormalDistributionTimingModifier` or a :class:`MultipleBurstModifier`

        """
        return _byteblower.Stream_ModifierTimingDestroy(self)

    def StatusGet(self):
        r"""

        Returns status information.

        :return: :class:`.StreamRuntimeStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.StatusGet()

        """
        return _byteblower.Stream_StatusGet(self)

# Register Stream in _byteblower:
_byteblower.Stream_swigregister(Stream)

class StreamMobile(AbstractObject):
    r"""

    A StreamMobile object configures a stream of frames that will be transmitted by a
    WirelessEndpoint.

    The StreamMobile object allows you to add frame objects (:class:`FrameMobile`)
    and configure parameters like the number of frames that will be transmitted,
    the inter-frame gap and the initial time to wait before transmission.

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :caption: Typical usage flow

       frame_size = 1000  # bytes

       stream = wirelessEndpoint.TxStreamAdd()
       stream.NumberOfFramesSet(100)

       # Transmit at 10 frames per second, which is 100 milliseconds per frame
       stream.InterFrameGapSet(10000000)

       stream.DestinationAddressSet('192.168.0.2')
       stream.DestinationPortSet(4000)
       stream.SourcePortSet(4001)

       # Add a frame
       frame = stream.FrameAdd()

       # ... configure the frame, see FrameMobile documentation for this.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NumberOfFramesGet(self):
        r"""

        Returns the number of frames that will be transmitted by a stream.

        :return: the number of frames that will be transmitted by the stream
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames to be transmitted by a stream

           print(stream.NumberOfFramesGet())


        """
        return _byteblower.StreamMobile_NumberOfFramesGet(self)

    def NumberOfFramesSet(self, nof):
        r"""

        Sets the number of frames sent by a stream.

        This method configures the number of frames a stream will transmit.

        :param count: The number of frames to send.
        :type count: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example sets the frame count of the stream.

           stream.NumberOfFramesSet(1000)

        """
        return _byteblower.StreamMobile_NumberOfFramesSet(self, nof)

    def InterFrameGapGet(self):
        r"""

        Returns the inter-frame gap for the stream.

        :return: The inter-frame gap is returned in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the inter-frame gap of a stream

           print(stream.InterFrameGapGet())


        """
        return _byteblower.StreamMobile_InterFrameGapGet(self)

    def InterFrameGapSet(self, interFrameGap):
        r"""

        Sets the inter-frame gap for the stream.

        :param duration: duration in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the inter-frame gap to 100ms


           stream.InterFrameGapSet(gap)


        """
        return _byteblower.StreamMobile_InterFrameGapSet(self, interFrameGap)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the time to wait before the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: get the current initial time to wait

           print(stream.InitialTimeToWaitGet())


        """
        return _byteblower.StreamMobile_InitialTimeToWaitGet(self)

    def InitialTimeToWaitSet(self, initTimeToWait):
        r"""

        Sets a delay before sending the first frame.

        :param duration: The amount of time to wait before sending the first frame
                         Unit is in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: set the initial time to wait to 2 seconds

           stream.InitialTimeToWaitSet(wait)


        """
        return _byteblower.StreamMobile_InitialTimeToWaitSet(self, initTimeToWait)

    def ResultClear(self):
        r"""

        Clears the results.

        .. note:: This affects the all results for a stream.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Resets the current result counters to zero.

           stream.ResultClear()

        """
        return _byteblower.StreamMobile_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: The cumulative results for the stream
        :rtype: :class:`StreamResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultGet().DescriptionGet())


        """
        return _byteblower.StreamMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        :return: The history counters for the stream
        :rtype: :class:`StreamResultHistory`

        .. code-block:: python
           :emphasize-lines: 1

           history = stream.ResultHistoryGet()


        """
        return _byteblower.StreamMobile_ResultHistoryGet(self)

    def FrameAdd(self):
        r"""

        Adds a frame to the stream.

        :return: The newly created frame
        :rtype: :class:`.FrameMobile`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example adds a frame to a stream.

           stream.FrameAdd()

        """
        return _byteblower.StreamMobile_FrameAdd(self)

    def FrameGet(self):
        r"""

        Returns list of frames on this stream.

        :return: A list of all configured frames on the stream
        :rtype: :class:`.FrameMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints all configured frames on a stream

           for frame in stream.FrameGet():
               print(frame.DescriptionGet())


        """
        return _byteblower.StreamMobile_FrameGet(self)

    def FrameDestroy(self, inFrame):
        return _byteblower.StreamMobile_FrameDestroy(self, inFrame)

    def SourcePortSet(self, inPort):
        r"""

        Sets the source port in the UDP header of the frames that will be transmitted.

        :param port: The UDP source port number for the transmitted frames (1-65535)
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.SourcePortSet(8000)


        """
        return _byteblower.StreamMobile_SourcePortSet(self, inPort)

    def SourcePortGet(self):
        r"""

        Returns the source port in the UDP header of the frames that will be
        transmitted.

        :return: The UDP source port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example gets the UDP source port of a stream

           print('UDP source:', stream.SourcePortGet())


        """
        return _byteblower.StreamMobile_SourcePortGet(self)

    def DestinationAddressSet(self, inAddress):
        r"""

        Sets the destination address in the IP header of the frames that will be
        transmitted.

        :param address: The destination IPv4 or IPv6 address to send the frames to.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: set an IPv4 destination

           stream.DestinationAddressSet('192.168.0.4')

        """
        return _byteblower.StreamMobile_DestinationAddressSet(self, inAddress)

    def DestinationAddressGet(self):
        r"""

        Returns the destination address in the IP header of the frames that will be
        transmitted.

        :return: the Destination IP address the frames will be sent to
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.DestinationAddressGet())


        """
        return _byteblower.StreamMobile_DestinationAddressGet(self)

    def DestinationPortSet(self, inDestinationPort):
        r"""

        Sets the destination port in the UDP header of the frames that will be
        transmitted.

        :param portnumber: UDP destination port to send the frame to (1-65535)
        :type portnumber: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.DestinationPortSet(4000)


        """
        return _byteblower.StreamMobile_DestinationPortSet(self, inDestinationPort)

    def DestinationPortGet(self):
        r"""

        Returns the destination port in the UDP header of the frames that will be
        transmitted.

        :return: The UDP destination port that will be used.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.DestinationPortGet())


        """
        return _byteblower.StreamMobile_DestinationPortGet(self)

    def TypeOfServiceGet(self):
        r"""

        Returns the type-of-service field (or TOS bits) in the IP header of the frames
        that will be transmitted.

        :return: The contents of the Type-Of-Service field.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example gets the current TOS field.

           print('TOS set to:', stream.TypeOfServiceGet())


        """
        return _byteblower.StreamMobile_TypeOfServiceGet(self)

    def TypeOfServiceSet(self, inTos):
        r"""

        Sets the type-of-service field (or TOS bits) in the IP header of the frames
        that will be transmitted.

        :param tos: The contents of the type-of-service field in the IP header
        :type tos: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.TypeOfServiceSet(2)


        """
        return _byteblower.StreamMobile_TypeOfServiceSet(self, inTos)

# Register StreamMobile in _byteblower:
_byteblower.StreamMobile_swigregister(StreamMobile)

class Schedule(AbstractObject):
    r"""

    This class contains the base functionality to configure a scheduled action.

    Schedulable objects can be obtained, for example by calling
    HttpClient.ScheduleGet(). The returned object is schedulable.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.Schedule_ServerGet(self)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the time when the action is scheduled. This time is set using
        :meth:`InitialTimeToWaitSet` At that time, the first frame will be sent.

        :return: The initial time to wait in nanoseconds.

        """
        return _byteblower.Schedule_InitialTimeToWaitGet(self)

    def InitialTimeToWaitSet(self, ns):
        r"""

        Sets the time when the action will be scheduled. That is, when the first frame
        will be sent.

        :param time: The time when the action will be scheduled.
                     Valid range: 0 to *max_uint64* [ns]
        :type time: int

            Where *<max_uint64>*    0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            ( = maximum unsigned 64bit integer)

        Sets the initial time to wait before the first frame will be sent. By default,
        the unit has a nanosecond resolution. But you can also provide a time unit.

        The schedule can be started using :meth:`Start`

        :raises: python_error: Failed to parse time string: When the value could not be
                 interpreted as a valid time string

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the initial time to wait to 9 nanoseconds

           schedule.InitialTimeToWaitSet(9)


        """
        return _byteblower.Schedule_InitialTimeToWaitSet(self, ns)

    def Prepare(self):
        return _byteblower.Schedule_Prepare(self)

    def Start(self):
        r"""

        Starts the scheduled action.

        The first packet will be sent after the initial time to wait.

        """
        return _byteblower.Schedule_Start(self)

    def Stop(self):
        r"""

        Stops the running scheduled action.

        If the action has not been started, nothing will happen.

        """
        return _byteblower.Schedule_Stop(self)

    def GetSchedulableObject(self):
        return _byteblower.Schedule_GetSchedulableObject(self)

# Register Schedule in _byteblower:
_byteblower.Schedule_swigregister(Schedule)

class Rx(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FilterSet(self, inFilter):
        return _byteblower.Rx_FilterSet(self, inFilter)

    def FilterGet(self):
        return _byteblower.Rx_FilterGet(self)

# Register Rx in _byteblower:
_byteblower.Rx_swigregister(Rx)

class TaggedRx(Rx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FrameTagGet(self):
        return _byteblower.TaggedRx_FrameTagGet(self)

    def FrameTagSet(self, fromFrameTagTx):
        return _byteblower.TaggedRx_FrameTagSet(self, fromFrameTagTx)

    def FrameTagDefaultSet(self):
        return _byteblower.TaggedRx_FrameTagDefaultSet(self)

# Register TaggedRx in _byteblower:
_byteblower.TaggedRx_swigregister(TaggedRx)

class Capture(Rx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FileNameRemoteGet(self):
        return _byteblower.Capture_FileNameRemoteGet(self)

    def Start(self):
        return _byteblower.Capture_Start(self)

    def Stop(self):
        return _byteblower.Capture_Stop(self)

    def ResultGet(self):
        return _byteblower.Capture_ResultGet(self)

# Register Capture in _byteblower:
_byteblower.Capture_swigregister(Capture)

class SchedulableObject(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_SchedulableObject

    def ScheduleStart(self):
        return _byteblower.SchedulableObject_ScheduleStart(self)

    def ScheduleStop(self):
        return _byteblower.SchedulableObject_ScheduleStop(self)

    def ScheduleRemove(self, inSchedule):
        return _byteblower.SchedulableObject_ScheduleRemove(self, inSchedule)

    def ScheduleRemoveAll(self):
        return _byteblower.SchedulableObject_ScheduleRemoveAll(self)

    def ScheduleGet(self):
        return _byteblower.SchedulableObject_ScheduleGet(self)

    def ServerGet(self):
        return _byteblower.SchedulableObject_ServerGet(self)

# Register SchedulableObject in _byteblower:
_byteblower.SchedulableObject_swigregister(SchedulableObject)

class Layer25Configuration(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.Layer25Configuration_PortGet(self)

# Register Layer25Configuration in _byteblower:
_byteblower.Layer25Configuration_swigregister(Layer25Configuration)

class DHCPv4SessionInfo(AbstractObject):
    r"""

    Class containing the info about the DHCPSession.

    This class represents the session info gathered from a DHCPSession. It will
    contain counters of the amount of DHCPMessages transmitted and received. It
    also contains some values of the obtained lease ( leasetime, GiAddr, SiAddr,
    OptionValues )

    .. code-block:: python
       :emphasize-lines: 2

       session_info = protocol.DHCPv4SessionInfoGet()
       for option in info.DHCPOptionGet():
    		print(option)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxGet(self):
        r"""

        Returns the number of DHCPMessages transmitted.

        :return: Number of DHCP messages transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info)

        """
        return _byteblower.DHCPv4SessionInfo_TxGet(self)

    def RxGet(self):
        r"""

        Returns the number of DHCPMessages recieved.

        :return:  Number of DHCP messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info)

        """
        return _byteblower.DHCPv4SessionInfo_RxGet(self)

    def DHCPOptionGet(self):
        r"""

        Returns a list if received DHCPOptions.

        :return: List of DHCPOptions in the form of OptionNumber-Value

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for option in session_info.DHCPOptionGet:
        		print(option)

        """
        return _byteblower.DHCPv4SessionInfo_DHCPOptionGet(self)

    def SiAddrGet(self):
        r"""

        Returns the IP address of next server to use in bootstrap.

        :return: next server IP address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(session_info.SiAddrGet())

        """
        return _byteblower.DHCPv4SessionInfo_SiAddrGet(self)

    def GiAddrGet(self):
        r"""

        Returns the ipAddress of the relay agent, used in booting via a relay agent.

        :return: Relay agent IP address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.GiAddrGet())


        """
        return _byteblower.DHCPv4SessionInfo_GiAddrGet(self)

    def DHCPServerAddrGet(self):
        r"""

        Returns the ipAddress of the DHCPServer.

        This address is parsed out of DHCPServerIdentifier option ( Option 54 )

        :return: Address of the DHCP server
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.DHCPServerAddrGet())

        """
        return _byteblower.DHCPv4SessionInfo_DHCPServerAddrGet(self)

    def LeaseTimeGet(self):
        r"""

        Returns IP Address lease time.

        :return: The leasetime in NanoSeconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.LeaseTimeGet())

        """
        return _byteblower.DHCPv4SessionInfo_LeaseTimeGet(self)

    def TransactionIDGet(self):
        return _byteblower.DHCPv4SessionInfo_TransactionIDGet(self)

    def DiscoverTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Discover message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.DiscoverTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_DiscoverTimestampLastGet(self)

    def OfferTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Offer message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.OfferTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_OfferTimestampLastGet(self)

    def RequestTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Request message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RequestTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_RequestTimestampLastGet(self)

    def AckTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Ack message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.AckTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_AckTimestampLastGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :return: RefreshTimestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RefreshTimestampGet())


        """
        return _byteblower.DHCPv4SessionInfo_RefreshTimestampGet(self)

# Register DHCPv4SessionInfo in _byteblower:
_byteblower.DHCPv4SessionInfo_swigregister(DHCPv4SessionInfo)

class DHCPv6SessionInfo(AbstractObject):
    r"""

    Class containing the info about the DHCPSession.

    This class represents the session info gathered from a DHCPv6Session. It will
    contain counters of the amount of DHCPMesseage transmitted and received.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxGet(self):
        r"""

        Returns the number of DHCPMessages transmitted.

        :return:  Number of DHCP messages transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcpSessionInfo.TxGet())


        """
        return _byteblower.DHCPv6SessionInfo_TxGet(self)

    def RxGet(self):
        r"""

        Returns the number of DHCPMessages recieved.

        :return:  Number of DHCP messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcpSessionInfo.RxGet())

        """
        return _byteblower.DHCPv6SessionInfo_RxGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the results are last retrieved from the server

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RefreshTimestampGet())

        """
        return _byteblower.DHCPv6SessionInfo_RefreshTimestampGet(self)

    def SolicitTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_SolicitTimestampLastGet(self)

    def AdvertiseTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_AdvertiseTimestampLastGet(self)

    def RequestTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_RequestTimestampLastGet(self)

    def ReplyTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_ReplyTimestampLastGet(self)

# Register DHCPv6SessionInfo in _byteblower:
_byteblower.DHCPv6SessionInfo_swigregister(DHCPv6SessionInfo)

class DHCPv4Protocol(AbstractObject):
    r"""

    The :class:`.DHCPv4Protocol` is the entry point to configure the DHCP client
    behavior of a ByteBlowerPort.

    A ByteBlowerPort can perform DHCP the get an IP address, gateway and netmask.
    Currently, no other options are supported but this will change in the future.

    Users can configure the timing parameters used in the different stages of the
    DHCP protocol:
    - Discover

      During the discover stage the ByteBlower port will broadcast discover
      messages.

    - Request

      Once one or more offers are received the ByteBlower port will broadcast its
      request message. If acknowledge the ByteBlower port will start using this
      address.

    - Renew

      When half of the lease time received in the acknowledge message of the
      request has passed, a ByteBlowerPort will sent a renew message to the server
      to extend its lease.

    Although DHCP allows clients to use unicast messages in the Request stage,
    ByteBlower currently only supports broadcast messages in this stage.

    A :class:`.DHCPv4Protocol` object also supports different retransmission
    strategies:

    Fixed
        This policy will use the same timeout value for each timeout.
    RFCSuggested
        This policy implements the policy described in :rfc:2131.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Perform(self):
        r"""

        Start DHCP and wait for the result.

        This method will force the DHCP client on the ByteBlower port to send a first
        DHCP discover message. It the client is already active, a new discover message
        will be sent. This is a synchronous call, so the full DHCPv6 solicit and
        request will be done once this call returns, or an error have occurred.

        :return: This method will return nothing, but will return after DHCP is
                 performed successfully. If DHCP fails, and exception is thrown.

        :raises: :exc:`.DHCPFailed` when no offer was received during the DHCP discover
                 stage or when no DHCPAck was received during DHCPRequest stage

        Example

        This example will perform DHCP on the specified ByteBlowerPort.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.Perform()

        """
        return _byteblower.DHCPv4Protocol_Perform(self)

    def PerformAsync(self):
        r"""

        Will start DHCP and return immediately.

        This method will force the DHCP client on the ByteBlower port to send a first
        DHCP discover message. If the client is already active, a new discover message
        will be sent. This is a asynchronous call, so it will return immediately. If
        you want to see if there an exception occurred during this async, call the
        :meth:`Perform` method.

        :return: This method will return nothing and return immediately

        .. versionadded:: 2.2

        Example

        This example will perform DHCP on the specified ByteBlowerPort.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.PerformAsync()


        """
        return _byteblower.DHCPv4Protocol_PerformAsync(self)

    def Release(self):
        r"""

        Release the DHCP lease.

        This method will release the address previously received using DHCP. After
        this, the address will not be used anymore by the ByteBlower port and the DHCP
        server can reuse the address for other DHCP clients. Of course, packets sent by
        the ByteBlower port as part of streams can still use the address.

        :return: This method will return nothing, but will return after DHCP Release is
                 performed

        Example

        This example will release the DHCP address.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.Release()

        """
        return _byteblower.DHCPv4Protocol_Release(self)

    def BroadcastFlagEnable(self, inValue):
        r"""

        Enables the DHCP broadcast flag

        .. versionadded:: 2.11.2

        When a ByteBlower port performs DHCP, the port will use the unicast DHCP method
        as described in the DHCP RFC.  Pre-2.11.2 ByteBlower servers used the legacy
        broadcast technique, which is sometimes detected by devices as a broadcast
        storm.

        :param enable: Whether or not to enable the Broadcast flag
        :type enable: bool

        Example

        This example will enable the Broadcast flag and thus the legacy behavour of the
        ByteBlower server

        .. code-block:: python
           :emphasize-lines: 2

        	dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
        	dhcp_protocol.BroadcastFlagEnable(True)
        	print(dhcp_protocol.BroadcastFlagIsEnabled())

        """
        return _byteblower.DHCPv4Protocol_BroadcastFlagEnable(self, inValue)

    def BroadcastFlagIsEnabled(self):
        r"""

        Returns whether or not the broadcast flag is enabled.

        .. versionadded:: 2.11.2

        When a ByteBlower port performs DHCP, the port will use the unicast DHCP method
        as described in the DHCP RFC.  Pre-2.11.2 ByteBlower servers used the legacy
        broadcast technique, which is sometimes detected by devices as a broadcast
        storm.

        :return: Whether or not the flag is enabled
        :rtype: bool

        Example

        This example will enable the Broadcast flag and thus the legacy behavour of the
        ByteBlower server

        .. code-block:: python
           :emphasize-lines: 2

        	dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
        	dhcp_protocol.BroadcastFlagEnable(True)
        	print(dhcp_protocol.BroadcastFlagIsEnabled())

        """
        return _byteblower.DHCPv4Protocol_BroadcastFlagIsEnabled(self)

    def ReleaseEnable(self, inValue):
        r"""

        Enable/disable sending DHCP release during destruction.

        When a ByteBlowerPort is destructed and this port has performed DHCP, such a
        port should release its address. If this behavior is prefered, then this should
        be done by using the Release.Enable method to indicate the ByteBlowerPort
        should release its address if possible. A ByteBlowerPort is able to release its
        address at destruction time if the destination mac address is in the
        ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be sent
        out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        :param enable: Boolean to enable or disable the release of the address at the
                       end of the test.
                       Default: **`True`**

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ReleaseEnable(False)

        """
        return _byteblower.DHCPv4Protocol_ReleaseEnable(self, inValue)

    def ReleaseIsEnabled(self):
        r"""

        Return whether sending DHCP release during destruction is enabled.

        When a ByteBlowerPort is destructed and this port has performed DHCP, it should
        release its address. If this behavior is prefered, then this should be done by
        using the :meth:`ReleaseEnable` method to inidicate the ByteBlowerPort should
        release its address if possible. A ByteBlowerPort is able to release its
        address at destruction time if the destination mac address is in the
        ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be sent
        out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        :return: If the port will release its IP at destruction

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 2

        	dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
        	print(dhcp_protocol.ReleaseIsEnabled())

        """
        return _byteblower.DHCPv4Protocol_ReleaseIsEnabled(self)

    def RetransmissionPolicyGet(self):
        r"""

        .. deprecated:: TODO
           This method has been renamed, use :meth:`RetransmissionPolicyStringGet`  now.

        """
        return _byteblower.DHCPv4Protocol_RetransmissionPolicyGet(self)

    def RetransmissionPolicySet(self, policy):
        r"""

        .. deprecated:: TODO
           This method has been renamed, use RetransmissionPolicy.Set.FromString now.

        """
        return _byteblower.DHCPv4Protocol_RetransmissionPolicySet(self, policy)

    def DiscoverInitialTimeoutGet(self):
        r"""

        Returns the current *<InitialTimeout>* for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The
        *<InitialTimeout>* is the timeout used to decide if the discover message must
        be retransmitted or not. The next timeout value will be calculated using the
        configured retransmission policy.

        :return:  Current '*<InitialTimeout>* value for the discover stage.
                  The unit is nanosecond (ns).

        Example

        This example will get the current *<InitialTimeout>* for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.DiscoverInitialTimeoutGet())

        """
        return _byteblower.DHCPv4Protocol_DiscoverInitialTimeoutGet(self)

    def DiscoverInitialTimeoutSet(self, inValue):
        r"""

        Sets the *<InitialTimeout>* for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The
        *<InitialTimeout>* is the timeout used to decide if the discover message must
        be retransmitted or not. The next timeout value will be calculated using the
        configured retransmission policy.

        :param InitialTimeout: New value for the initial timeout.
                               The unit is in nanosecond (ns), but the unit

        Example

        This example will set the *<InitialTimeout>* for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.DiscoverInitialTimeoutSet(2000000000)


        """
        return _byteblower.DHCPv4Protocol_DiscoverInitialTimeoutSet(self, inValue)

    def DiscoverMaxRetriesGet(self):
        r"""

        Returns the current maximum retries for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The maximum
        number of times the DHCP client will retransmit the discover message is
        returned by this method.

        :return: Current value for the number of retries in the discover stage.

        Example

        This example will get the current maximum number of retries for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.DiscoverMaxRetriesGet())

        """
        return _byteblower.DHCPv4Protocol_DiscoverMaxRetriesGet(self)

    def DiscoverMaxRetriesSet(self, inValue):
        r"""

        Sets the maximum retries for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The maximum
        number of times the DHCP client will retransmit the discover message is
        configured by this method.

        :param maxRetries: The new value for the maximum number of retransmission of
                           the discover message.

        Example

        This example will set the maximum number of retries for the discover stage to
        3 times.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.DiscoverMaxRetriesSet(3)

        """
        return _byteblower.DHCPv4Protocol_DiscoverMaxRetriesSet(self, inValue)

    def RequestInitialTimeoutGet(self):
        r"""

        Returns the current *<InitialTimeout>* for the DHCP request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The *<InitialTimeout>*
        is the timeout used to decide if the request message must be retransmitted or
        not. The next timeout value will be calculated using the configured retransmission
        policy.

        :return: Current *<InitialTimeout>* value for the request stage.
                 The unit is nanosecond (ns).

        Example

        This example will get the current *<InitialTimeout>* for the request stage.


        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestInitialTimeoutGet())

        """
        return _byteblower.DHCPv4Protocol_RequestInitialTimeoutGet(self)

    def RequestInitialTimeoutSet(self, inTime):
        r"""

        Sets the *<InitialTimeout>* for the DHCP request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The *<InitialTimeout>*
        is the timeout used to decide if the request message must be retransmitted or
        not. The next timeout value will be calculated using the configured
        retransmission policy.

        :param InitialTimeout: New value for the initial timeout.
                               The unit is in nanosecond (ns).

        Example

        This example will set the *<InitialTimeout>* for the request stage.

        .. code-block:: python
           :emphasize-lines: 1


        	dhcp_protocol.RequestInitialTimeoutSet(3000000000)

        """
        return _byteblower.DHCPv4Protocol_RequestInitialTimeoutSet(self, inTime)

    def RequestMaxRetriesGet(self):
        r"""

        Returns the current maximum retries for the DHCP Request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The maximum number of
        times the DHCP client will retransmit the request message is returned by this
        method.

        :return:  Current value for the number of retries in the request stage.

        Example

        This example will get the current maximum number of retries to 10 for the request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxRetriesSet(10)

        """
        return _byteblower.DHCPv4Protocol_RequestMaxRetriesGet(self)

    def RequestMaxRetriesSet(self, inValue):
        r"""

        Sets the maximum retries for the DHCP Request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The maximum number of
        times the DHCP client will retransmit the request message is configured by
        this method.

        :param maxRetries: The new value for the maximum number of retransmissions of
                           the request message.

        Default value is 5 times

        Example

        This example will set the current maximum number of retries to 10 for the request
        stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxRetriesSet(10)  

        """
        return _byteblower.DHCPv4Protocol_RequestMaxRetriesSet(self, inValue)

    def DHCPv4SessionInfoGet(self):
        r"""

        Returns the sessionInfo object for this DHCP Session.

        This object contains all the DHCP sessionInfo like Tx,Rx, current leaseTime,
        giaddr etc...

        :return: :class:`DHCPv4SessionInfo`

        Example

        This example will return the DHCPv4SessionInfo object for this DHCP session.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcpProtocol.DHCPv4SessionInfoGet().DescriptionGet())

        """
        return _byteblower.DHCPv4Protocol_DHCPv4SessionInfoGet(self)

# Register DHCPv4Protocol in _byteblower:
_byteblower.DHCPv4Protocol_swigregister(DHCPv4Protocol)

class DHCPv6Protocol(AbstractObject):
    r"""

    The :class:`.DHCPv6Protocol` is the entry point to configure the DHCPv6 client
     behavior of a ByteBlowerPort.

    A ByteBlowerPort can perform DHCPv6 for configuring IP addresses, IP prefixes
    and/or other parameters required to operate on an IPv6 network.

    A ByteBlowerPort can acquire and combine IP addresses using stateless address
    autoconfiguration, or by using DHCPv6 or static configuration. DHCP tends to be
    preferred at sites where central management of hosts is valued; stateless
    autoconfiguration does not require any sort of central management, and is
    therefore preferable in networks where no management is readily available,
    such as a typical home network.

    IPv6 hosts that use stateless autoconfiguration may require information other
    than an IP address. DHCPv6 can be used to acquire this information, even though
    it is not being used to configure IP addresses.

    DHCPv6 can also be used to deligate prefix information to e.g. home gateways.
    Such gateways require not only an IPv6 address for use in communicating with
    upstream routers, but also an IPv6 prefix for use in configuring devices on the
    downstream side of the router. DHCPv6 Prefix delegation provides a mechanism
    for configuring such routers. ByteBlower currently doesn't support prefix
    delegation yet, but can only be used as a host.

    ByteBlower allows full control of the timing parameters of the DHCPv6 client
    side. The retransmission policy used for DHCPv6 is the one suggested in the
    rfc:`3315`.

    Configurable timing parameters are:

    - Initial Timeout
    - Maximum Duration
    - Maximum Retries
    - Maximum Timeout

    These timing parameters can be applied to the following stages of DHCPv6:

    - Solicit
    - Request
    - Renew
    - Inform
    - Confirm

    For each state the parameters do the following:
        ByteBlower will send up to *<MaxRetries>* messages. The total duration of
        the the state may take up the *<MaxDuration>*. For the first attempt, a
        ByteBlowerPort will wait up to  *<InitialTimeout>* nanoseconds before
        retrying. Each attempt will wait for  maximum '*<MaxTimeout>* nanoseconds
        before concluding that the messages has timed out.




    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PerformAsync(self):
        r"""

        This method will bootstrap the DHCPv6 process.

        The client will start with sending DHCPv6 solicit messages. This is a
        asynchronous call, so it will return immediately. If you want to see if there
        an exception occured during this async, call the perform method.

        :return: This method will return nothing and return immediately

        .. versionadded:: 2.2

        Example

        This example will start the DHCPv6 process.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.PerformAsync()

        """
        return _byteblower.DHCPv6Protocol_PerformAsync(self)

    def Perform(self):
        r"""

        This method will bootstrap the DHCPv6 process.

        The client will start with sending DHCPv6 solicit messages. This is a
        synchronous call, so the full DHCPv6 solicit and request will be done once this
        call returns, or an error have occurred.

        :return: This method will return nothing, but will return after DHCP is
                 performed successfully. If DHCP fails, and exception is thrown.

        :raises: :exc:`.DHCPFailed` Thrown if no offer was received during the DHCP
                 solicit stage or no DHCPReply during DHCPRequest stage

        Example

        This example will start the DHCPv6 process.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.Perform()

        """
        return _byteblower.DHCPv6Protocol_Perform(self)

    def Release(self):
        r"""

        Release the address previously received using DHCPv6

        This method will release the address previously received using DHCP. After
        this, the address will not be used anymore by the ByteBlower port and the DHCP
        server can reuse the address for other DHCP clients. Offcourse, packets sent by
        the ByteBlower port as part of streams can still use the address.

        :return: This method will return nothing, but will return after DHCP Release is
                 performed

        Example

        This example will release the DHCP address.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.Release()


        """
        return _byteblower.DHCPv6Protocol_Release(self)

    def ReleaseEnable(self, inValue):
        r"""

        Enable automatical release when the ByteBlower port is destroyed

        When a ByteBlowerPort is destructed and this port has performed DHCP, such a
        port should release its address. If this behavior is prefered, then this
        should be done by using the :meth:`ReleaseEnable` method to inidicate the
        ByteBlowerPort should release its address if possible. A ByteBlowerPort is able
        to release its address at destruction time if the destination mac address is in
        the ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be
        sent out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        :param enable: bool True to enable the automatic release of the address
                       Default: **`true`**

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ReleaseEnable()

        """
        return _byteblower.DHCPv6Protocol_ReleaseEnable(self, inValue)

    def ReleaseIsEnabled(self):
        r"""

        Returns True when automatic release is enabled

        When a ByteBlowerPort is destructed and this port has performed DHCP, it should
        release its address. If this behavior is prefered, then this should be done by
        using the Release.Enable method to inidicate the ByteBlowerPort should release
        its address if possible. A ByteBlowerPort is able to release its address at
        destruction time if the destination mac address is in the ByteBlowerPort's
        ARP cache. If not, the DHCP release messages will not be sent out, because it
        could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`

        :return: If the port will release its IP at destruction

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ReleaseIsEnabled())

        """
        return _byteblower.DHCPv6Protocol_ReleaseIsEnabled(self)

    def SolicitInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Solicit state.

        :param value: New value for *<InitialTimeout>* for stage Solicit.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.SolicitInitialTimeoutSet(100000)

        """
        return _byteblower.DHCPv6Protocol_SolicitInitialTimeoutSet(self, arg2)

    def SolicitInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Solicit state.

        :return: Current value for *<InitialTimeout>* for stage Solicit.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitInitialTimeoutGet(self)

    def SolicitMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Solicit state.

        :param value: New value for *<MaxTimeout>* for stage Solicit.
                      This is a time value, in nanosecond units.

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Solicit stage.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.SolicitMaxTimeoutSet(10000)


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxTimeoutSet(self, arg2)

    def SolicitMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Solicit state.

        :return: Current value for *<MaxTimeout>* for stage Solicit.
                 This is a time value, in nanosecond units.

        Example
        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxTimeoutGet(self)

    def SolicitMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Solicit state.

        :param value: New value for *<MaxRetries>* for stage Solicit.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Solicit message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxRetriesSet(self, arg2)

    def SolicitMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Solicit state.

        :return: Current value for *<MaxRetries>* for stage Solicit.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Solicit message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxRetriesGet(self)

    def SolicitMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Solicit state.

        :param value: New value for *<MaxDuration>* for stage Solicit.
                      This is a time value, in nanosecond units.


        Example
        This example demonstrates how to set the value for *<MaxDuration>* to 1000000 in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.SolicitMaxDurationSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxDurationSet(self, arg2)

    def SolicitMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Solicit state.

        :return: Current value for *<MaxDuration>* for stage Solicit.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxDurationGet(self)

    def RequestInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Request state.

        :param value: New value for *<InitialTimeout>* for stage Request.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestInitialTimeoutSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_RequestInitialTimeoutSet(self, arg2)

    def RequestInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Request state.

        :return:  Current value for *<InitialTimeout>* for stage Request.
                  This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RequestInitialTimeoutGet(self)

    def RequestMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Request state.

        :param value: New value for *<MaxTimeout>* for stage Request.
                      This is a time value, in nanosecond units

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxTimeoutSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_RequestMaxTimeoutSet(self, arg2)

    def RequestMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Request state.

        :return: Current value for *<MaxTimeout>* for stage Request.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RequestMaxTimeoutGet(self)

    def RequestMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Request
        state.

        :param value: New value for *<MaxRetries>* for stage Request.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Request message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 10 in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxRetriesSet(10)


        """
        return _byteblower.DHCPv6Protocol_RequestMaxRetriesSet(self, arg2)

    def RequestMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Request state.

        :return: Current value for *<MaxRetries>* for stage Request.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Request message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_RequestMaxRetriesGet(self)

    def RequestMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Request state.

        :param value: New value for *<MaxDuration>* for stage Request.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* to 10 in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxDurationSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_RequestMaxDurationSet(self, arg2)

    def RequestMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Request state.

        :return: Current value for *<MaxDuration>* for stage Request.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_RequestMaxDurationGet(self)

    def ConfirmInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Confirm state.

        :param value: New value for *<InitialTimeout>* for stage Confirm.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmInitialTimeoutSet(100000)

        """
        return _byteblower.DHCPv6Protocol_ConfirmInitialTimeoutSet(self, arg2)

    def ConfirmInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Confirm state.

        :return: Current value for *<InitialTimeout>* for stage Confirm.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ConfirmInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmInitialTimeoutGet(self)

    def ConfirmMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Confirm state.

        :param value: New value for *<MaxTimeout>* for stage Confirm.
                      This is a time value, in nanosecond inits.

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmMaxTimeoutSet(5000000000)

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxTimeoutSet(self, arg2)

    def ConfirmMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Confirm state.

        :return: Current value for *<MaxTimeout>* for stage Confirm.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ConfirmMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxTimeoutGet(self)

    def ConfirmMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Confirm state.

        :param value: New value for *<MaxRetries>* for stage Confirm.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Confirmmessage.

        Example
        This example demonstrates how to set the value for *<MaxRetries>* to 12 in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmMaxRetriesSet(12)

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxRetriesSet(self, arg2)

    def ConfirmMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Confirm state.

        :return:  Current value for *<MaxRetries>* for stage Confirm.
                  This is a positive integer value, indicating the number of times the
                  ByteBlowerPort will resend its Confirm message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcpv6.ConfirmMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxRetriesGet(self)

    def ConfirmMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Confirm state.

        :param value:  New value for *<MaxDuration>* for stage Confirm.
                       This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmMaxDurationSet(100000)

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxDurationSet(self, arg2)

    def ConfirmMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Confirm state.

        :return: Current value for *<MaxDuration>* for stage Confirm.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ConfirmMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxDurationGet(self)

    def RenewInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Renew state.

        :param value: New value for *<InitialTimeout>* for stage Renew.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* to 10000 in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RenewInitialTimeoutSet(10000)


        """
        return _byteblower.DHCPv6Protocol_RenewInitialTimeoutSet(self, arg2)

    def RenewInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Renew state.

        :return: Current value for *<InitialTimeout>* for stage Renew.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RenewInitialTimeoutGet(self)

    def RenewMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Renew state.

        :param value: New value for *<MaxTimeout>* for stage Renew.
                     This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcpv6.RenewMaxTimeoutSet(5000)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxTimeoutSet(self, arg2)

    def RenewMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Renew state.

        :return:  Current value for *<MaxTimeout>* for stage Renew.
                  This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RenewMaxTimeoutGet(self)

    def RenewMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Renew state.

        :param value: New value for *<MaxRetries>* for stage Renew.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Renew message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 12in the Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RenewMaxRetriesSet(12)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxRetriesSet(self, arg2)

    def RenewMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Renew state.

        :return: Current value for *<MaxRetries>* for stage Renew.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Renew message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_RenewMaxRetriesGet(self)

    def RenewMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Renew state.

        :param value: New value for *<MaxDuration>* for stage Renew.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RenewMaxDurationSet(100000)

        """
        return _byteblower.DHCPv6Protocol_RenewMaxDurationSet(self, arg2)

    def RenewMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Renew state.

        :return: Current value for *<MaxDuration>* for stage Renew.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_RenewMaxDurationGet(self)

    def InformInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Inform state.

        :param value: New value for *<InitialTimeout>* for stage Inform.
                     This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformInitialTimeoutSet()

        """
        return _byteblower.DHCPv6Protocol_InformInitialTimeoutSet(self, arg2)

    def InformInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Inform state.

        :return: Current value for *<InitialTimeout>* for stage Inform.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_InformInitialTimeoutGet(self)

    def InformMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Inform state.

        :param value: New value for *<MaxTimeout>* for stage Inform.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformMaxTimeoutSet(100000)

        """
        return _byteblower.DHCPv6Protocol_InformMaxTimeoutSet(self, arg2)

    def InformMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Inform state.

        :return: Current value for *<MaxTimeout>* for stage Inform.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_InformMaxTimeoutGet(self)

    def InformMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Inform state.

        :param value: New value for *<MaxRetries>* for stage Inform.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Inform message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 5 in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformMaxRetriesSet(5)


        """
        return _byteblower.DHCPv6Protocol_InformMaxRetriesSet(self, arg2)

    def InformMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Inform state.

        :return: Current value for *<MaxRetries>* for stage Inform.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Inform message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_InformMaxRetriesGet(self)

    def InformMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Inform state.

        :param value: New value for *<MaxDuration>* for stage Inform.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* to 100000 in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformMaxDurationSet(100000)

        """
        return _byteblower.DHCPv6Protocol_InformMaxDurationSet(self, arg2)

    def InformMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Inform state.

        :return: Current value for *<MaxDuration>* for stage Inform.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_InformMaxDurationGet(self)

    def RetransmissionPolicyGet(self):
        return _byteblower.DHCPv6Protocol_RetransmissionPolicyGet(self)

    def RetransmissionPolicySet(self, policy):
        return _byteblower.DHCPv6Protocol_RetransmissionPolicySet(self, policy)

    def DHCPv6SessionInfoGet(self):
        r"""

        Returns the sessionInfo object for this DHCP Session.

        This object contains all the DHCP sessionInfo like Tx,Rx

        :return: The :class:`DHCPv6SessionInfo` object for this DHCP session

        Example

        This example will return the :class:`DHCPv6SessionInfo` object for this DHCP
        session.

        .. code-block:: python
           :emphasize-lines: 1


        	print(dhcp_protocol.DHCPv6SessionInfoGet().DescriptionGet())

        """
        return _byteblower.DHCPv6Protocol_DHCPv6SessionInfoGet(self)

# Register DHCPv6Protocol in _byteblower:
_byteblower.DHCPv6Protocol_swigregister(DHCPv6Protocol)

TCPConnectionState_CLOSED = _byteblower.TCPConnectionState_CLOSED
TCPConnectionState_LISTEN = _byteblower.TCPConnectionState_LISTEN
TCPConnectionState_SYN_RECEIVED = _byteblower.TCPConnectionState_SYN_RECEIVED
TCPConnectionState_SYN_SENT = _byteblower.TCPConnectionState_SYN_SENT
TCPConnectionState_ESTABLISHED = _byteblower.TCPConnectionState_ESTABLISHED
TCPConnectionState_FIN_WAIT_1 = _byteblower.TCPConnectionState_FIN_WAIT_1
TCPConnectionState_FIN_WAIT_2 = _byteblower.TCPConnectionState_FIN_WAIT_2
TCPConnectionState_CLOSING = _byteblower.TCPConnectionState_CLOSING
TCPConnectionState_CLOSE_WAIT = _byteblower.TCPConnectionState_CLOSE_WAIT
TCPConnectionState_LAST_ACK = _byteblower.TCPConnectionState_LAST_ACK
TCPConnectionState_TIME_WAIT = _byteblower.TCPConnectionState_TIME_WAIT

def ConvertTCPConnectionStateToString(inState):
    return _byteblower.ConvertTCPConnectionStateToString(inState)

def ParseTCPConnectionStateFromString(inState):
    return _byteblower.ParseTCPConnectionStateFromString(inState)
TCPCongestionAvoidanceAlgorithm__None = _byteblower.TCPCongestionAvoidanceAlgorithm__None
TCPCongestionAvoidanceAlgorithm_NewReno = _byteblower.TCPCongestionAvoidanceAlgorithm_NewReno
TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic
TCPCongestionAvoidanceAlgorithm_Sack = _byteblower.TCPCongestionAvoidanceAlgorithm_Sack
TCPCongestionAvoidanceAlgorithm_SackWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_SackWithCubic

def ConvertTCPCongestionAvoidanceAlgorithmToString(inTCAA):
    return _byteblower.ConvertTCPCongestionAvoidanceAlgorithmToString(inTCAA)

def ParseTCPCongestionAvoidanceAlgorithmFromString(inValue):
    return _byteblower.ParseTCPCongestionAvoidanceAlgorithmFromString(inValue)
HTTPRequestMethod_Undefined = _byteblower.HTTPRequestMethod_Undefined
HTTPRequestMethod_Options = _byteblower.HTTPRequestMethod_Options
HTTPRequestMethod_Get = _byteblower.HTTPRequestMethod_Get
HTTPRequestMethod_Head = _byteblower.HTTPRequestMethod_Head
HTTPRequestMethod_Post = _byteblower.HTTPRequestMethod_Post
HTTPRequestMethod_Put = _byteblower.HTTPRequestMethod_Put
HTTPRequestMethod_Delete = _byteblower.HTTPRequestMethod_Delete
HTTPRequestMethod_Trace = _byteblower.HTTPRequestMethod_Trace

def ConvertHTTPRequestMethodToString(inHTTPRequestMethod):
    return _byteblower.ConvertHTTPRequestMethodToString(inHTTPRequestMethod)

def ParseHTTPRequestMethodFromString(inHTTPRequestMethod):
    return _byteblower.ParseHTTPRequestMethodFromString(inHTTPRequestMethod)
HTTPRequestStatus_Configuration = _byteblower.HTTPRequestStatus_Configuration
HTTPRequestStatus_Scheduled = _byteblower.HTTPRequestStatus_Scheduled
HTTPRequestStatus_Connecting = _byteblower.HTTPRequestStatus_Connecting
HTTPRequestStatus_Running = _byteblower.HTTPRequestStatus_Running
HTTPRequestStatus_Finished = _byteblower.HTTPRequestStatus_Finished
HTTPRequestStatus_Stopped = _byteblower.HTTPRequestStatus_Stopped
HTTPRequestStatus_Error = _byteblower.HTTPRequestStatus_Error

def ConvertHTTPRequestStatusToString(inHTTPRequestStatus):
    return _byteblower.ConvertHTTPRequestStatusToString(inHTTPRequestStatus)

def ParseHTTPRequestStatusFromString(inStr):
    return _byteblower.ParseHTTPRequestStatusFromString(inStr)
HTTPMultiClientStatus_Configuration = _byteblower.HTTPMultiClientStatus_Configuration
HTTPMultiClientStatus_Scheduled = _byteblower.HTTPMultiClientStatus_Scheduled
HTTPMultiClientStatus_Running = _byteblower.HTTPMultiClientStatus_Running
HTTPMultiClientStatus_Finished = _byteblower.HTTPMultiClientStatus_Finished
HTTPMultiClientStatus_Stopped = _byteblower.HTTPMultiClientStatus_Stopped

def ConvertHTTPMultiClientStatusToString(inHTTPRequestStatus):
    return _byteblower.ConvertHTTPMultiClientStatusToString(inHTTPRequestStatus)
HTTPRequestType_Size = _byteblower.HTTPRequestType_Size
HTTPRequestType_Duration = _byteblower.HTTPRequestType_Duration

def ConvertHTTPRequestTypeToString(inHTTPRequestType):
    return _byteblower.ConvertHTTPRequestTypeToString(inHTTPRequestType)

def ParseHTTPRequestTypeFromString(s):
    return _byteblower.ParseHTTPRequestTypeFromString(s)
class CapturedFrame(AbstractObject):
    r"""

    A representation of a Captured Frame captured using a :class:`CaptureRawPacket`.

    Example

    .. code-block:: python

    	result = captureRaw.ResultGet()
        frame = result.FramesGetByIndex(0)
        print(frame.LengthGet())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, inAbstractObject, inTimestamp, bytes):
        _byteblower.CapturedFrame_swiginit(self, _byteblower.new_CapturedFrame(inAbstractObject, inTimestamp, bytes))

    def BufferGet(self):
        return _byteblower.CapturedFrame_BufferGet(self)

    def LengthGet(self):
        r"""

        Gets the packet length of this CapturedFrame. This is the length without CRC.

        :return: Lenght of the packet without CRC

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.LengthGet())

        """
        return _byteblower.CapturedFrame_LengthGet(self)

    def TimestampGet(self):
        r"""

        Gets timestamp [NS] of this CapturedFrame.

        :return: Timestamp in nanoseconds

        Example

        This example gets the timestamp of the captured frame

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.TimestampGet())

        """
        return _byteblower.CapturedFrame_TimestampGet(self)

    def BytesGet(self):
        r"""

        Gets the bytes in HEX format of this CapturedFrame.

        :return:  hex representation of the content of the captured frame

        Example

        This example gets the bytes in HEX

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.BytesGet())

        """
        return _byteblower.CapturedFrame_BytesGet(self)

# Register CapturedFrame in _byteblower:
_byteblower.CapturedFrame_swigregister(CapturedFrame)

class CapturedHTTPData(AbstractObject):
    r"""

    This class represents captured HTTP data.

    The HTTP data is a local snapshot of the HTTP data received in a HTTP session
    at the ByteBlower Server.

    HTTP data capture is currently supported on HTTP Client objects.
    .. code-block:: python
       :emphasize-lines: 2

    	captureData = httpClient.CaptureGet()
    	print(captureData.HttpSizeGet())



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def HttpSizeGet(self):
        r"""

        Returns the number of captured bytes of HTTP data.

        The value includes the size of both HTTP header and payload.

        .. note:: This only outputs the local cached HTTP data. The local cached
                  HTTP data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the ::Refresh method.

        :return: Size of captured HTTP data in Bytes.

        :raises: ByteBlower.Protocol.NotSupported - When the ByteBlower Server does
                 not support HTTP Client captures

        Example

        Suppose we sent a HTTP GET request for an index.html test page

        .. code-block:: python
           :emphasize-lines: 1

        	print(captureData.HttpSizeGet())


        """
        return _byteblower.CapturedHTTPData_HttpSizeGet(self)

    def HttpBytesGet(self):
        r"""

        Returns the captured HTTP data.

        The data includes both HTTP header and payload.

        .. note:: This only outputs the local cached HTTP data. The local cached
                  HTTP data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the :meth:`Refresh` method.

        :return: Captured HTTP data as string.

        :raises: ByteBlower.Protocol.NotSupported - When the ByteBlower Server does not
                 support HTTP Client captures

        Example

        Suppose we sent a HTTP GET request for an 'index.html' test page


        .. code-block:: python
        	:emphasize-lines: 1

        	print(captureData.HttpBytesGet())


        .. code-block:: http

            HTTP/1.1 200 OK
            Date: Wed, 12 Feb 2014 13:23:32 GMT
            Server: Apache/2.2.22 (Debian)
            Last-Modified: Thu, 10 Feb 2011 11:32:16 GMT
            ETag: "27c083-b1-49bebeefcb000"
            Accept-Ranges: bytes
            Content-Length: 177
            Vary: Accept-Encoding
            Content-Type: text/html
            X-Pad: avoid browser bug
            <html><body><h1>It works!</h1>
            <p>This is the default web page for this server.</p>
            <p>The web server software is running but no content has been added,
            yet.</p>
            </body></html>

        """
        return _byteblower.CapturedHTTPData_HttpBytesGet(self)

    def HttpBytesSave(self, inFileName):
        r"""

        Saves the captured HTTP data to file.

        .. note:: This only outputs the local cached HTTP data. The local cached HTTP
                  data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the :meth:`Refresh` method.

        :param fileName: Destination filename for the captured HTTP data.

        :raises: ByteBlower.Protocol.NotSupported - When the ByteBlower Server does not
                 support HTTP Client captures

        Example

        Stores all HTTP data captured to `c:.txt`

        .. code-block:: python
        	:emphasize-lines: 1

        	captureData.HttpBytesSave('httpResults.txt')


        """
        return _byteblower.CapturedHTTPData_HttpBytesSave(self, inFileName)

# Register CapturedHTTPData in _byteblower:
_byteblower.CapturedHTTPData_swigregister(CapturedHTTPData)

class CaptureRawPacket(Capture):
    r"""

    This class is used to capture the raw packet data that is received on the
    Physical interface that is associated with a ByteBlowerPort.

    With an :class:`.CaptureRawpacket` you can capture the data that is received by the
    ByteBlower Port and save this to a pcap file on your pc. You can also apply a
    filter (BPF-style) to only capture the packets of your interest.

    Example

    .. code-block:: python

    	captureRaw = bbPort2.RxCaptureBasicAdd()
        captureRaw.FilterSet('ip dst 1.1.1.2')
        captureRaw.Start()
    	#...
    	captureRaw.Stop()
    	result = captureRaw.ResultGet()
    	print(result.DescriptionGet())



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FilterSet(self, inFilter):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does not reset the counter values
                  which were triggered by a previous filter string.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

            captureRaw.FilterSet('ip dst 1.1.1.2')
        -

        """
        return _byteblower.CaptureRawPacket_FilterSet(self, inFilter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`.IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The BPF
        filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

            print(captureRaw.FilterGet())

        """
        return _byteblower.CaptureRawPacket_FilterGet(self)

    def FileNameRemoteGet(self):
        return _byteblower.CaptureRawPacket_FileNameRemoteGet(self)

    def Start(self):
        r"""

        Start capturing.

        .. note:: Calling Start while already running does not throw an exception.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            captureRaw.Start()

        """
        return _byteblower.CaptureRawPacket_Start(self)

    def Stop(self):
        r"""

        Stop capturing.

        .. note:: Calling Stop while not running does not throw an exception.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	captureRaw.Stop()


        """
        return _byteblower.CaptureRawPacket_Stop(self)

    def ResultGet(self):
        r"""

        Returns the capture result.

        :return: :class:`.CaptureResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result = captureRaw.ResultGet()


        """
        return _byteblower.CaptureRawPacket_ResultGet(self)

# Register CaptureRawPacket in _byteblower:
_byteblower.CaptureRawPacket_swigregister(CaptureRawPacket)

class CaptureResultSnapshot(AbstractRefreshableResult):
    r"""

    This class represents the result of a :class:`.CaptureRawpacket`.

    It contains the metrics and the frames that are captured.
    To get an update of the values use ::Refresh.

    Example

    .. code-block:: python

    	captureRaw = bbPort2.RxCaptureBasicAdd()
        captureRaw.FilterSet('ip dst 1.1.1.2')
        captureRaw.Start()
    	...
    	captureRaw.Stop()
        resultSnapshot = captureRaw.ResultGet()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clears the counters and deletes the captured packets from the capture.

        Example

        This example returns the captured frames

        .. code-block:: python
           :emphasize-lines: 1

            resultSnapshot.Clear()

        """
        return _byteblower.CaptureResultSnapshot_Clear(self)

    def PacketCountGet(self):
        r"""

        Returns the number of packets captured.

        :return:  The number of packets this capture captured

        Example

        This example returns the number of packets captured

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnapshot.PacketCountGet())

        """
        return _byteblower.CaptureResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Returns the number of bytes captured.

        :return: The number of bytes captured

        Example

        This example returns the number of bytes captured

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.ByteCountGet())

        """
        return _byteblower.CaptureResultSnapshot_ByteCountGet(self)

    def ErrorCountGet(self):
        r"""

        Returns Error count.

        :return: Returns the number of packets with incorrect CRC

        Example

        This example returns the number of corrupt frames

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.ErrorCountGet())

        """
        return _byteblower.CaptureResultSnapshot_ErrorCountGet(self)

    def CaptureDurationGet(self):
        r"""

        Returns the duration of the capture.

        :return:  The duration of the capture in nanoseconds

        Example

        This example returns the duration of the capture

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnapshot.CaptureDurationGet())

        """
        return _byteblower.CaptureResultSnapshot_CaptureDurationGet(self)

    def StateNameGet(self):
        r"""

        Returns the status of the current capture.

        :return:  Returns current state of this capture.

        Possible values are:
        - unknown
        - unavailable
        - inactive
        - active}

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.StateNameGet())

        """
        return _byteblower.CaptureResultSnapshot_StateNameGet(self)

    def FramesGet(self):
        r"""

        Returns a list of :class:`CapturedFrameList`.

        :return: :class:`CapturedFrameList`

        Example

        This example returns the captured frames

        .. code-block:: python
           :emphasize-lines: 1

        	framesResult = resultSnapshot.FramesGet()
            for frame in framesResult:
        		print(frame.DescriptionGet())

        """
        return _byteblower.CaptureResultSnapshot_FramesGet(self)

    def FramesGetByIndex(self, index):
        r"""

        Returns a Rx.Capture.Frame at the provided index.

        :return:  a :class:`CapturedFrame`

        Example

        This example returns the captured frame given by the index

        .. code-block:: python
           :emphasize-lines: 1

            frame = resultSnapshot.FramesGetByIndex(0)

        """
        return _byteblower.CaptureResultSnapshot_FramesGetByIndex(self, index)

    def PcapLastFileNameGet(self):
        r"""

        The fileName where the last pcap was saved to.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.PcapLastFileNameGet())
        	# prints: pcapResult.pcap

        """
        return _byteblower.CaptureResultSnapshot_PcapLastFileNameGet(self)

    def PcapSave(self, filename):
        r"""

        Stores the captured frames into a `pcap` file.

        The stored capture file can be opened by e.g. `wireshark`.

        :param fileName: - Destination filename for the capture file.

        :raises: <python_error> - No pcap support found: When the pcap library is not
                 installed on the ByteBlower client PC.

        :raises: ByteBlower.Rx.Capture.GetFailed - When no results are available or
                 when an exception occurred while obtaining the results.

        :raises: ByteBlower.Rx.Capture.GetFramesFailed - Invalid captured packet offset.

        Example

        Stores all packets captured by filter to `c:\pcap`

        .. code-block:: python
           :emphasize-lines: 1

        	resultSnapshot.PcapSave('resultPcap.pcap')



        """
        return _byteblower.CaptureResultSnapshot_PcapSave(self, filename)

    def PcapNanoSave(self, filename):
        r"""

        Stores the captured frames into a `pcap` file.

        The stored capture file can be opened by e.g. `wireshark`.

        :param: - Destination filename for the capture file.

        :raises: <python_error> - No pcap support found: When the pcap library is not
                 installed on the ByteBlower client PC.
        :raises: ByteBlower.Rx.Capture.GetFailed - When no results are available or
                 when an exception occurred while obtaining the results.
        :raises: ByteBlower.Rx.Capture.GetFramesFailed - Invalid captured packet offset.

        Example

        Stores all packets captured by filter to `c:\pcap` which is in PcapNano format

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           server.PortCreate('trunk-1-1')
           # TODO??

        """
        return _byteblower.CaptureResultSnapshot_PcapNanoSave(self, filename)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnapshot.RefreshTimestampGet())

        """
        return _byteblower.CaptureResultSnapshot_RefreshTimestampGet(self)

# Register CaptureResultSnapshot in _byteblower:
_byteblower.CaptureResultSnapshot_swigregister(CaptureResultSnapshot)

class TCPSessionInfo(AbstractObject):
    r"""

    Class containing info about the TCP session.
    Example

    .. code-block:: python

    	tcpSessionInfo = httpSessionInfo.TcpSessionInfoGet()
        # print an integer which indicates a certain State
        print(tcpSessionInfo.ConnectionStateGet())



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        r"""

        Returns the current TCP connection state.

        :return: :class:`TCPConnectionState`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ConnectionStateGet())


        """
        return _byteblower.TCPSessionInfo_ConnectionStateGet(self)

    def CongestionAvoidanceAlgorithmGet(self):
        r"""

        Returns the congestion avoidance algorithm used in this TCP session.

        :return: CongestionAvoidanceAlgorithm

        Possible values are:

        - Sack
        - None
        - NewReno
        - ServerDefault

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.CongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.TCPSessionInfo_CongestionAvoidanceAlgorithmGet(self)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the maximum segment size this TCP connection is allowed to use when
        transmitting data..

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.MaximumSegmentSizeGet())


        """
        return _byteblower.TCPSessionInfo_MaximumSegmentSizeGet(self)

    def ResultGet(self):
        r"""

        Returns the Layer4.Tcp.ResultSnapshot for this session containing the current
        result counters.

        The snapshot contains byte counters and time values.

        :return: :class:`.TCPResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ResultGet().DescriptionGet())


        """
        return _byteblower.TCPSessionInfo_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the Layer4.Tcp.ResultHistory for this session.

        :return: :class:`.TCPResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.TCPSessionInfo_ResultHistoryGet(self)

# Register TCPSessionInfo in _byteblower:
_byteblower.TCPSessionInfo_swigregister(TCPSessionInfo)

class TCPTunnel(AbstractObject):
    r"""

    Creates a TCP port forwarding configuration between a local host and a remote
    server.

    Traffic is forwarded between localhost and the remote endpoint.

    .. versionadded:: 2.7.0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.TCPTunnel_PortGet(self)

    def LocalPortSet(self, inLocalPort):
        r"""

        Configures the local port number of the port mapping configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpTunnel.LocalPortSet(12345)



        """
        return _byteblower.TCPTunnel_LocalPortSet(self, inLocalPort)

    def RemotePortSet(self, inLocalPort):
        r"""

        Configures the remote port to which data will be forwarded.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpTunnel.LocalPortSet(80)



        """
        return _byteblower.TCPTunnel_RemotePortSet(self, inLocalPort)

    def RemoteAddressSet(self, remote_address):
        r"""

        Configures the IP of the remote endpoint.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	tcpTunnel.RemoteAddressSet('192.168.1.10')



        """
        return _byteblower.TCPTunnel_RemoteAddressSet(self, remote_address)

    def Start(self):
        r"""

        Activates the port mapping configuration.

        Once the port mapping is activated it becomes possible to access the remote
        endpoint through external applications like curl, wget, ssh or the a web
        browser.

        For example:

            curl --insecure https://localhost:123435

            wget --no-check-certificate https://localhost:12345

        Of course, you can also use Tcl's networking packages like http.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpTunnel.Start()


        """
        return _byteblower.TCPTunnel_Start(self)

    def Stop(self):
        r"""

        Stops the port mapping configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	tcpTunnel.Stop()



        """
        return _byteblower.TCPTunnel_Stop(self)

# Register TCPTunnel in _byteblower:
_byteblower.TCPTunnel_swigregister(TCPTunnel)

class TCPResultData(AbstractObject):
    r"""

    Contains static TCP result counters.  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        return _byteblower.TCPResultData_ConnectionStateGet(self)

    def TxSegmentCountTotalGet(self):
        r"""

        Returns the total number of transmitted segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultData_TxSegmentCountTotalGet(self)

    def RxSegmentCountTotalGet(self):
        r"""

        Returns the total number of received segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultData.RxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultData_RxSegmentCountTotalGet(self)

    def RxSegmentCountOutOfOrderGet(self):
        r"""

        Returns the number of segments that were received out of order.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxSegmentCountOutOfOrderGet())



        """
        return _byteblower.TCPResultData_RxSegmentCountOutOfOrderGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        Returns the number of transmitted TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxByteCountHeaderGet())



        """
        return _byteblower.TCPResultData_TxByteCountHeaderGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        Returns the number of transmitted TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxByteCountPayloadGet())




        """
        return _byteblower.TCPResultData_TxByteCountPayloadGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes transmitted on the current TCP connection.  

        This is the sum of the tranmitted TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxByteCountTotalGet())



        """
        return _byteblower.TCPResultData_TxByteCountTotalGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        Returns the number of received TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxByteCountHeaderGet())



        """
        return _byteblower.TCPResultData_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        Returns the number of received TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxByteCountPayloadGet())



        """
        return _byteblower.TCPResultData_RxByteCountPayloadGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes received on the current TCP connection.  

        This is the sum of the received TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxByteCountTotalGet())



        """
        return _byteblower.TCPResultData_RxByteCountTotalGet(self)

    def ReceiverWindowCurrentGet(self):
        r"""

        Returns the current TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection 
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultData.ReceiverWindowCurrentGet())



        """
        return _byteblower.TCPResultData_ReceiverWindowCurrentGet(self)

    def ReceiverWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection 
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.ReceiverWindowMinimumGet())



        """
        return _byteblower.TCPResultData_ReceiverWindowMinimumGet(self)

    def ReceiverWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection 
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.ReceiverWindowMaximumGet())



        """
        return _byteblower.TCPResultData_ReceiverWindowMaximumGet(self)

    def CongestionWindowCurrentGet(self):
        r"""

        Returns the current TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.CongestionWindowCurrentGet())



        """
        return _byteblower.TCPResultData_CongestionWindowCurrentGet(self)

    def CongestionWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultData.CongestionWindowMinimumGet())



        """
        return _byteblower.TCPResultData_CongestionWindowMinimumGet(self)

    def CongestionWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.CongestionWindowMaximumGet())



        """
        return _byteblower.TCPResultData_CongestionWindowMaximumGet(self)

    def FlightSizeCurrentGet(self):
        r"""

        Returns the number of bytes that are currently in-flight.  

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.FlightSizeCurrentGet())O


        """
        return _byteblower.TCPResultData_FlightSizeCurrentGet(self)

    def FlightSizeMinimumGet(self):
        r"""

        Returns the smallest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not yet 
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.FlightSizeMinimumGet())



        """
        return _byteblower.TCPResultData_FlightSizeMinimumGet(self)

    def FlightSizeMaximumGet(self):
        r"""

        Returns the largest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.FlightSizeMaximumGet())



        """
        return _byteblower.TCPResultData_FlightSizeMaximumGet(self)

    def SlowStartThresholdCurrentGet(self):
        r"""

        Returns the current TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.SlowStartThresholdCurrentGet())



        """
        return _byteblower.TCPResultData_SlowStartThresholdCurrentGet(self)

    def SlowStartThresholdMinimumGet(self):
        r"""

        Returns the smallest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.SlowStartThresholdMinimumGet())



        """
        return _byteblower.TCPResultData_SlowStartThresholdMinimumGet(self)

    def SlowStartThresholdMaximumGet(self):
        r"""

        Returns the largest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.SlowStartThresholdMaximumGet())



        """
        return _byteblower.TCPResultData_SlowStartThresholdMaximumGet(self)

    def RoundTripTimeMinimumGet(self):
        r"""

        Returns the smallest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RoundTripTimeMinimumGet())



        """
        return _byteblower.TCPResultData_RoundTripTimeMinimumGet(self)

    def RoundTripTimeMaximumGet(self):
        r"""

        Returns the largest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RoundTripTimeMaximumGet())



        """
        return _byteblower.TCPResultData_RoundTripTimeMaximumGet(self)

    def RoundTripTimeCurrentGet(self):
        r"""

        Returns the current round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RoundTripTimeCurrentGet())



        """
        return _byteblower.TCPResultData_RoundTripTimeCurrentGet(self)

    def RetransmissionCountTotalGet(self):
        r"""

        Returns the total number of retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RetransmissionCountTotalGet())



        """
        return _byteblower.TCPResultData_RetransmissionCountTotalGet(self)

    def RetransmissionCountFastGet(self):
        r"""

        Returns the total number of fast retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RetransmissionCountFastGet())



        """
        return _byteblower.TCPResultData_RetransmissionCountFastGet(self)

    def RetransmissionCountSlowGet(self):
        r"""

        Returns the total number of timeout retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RetransmissionCountSlowGet())



        """
        return _byteblower.TCPResultData_RetransmissionCountSlowGet(self)

    def TimestampSynSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-SYN 
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampSynSentGet())



        """
        return _byteblower.TCPResultData_TimestampSynSentGet(self)

    def TimestampSynReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-SYN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampSynReceivedGet())



        """
        return _byteblower.TCPResultData_TimestampSynReceivedGet(self)

    def TimestampEstablishedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection entered the 
        established state.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampEstablishedGet())



        """
        return _byteblower.TCPResultData_TimestampEstablishedGet(self)

    def TimestampFinSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-FIN 
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampFinSentGet())



        """
        return _byteblower.TCPResultData_TimestampFinSentGet(self)

    def TimestampFinReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-FIN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampFinReceivedGet())


        """
        return _byteblower.TCPResultData_TimestampFinReceivedGet(self)

    def NumberOfSynSentGet(self):
        r"""

        Returns the number of TCP SYN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfSynSentGet())



        """
        return _byteblower.TCPResultData_NumberOfSynSentGet(self)

    def NumberOfSynReceivedGet(self):
        r"""

        Returns the number of TCP SYN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfSynReceivedGet())


        """
        return _byteblower.TCPResultData_NumberOfSynReceivedGet(self)

    def NumberOfFinSentGet(self):
        r"""

        Returns the number of TCP FIN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfFinSentGet())



        """
        return _byteblower.TCPResultData_NumberOfFinSentGet(self)

    def NumberOfFinReceivedGet(self):
        r"""

        Returns the number of TCP FIN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfFinReceivedGet())



        """
        return _byteblower.TCPResultData_NumberOfFinReceivedGet(self)

    def TxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent its last TCP 
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxTimestampLastGet())



        """
        return _byteblower.TCPResultData_TxTimestampLastGet(self)

    def RxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received its last
        TCP segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxTimestampLastGet())



        """
        return _byteblower.TCPResultData_RxTimestampLastGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns nanosecond duration between when result objects are created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.IntervalDurationGet())



        """
        return _byteblower.TCPResultData_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Returns the nanosecond timestamp for when this result object was created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampGet())



        """
        return _byteblower.TCPResultData_TimestampGet(self)

# Register TCPResultData in _byteblower:
_byteblower.TCPResultData_swigregister(TCPResultData)

class TCPResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.TCPResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TCPResultDataList_pop(self)

    def append(self, x):
        return _byteblower.TCPResultDataList_append(self, x)

    def empty(self):
        return _byteblower.TCPResultDataList_empty(self)

    def size(self):
        return _byteblower.TCPResultDataList_size(self)

    def swap(self, v):
        return _byteblower.TCPResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.TCPResultDataList_begin(self)

    def end(self):
        return _byteblower.TCPResultDataList_end(self)

    def rbegin(self):
        return _byteblower.TCPResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.TCPResultDataList_rend(self)

    def clear(self):
        return _byteblower.TCPResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.TCPResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TCPResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TCPResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TCPResultDataList_swiginit(self, _byteblower.new_TCPResultDataList(*args))

    def push_back(self, x):
        return _byteblower.TCPResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.TCPResultDataList_front(self)

    def back(self):
        return _byteblower.TCPResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.TCPResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TCPResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TCPResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TCPResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.TCPResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TCPResultDataList

# Register TCPResultDataList in _byteblower:
_byteblower.TCPResultDataList_swigregister(TCPResultDataList)

class TCPResultSnapshot(AbstractRefreshableResult):
    r"""

    Contains TCP result counters.  

    You can refresh the counters by calling the 
    :meth:`.TCPResultSnapshot.Refresh` method.  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        return _byteblower.TCPResultSnapshot_ConnectionStateGet(self)

    def TxSegmentCountTotalGet(self):
        r"""

        Returns the total number of transmitted segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_TxSegmentCountTotalGet(self)

    def RxSegmentCountTotalGet(self):
        r"""

        Returns the total number of received segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_RxSegmentCountTotalGet(self)

    def RxSegmentCountOutOfOrderGet(self):
        r"""

        Returns the number of segments that were received out of order.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxSegmentCountOutOfOrderGet())



        """
        return _byteblower.TCPResultSnapshot_RxSegmentCountOutOfOrderGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        Returns the number of transmitted TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxByteCountHeaderGet())



        """
        return _byteblower.TCPResultSnapshot_TxByteCountHeaderGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        Returns the number of transmitted TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxByteCountPayloadGet())



        """
        return _byteblower.TCPResultSnapshot_TxByteCountPayloadGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes transmitted on the current TCP connection.  

        This is the sum of the tranmitted TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxByteCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_TxByteCountTotalGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        Returns the number of received TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxByteCountHeaderGet())



        """
        return _byteblower.TCPResultSnapshot_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        Returns the number of received TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxByteCountPayloadGet())



        """
        return _byteblower.TCPResultSnapshot_RxByteCountPayloadGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes received on the current TCP connection.  

        This is the sum of the received TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxByteCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_RxByteCountTotalGet(self)

    def ReceiverWindowCurrentGet(self):
        r"""

        Returns the current TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.ReceiverWindowCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowCurrentGet(self)

    def ReceiverWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.ReceiverWindowMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowMinimumGet(self)

    def ReceiverWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.ReceiverWindowMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowMaximumGet(self)

    def CongestionWindowCurrentGet(self):
        r"""

        Returns the current TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to 
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.CongestionWindowCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_CongestionWindowCurrentGet(self)

    def CongestionWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.CongestionWindowMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_CongestionWindowMinimumGet(self)

    def CongestionWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to 
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.CongestionWindowMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_CongestionWindowMaximumGet(self)

    def FlightSizeCurrentGet(self):
        r"""

        Returns the number of bytes that are currently in-flight.  

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.FlightSizeCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_FlightSizeCurrentGet(self)

    def FlightSizeMinimumGet(self):
        r"""

        Returns the smallest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not 
        yet acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.FlightSizeMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_FlightSizeMinimumGet(self)

    def FlightSizeMaximumGet(self):
        r"""

        Returns the largest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not yet 
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.FlightSizeMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_FlightSizeMaximumGet(self)

    def SlowStartThresholdCurrentGet(self):
        r"""

        Returns the current TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to 
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.SlowStartThresholdCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdCurrentGet(self)

    def SlowStartThresholdMinimumGet(self):
        r"""

        Returns the smallest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to 
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.SlowStartThresholdMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdMinimumGet(self)

    def SlowStartThresholdMaximumGet(self):
        r"""

        Returns the largest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.SlowStartThresholdMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdMaximumGet(self)

    def RoundTripTimeMinimumGet(self):
        r"""

        Returns the smallest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RoundTripTimeMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeMinimumGet(self)

    def RoundTripTimeMaximumGet(self):
        r"""

        Returns the largest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RoundTripTimeMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeMaximumGet(self)

    def RoundTripTimeCurrentGet(self):
        r"""

        Returns the current round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RoundTripTimeCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeCurrentGet(self)

    def RetransmissionCountTotalGet(self):
        r"""

        Returns the total number of retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RetransmissionCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountTotalGet(self)

    def RetransmissionCountFastGet(self):
        r"""

        Returns the total number of fast retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RetransmissionCountFastGet())



        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountFastGet(self)

    def RetransmissionCountSlowGet(self):
        r"""

        Returns the total number of timeout retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RetransmissionCountSlowGet())



        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountSlowGet(self)

    def TimestampSynSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-SYN
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampSynSentGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampSynSentGet(self)

    def TimestampSynReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-SYN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampSynReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampSynReceivedGet(self)

    def TimestampEstablishedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection entered the 
        established state.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampEstablishedGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampEstablishedGet(self)

    def TimestampFinSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-FIN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampFinSentGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampFinSentGet(self)

    def TimestampFinReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-FIN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampFinReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampFinReceivedGet(self)

    def NumberOfSynSentGet(self):
        r"""

        Returns the number of TCP SYN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.NumberOfSynSentGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfSynSentGet(self)

    def NumberOfSynReceivedGet(self):
        r"""

        Returns the number of TCP SYN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultSnapshot.NumberOfSynReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfSynReceivedGet(self)

    def NumberOfFinSentGet(self):
        r"""

        Returns the number of TCP FIN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.NumberOfFinSentGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfFinSentGet(self)

    def NumberOfFinReceivedGet(self):
        r"""

        Returns the number of TCP FIN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.NumberOfFinReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfFinReceivedGet(self)

    def TxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent its last TCP 
        segment. 

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxTimestampLastGet())



        """
        return _byteblower.TCPResultSnapshot_TxTimestampLastGet(self)

    def RxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received its last 
        TCP segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxTimestampLastGet())



        """
        return _byteblower.TCPResultSnapshot_RxTimestampLastGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns nanosecond duration between when result objects are created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.IntervalDurationGet())



        """
        return _byteblower.TCPResultSnapshot_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Returns the nanosecond timestamp for when this result object was created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.  

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RefreshTimestampGet())



        """
        return _byteblower.TCPResultSnapshot_RefreshTimestampGet(self)

# Register TCPResultSnapshot in _byteblower:
_byteblower.TCPResultSnapshot_swigregister(TCPResultSnapshot)

class TCPResultSnapshotList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPResultSnapshotList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPResultSnapshotList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPResultSnapshotList___bool__(self)

    def __len__(self):
        return _byteblower.TCPResultSnapshotList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPResultSnapshotList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPResultSnapshotList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPResultSnapshotList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPResultSnapshotList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPResultSnapshotList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPResultSnapshotList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TCPResultSnapshotList_pop(self)

    def append(self, x):
        return _byteblower.TCPResultSnapshotList_append(self, x)

    def empty(self):
        return _byteblower.TCPResultSnapshotList_empty(self)

    def size(self):
        return _byteblower.TCPResultSnapshotList_size(self)

    def swap(self, v):
        return _byteblower.TCPResultSnapshotList_swap(self, v)

    def begin(self):
        return _byteblower.TCPResultSnapshotList_begin(self)

    def end(self):
        return _byteblower.TCPResultSnapshotList_end(self)

    def rbegin(self):
        return _byteblower.TCPResultSnapshotList_rbegin(self)

    def rend(self):
        return _byteblower.TCPResultSnapshotList_rend(self)

    def clear(self):
        return _byteblower.TCPResultSnapshotList_clear(self)

    def get_allocator(self):
        return _byteblower.TCPResultSnapshotList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TCPResultSnapshotList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TCPResultSnapshotList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TCPResultSnapshotList_swiginit(self, _byteblower.new_TCPResultSnapshotList(*args))

    def push_back(self, x):
        return _byteblower.TCPResultSnapshotList_push_back(self, x)

    def front(self):
        return _byteblower.TCPResultSnapshotList_front(self)

    def back(self):
        return _byteblower.TCPResultSnapshotList_back(self)

    def assign(self, n, x):
        return _byteblower.TCPResultSnapshotList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TCPResultSnapshotList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TCPResultSnapshotList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TCPResultSnapshotList_reserve(self, n)

    def capacity(self):
        return _byteblower.TCPResultSnapshotList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TCPResultSnapshotList

# Register TCPResultSnapshotList in _byteblower:
_byteblower.TCPResultSnapshotList_swigregister(TCPResultSnapshotList)

class TCPResultHistory(AbstractRefreshableResult):
    r"""

    Interface that allows you to obtain the cumulative and interval result data 
    objects regarding TCP stats.  

    At fixed time intervals, ByteBlower takes Interval and Cumulative stats of the
    TCP session. Only a fixed number of stats ( use :meth:`SamplingBufferLengthGet`
    to know how many ) are kept in memory at the ByteBlower server. Using the
    :meth:`Refresh` method those stats are transfered to the client pc where they
    are stored until you clear them ( :meth:`Clear` ).  

    The interval duration of such a historyObject can be obtained using 
    :meth:`SamplingIntervalDurationGet`  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        r"""

        Returns a list of recent TCP result objects containing cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be 
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.TCPResultDataList` containing the Cumulative counters  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultList = tcpResultHistory.CumulativeGet()



        """
        return _byteblower.TCPResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a list of recent TCP result objects containing cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :param index: index

        :return: :class:`.TCPResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeGetByIndex(0).DescriptionGet())



        """
        return _byteblower.TCPResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns a list of recent TCP result objects containing cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be 
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return:  The length of the cumulative list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeLengthGet())



        """
        return _byteblower.TCPResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of recent TCP result objects containing interval counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The duration of the interval can 
        be obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.TCPResultDataList` containing the Interval counters  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           intervalCounterList = tcpResultHistory.IntervalGetByTime(time).Intervalget()


        """
        return _byteblower.TCPResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a list of recent TCP result objects containing interval counters.  

        Each result object contains the counters only for a specific time interval. The
        duration of the interval can be obtained using 
        :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.TCPResultData`

        :param index: index

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultHistory.IntervalGetByIndex(0).DescriptionGet())



        """
        return _byteblower.TCPResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns a list of recent TCP result objects containing interval counters.  

        Each result object contains the counters only for a specific time interval. The
        duration of the interval can be obtained using 
        :meth:`SamplingIntervalDurationGet`.  

        :return: The length of the Interval list  

        Example 

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.IntervalLengthGet())



        """
        return _byteblower.TCPResultHistory_IntervalLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available cumulative counters  

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeGetByTime(timestamp).DescriptionGet())



        """
        return _byteblower.TCPResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.IntervalGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.TCPResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeLatestGet())



        """
        return _byteblower.TCPResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.IntervalLatestGet().DescriptionGet())



        """
        return _byteblower.TCPResultHistory_IntervalLatestGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds..  

        :return:  Duration in nanoseconds  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.SamplingIntervalDurationGet())



        """
        return _byteblower.TCPResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer at server-side.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.SamplingBufferLengthGet())



        """
        return _byteblower.TCPResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.  

        .. versionadded:: 2.3.0  

        .. warning: The previously collected history will be invalidated.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpResultHistory.SamplingIntervalDurationSet(1000000000)



        """
        return _byteblower.TCPResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.  

        .. versionadded:: 2.3.0  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpResultHistory.SamplingBufferLengthSet(6)



        """
        return _byteblower.TCPResultHistory_SamplingBufferLengthSet(self, inLength)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history is requested.  

        This is the timestamp on the server when the last :meth:`Refresh` was called.  

        :return: Timestamp in nanoseconds since epoch  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.RefreshTimestampGet())



        """
        return _byteblower.TCPResultHistory_RefreshTimestampGet(self)

    def Clear(self):
        r"""

        Clears the history.  

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can 
        execute this method. Both Interval and Cumulative counter lists will be cleared
        .

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	tcpResultHistory.Clear()



        """
        return _byteblower.TCPResultHistory_Clear(self)

# Register TCPResultHistory in _byteblower:
_byteblower.TCPResultHistory_swigregister(TCPResultHistory)

class HTTPResultData(AbstractObject):
    r"""

    Contains the HTTP result counters.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AverageDataSpeedGet(self):
        r"""

        Rate in bytes per seconds of the data transferred.

        This method determines the direction of the traffic based on the HTTP method
        and whether the parent is an HTTPServer or HTTPClient.

        - A "GET" request on an HTTPServer : TX traffic.
        - A "GET" request on an HTTPClient : RX traffic.
        - A "PUT" request on an HTTPServer : RX traffic.
        - A "PUT" request on an HTTPClient : TX traffic.

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.AverageDataSpeedGet().BitRateGet())



        """
        return _byteblower.HTTPResultData_AverageDataSpeedGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        The size of the received HTTPheader in bytes.

        HTTP header contains the HTTP header fields. These fields define the operating
        parameters of an HTTP transaction (e.g. :
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0
        )

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxByteCountHeaderGet())



        """
        return _byteblower.HTTPResultData_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        The size of the received HTTP Payload in bytes.

        The size of the actual content of the HTTP transaction

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxByteCountPayloadGet())



        """
        return _byteblower.HTTPResultData_RxByteCountPayloadGet(self)

    def RxByteCountRateGet(self):
        r"""

        Rate in bytes per seconds of the data received.

        :return:  Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxByteCountRateGet())



        """
        return _byteblower.HTTPResultData_RxByteCountRateGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Total of bytes received.

        The total is the sum of :meth:`RxByteCountHeaderGet` and
        :meth:`RxByteCountPayloadGet`

        :return: Total received bytes

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxByteCountTotalGet())


        """
        return _byteblower.HTTPResultData_RxByteCountTotalGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        The size of the transmitted HTTPHeader in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxByteCountHeaderGet())



        """
        return _byteblower.HTTPResultData_TxByteCountHeaderGet(self)

    def TxByteCountRateGet(self):
        r"""

        Rate in bytes per seconds of the data sent.

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 2

            print(resultData.TxByteCountRateGet().BitRateGet())



        """
        return _byteblower.HTTPResultData_TxByteCountRateGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        The size of the transmitted HTTPPayload in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.TxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultData_TxByteCountPayloadGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Total of transmitted bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.TxByteCountTotalGet())


        """
        return _byteblower.HTTPResultData_TxByteCountTotalGet(self)

    def TxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first transmitted packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxTimestampFirstGet())



        """
        return _byteblower.HTTPResultData_TxTimestampFirstGet(self)

    def TxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last transmitted packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxTimestampLastGet())



        """
        return _byteblower.HTTPResultData_TxTimestampLastGet(self)

    def RxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first received packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultData.RxTimestampFirstGet())


        """
        return _byteblower.HTTPResultData_RxTimestampFirstGet(self)

    def RxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last received packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxTimestampLastGet())



        """
        return _byteblower.HTTPResultData_RxTimestampLastGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the duration of this interval in nanoseconds.

        :return: intervalduration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.IntervalDurationGet())



        """
        return _byteblower.HTTPResultData_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example
        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TimestampGet())



        """
        return _byteblower.HTTPResultData_TimestampGet(self)

# Register HTTPResultData in _byteblower:
_byteblower.HTTPResultData_swigregister(HTTPResultData)

class HTTPResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPResultDataList_pop(self)

    def append(self, x):
        return _byteblower.HTTPResultDataList_append(self, x)

    def empty(self):
        return _byteblower.HTTPResultDataList_empty(self)

    def size(self):
        return _byteblower.HTTPResultDataList_size(self)

    def swap(self, v):
        return _byteblower.HTTPResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPResultDataList_begin(self)

    def end(self):
        return _byteblower.HTTPResultDataList_end(self)

    def rbegin(self):
        return _byteblower.HTTPResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPResultDataList_rend(self)

    def clear(self):
        return _byteblower.HTTPResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPResultDataList_swiginit(self, _byteblower.new_HTTPResultDataList(*args))

    def push_back(self, x):
        return _byteblower.HTTPResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPResultDataList_front(self)

    def back(self):
        return _byteblower.HTTPResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPResultDataList

# Register HTTPResultDataList in _byteblower:
_byteblower.HTTPResultDataList_swigregister(HTTPResultDataList)

class HTTPResultSnapshot(AbstractRefreshableResult):
    r"""

    Contains HTTP result counters.

    You can refresh the counters by calling the :meth:`Refresh` method.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AverageDataSpeedGet(self):
        r"""

        Rate in bytes per seconds of the data transferred.

        Depending on the HTTP method or if the parent of this object is an
        :class:`HTTPServer` or :class:`HTTPClient`, the rate of the traffic sent or
        received will be returned

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnaphot.AverageDataSpeedGet())


        """
        return _byteblower.HTTPResultSnapshot_AverageDataSpeedGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        The size of the received HTTPheader in bytes.

        HTTP header contains the HTTP header fields. These fields define the operating
        parameters of an HTTP transaction (e.g. : User-Agent: Mozilla/5.0 (X11;
        Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 )

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	result = httP
            print(resultSnapshot.RxByteCountHeaderGet())



        """
        return _byteblower.HTTPResultSnapshot_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        The size of the received HTTP Payload in bytes.

        The size of the actual content of the HTTP transaction

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.RxByteCountPayloadGet())



        """
        return _byteblower.HTTPResultSnapshot_RxByteCountPayloadGet(self)

    def RxByteCountRateGet(self):
        r"""

        Rate in bytes per seconds of the data received.

        :return:  Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnaphot.RxByteCountRateGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountRateGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Total number of bytes received.

        The total is the sum of :meth:`RxByteCountHeaderGet` and
        :meth:`RxByteCountPayloadGet`

        :return: Total received bytes

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.RxByteCountTotalGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountTotalGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        The size of the transmitted HTTPHeader in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.TxByteCountHeaderGet())


        """
        return _byteblower.HTTPResultSnapshot_TxByteCountHeaderGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        The size of the transmitted HTTPPayload in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnaphot.TxByteCountPayloadGet())

        """
        return _byteblower.HTTPResultSnapshot_TxByteCountPayloadGet(self)

    def TxByteCountRateGet(self):
        r"""

        Rate in bytes per seconds of the data sent.

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnaphot.TxByteCountPayloadGet())



        """
        return _byteblower.HTTPResultSnapshot_TxByteCountRateGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Total of transmitted bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.TxByteCountTotalGet())



        """
        return _byteblower.HTTPResultSnapshot_TxByteCountTotalGet(self)

    def TxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first transmitted packet.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.TxTimestampFirstGet())



        """
        return _byteblower.HTTPResultSnapshot_TxTimestampFirstGet(self)

    def TxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last transmitted packet.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnapshot.TxTimestampLastGet())



        """
        return _byteblower.HTTPResultSnapshot_TxTimestampLastGet(self)

    def RxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first received packet.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.RxTimestampFirstGet())



        """
        return _byteblower.HTTPResultSnapshot_RxTimestampFirstGet(self)

    def RxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last received packet.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnapshot.RxTimestampLastGet())



        """
        return _byteblower.HTTPResultSnapshot_RxTimestampLastGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the duration (in nanoseconds) between snapshot objects.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.IntervalDurationGet())

        """
        return _byteblower.HTTPResultSnapshot_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnaphot.TimestampGet())



        """
        return _byteblower.HTTPResultSnapshot_TimestampGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.RefreshTimestampGet())



        """
        return _byteblower.HTTPResultSnapshot_RefreshTimestampGet(self)

# Register HTTPResultSnapshot in _byteblower:
_byteblower.HTTPResultSnapshot_swigregister(HTTPResultSnapshot)

class HTTPResultSnapshotList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPResultSnapshotList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPResultSnapshotList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPResultSnapshotList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPResultSnapshotList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPResultSnapshotList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPResultSnapshotList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPResultSnapshotList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPResultSnapshotList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPResultSnapshotList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPResultSnapshotList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPResultSnapshotList_pop(self)

    def append(self, x):
        return _byteblower.HTTPResultSnapshotList_append(self, x)

    def empty(self):
        return _byteblower.HTTPResultSnapshotList_empty(self)

    def size(self):
        return _byteblower.HTTPResultSnapshotList_size(self)

    def swap(self, v):
        return _byteblower.HTTPResultSnapshotList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPResultSnapshotList_begin(self)

    def end(self):
        return _byteblower.HTTPResultSnapshotList_end(self)

    def rbegin(self):
        return _byteblower.HTTPResultSnapshotList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPResultSnapshotList_rend(self)

    def clear(self):
        return _byteblower.HTTPResultSnapshotList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPResultSnapshotList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPResultSnapshotList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPResultSnapshotList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPResultSnapshotList_swiginit(self, _byteblower.new_HTTPResultSnapshotList(*args))

    def push_back(self, x):
        return _byteblower.HTTPResultSnapshotList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPResultSnapshotList_front(self)

    def back(self):
        return _byteblower.HTTPResultSnapshotList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPResultSnapshotList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPResultSnapshotList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPResultSnapshotList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPResultSnapshotList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPResultSnapshotList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPResultSnapshotList

# Register HTTPResultSnapshotList in _byteblower:
_byteblower.HTTPResultSnapshotList_swigregister(HTTPResultSnapshotList)

class HTTPResultHistory(AbstractRefreshableResult):
    r"""

    General interface for getting cumulative or interval results.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative results.

        :return: :class:`HTTPResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultHistory.CumulativeGet()[0].DescriptionGet())



        """
        return _byteblower.HTTPResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index

        :return: :class:`.HTTPResultData` cumulative counter object at the specified
                 index

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.CumulativeGetByIndex(0)


        """
        return _byteblower.HTTPResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultHistory.CumulativeLengthGet())


        """
        return _byteblower.HTTPResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: :class:`HTTPResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

        	httpResultData = resultHistory.IntervalGet()[0]

        """
        return _byteblower.HTTPResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index

        :return: :class:`.HTTPResultData` interval counter object at the specified
                 index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 3

           httpResultData = resultHistory.IntervalGetByIndex(0)


        """
        return _byteblower.HTTPResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.IntervalLengthGet())


        """
        return _byteblower.HTTPResultHistory_IntervalLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	httpResultData = resultHistory.CumulativeGetByTime(timestamp)



        """
        return _byteblower.HTTPResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :return: :class:`HTTPResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           interval = resultHistory.IntervalGetByTime(timestamp)


        """
        return _byteblower.HTTPResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :return: :class:`HTTPResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.CumulativeLatestGet())



        """
        return _byteblower.HTTPResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :return: :class:`.HTTPResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.IntervalLatestGet(0)



        """
        return _byteblower.HTTPResultHistory_IntervalLatestGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.SamplingIntervalDurationGet())



        """
        return _byteblower.HTTPResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. warning:: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            resultHistory.SamplingIntervalDurationSet(1000000000)


        """
        return _byteblower.HTTPResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        """
        return _byteblower.HTTPResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.SamplingBufferLengthSet(6))



        """
        return _byteblower.HTTPResultHistory_SamplingBufferLengthSet(self, inLength)

    def RefreshTimestampGet(self):
        r"""

        RefreshTimestampGet.

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultHistory.RefreshTimestampGet())



        """
        return _byteblower.HTTPResultHistory_RefreshTimestampGet(self)

    def Clear(self):
        r"""

        Clears the history.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory.Clear()



        """
        return _byteblower.HTTPResultHistory_Clear(self)

# Register HTTPResultHistory in _byteblower:
_byteblower.HTTPResultHistory_swigregister(HTTPResultHistory)

class HTTPSessionInfo(AbstractObject):
    r"""

    Class containing the info about the HTTPSession.

    This class represents the session info gather from a HTTP session. It will
    contain states of the TCP session, Timestamp of received requests average
    throughputs etc..

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Role_Client = _byteblower.HTTPSessionInfo_Role_Client
    Role_Server = _byteblower.HTTPSessionInfo_Role_Server

    @staticmethod
    def ConvertRoleToString(inRole):
        return _byteblower.HTTPSessionInfo_ConvertRoleToString(inRole)

    def RoleGet(self):
        r"""

        Returns the role of the session.

        Possible values are:

        - Client
        - Server}

        :return: The role the session was/is playing

        Example

        retrieve the httpsession info from the httpClient

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO???


        """
        return _byteblower.HTTPSessionInfo_RoleGet(self)

    def TcpSessionInfoGet(self):
        r"""

        Returns the TCPSessionInfo from this session.

        The :class:`.TCPSessionInfo` contains information about the TCP underlying
        session.

        :return: :class:`.TCPSessionInfo`

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.TcpSessionInfoGet().DescriptionGet())



        """
        return _byteblower.HTTPSessionInfo_TcpSessionInfoGet(self)

    def RequestMethodGet(self):
        r"""

        Returns the http request method of the session.

        Possible values are:

        - GET
        - PUT

        :return: The request method used in this session

        Example

        retrieve the httpsession info from the httpClient

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.RequestMethodGet() == HTTPRequestMethod.Get)



        """
        return _byteblower.HTTPSessionInfo_RequestMethodGet(self)

    def RequestTypeGet(self):
        r"""

        Returns the request type ( Duration or Size )

        Possible values are:

        - Duration
        - Size

        :return: request Type

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.RequestTypeGet() == HTTPRequestType.Duration)



        """
        return _byteblower.HTTPSessionInfo_RequestTypeGet(self)

    def RequestStatusGet(self):
        r"""

        Returns the status of the HTTP request.

        :return: :class:`.HTTPRequestStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1


        	print(httpSessionInfo.RequestStatusGet() == HTTPRequestStatus.Running)



        """
        return _byteblower.HTTPSessionInfo_RequestStatusGet(self)

    def ErrorMessageGet(self):
        r"""

        Returns the error message.

        When the request status is "Error" then extra information can be obtained
        with this method.

        :return: The error message string

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.ErrorMessageGet())



        """
        return _byteblower.HTTPSessionInfo_ErrorMessageGet(self)

    def RequestValueGet(self):
        r"""

        Returns the request value.

        In case of duration based session it returns the duration that was requested by
        the httpClient. For Size it returns the requested payload size

        :return: Request Value

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.RequestValueGet())



        """
        return _byteblower.HTTPSessionInfo_RequestValueGet(self)

    def RequestDurationGet(self):
        return _byteblower.HTTPSessionInfo_RequestDurationGet(self)

    def RequestSizeGet(self):
        return _byteblower.HTTPSessionInfo_RequestSizeGet(self)

    def ServerClientIdGet(self):
        return _byteblower.HTTPSessionInfo_ServerClientIdGet(self)

    def ResultGet(self):
        r"""

        Returns the HTTPResultSnapshot for this session.

        The snapshot contains byte counters and time values.

        :return: :class:`.HTTPResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.ResultGet().DescriptionGet())



        """
        return _byteblower.HTTPSessionInfo_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the HTTPResultHistory for this session.

        The history contains a list of snapshots taken at one second intervals.
        To update the history use the :meth:`Refresh` function.

        :return: :class:`.HTTPResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.HTTPSessionInfo_ResultHistoryGet(self)

    def Destroy(self):
        return _byteblower.HTTPSessionInfo_Destroy(self)

# Register HTTPSessionInfo in _byteblower:
_byteblower.HTTPSessionInfo_swigregister(HTTPSessionInfo)

def HTTPSessionInfo_ConvertRoleToString(inRole):
    return _byteblower.HTTPSessionInfo_ConvertRoleToString(inRole)

class HTTPMultiResultData(AbstractObject):
    r"""

    Contains the result counters for :class:`HTTPMultiClient` or
    :class:`HTTPMultiServer`.

    .. code-block:: python
       :emphasize-lines: 2

    	http_multi_data = http_client.ResultHistoryGet().CumulativeGetByIndex(0)
    	print(http_multi_data.TxTimestampLastGet(10000000000))


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FinishedGet(self):
        r"""

        Indicates whether the flow has finished.

        :return: bool: indicates if the flow has finished.

        For the :class:`HTTPMultiClient` this means that client state is Finished or
        Stopped. For the :class:`HTTPMultiServer` this means the server state is
        Stopped.

        """
        return _byteblower.HTTPMultiResultData_FinishedGet(self)

    def RxByteCountGet(self):
        r"""

        Returns number of received bytes.

        """
        return _byteblower.HTTPMultiResultData_RxByteCountGet(self)

    def TxByteCountGet(self):
        r"""

        Returns number of sent bytes.

        """
        return _byteblower.HTTPMultiResultData_TxByteCountGet(self)

    def RxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_RxSpeedGet(self)

    def TxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_TxSpeedGet(self)

    def TxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted packet or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TxTimestampFirstGet(self, default_value)

    def TxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted packet or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 2

        	print(http_multi_data.TxTimestampLastGet(10000000000))


        """
        return _byteblower.HTTPMultiResultData_TxTimestampLastGet(self, default_value)

    def RxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved packet or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RxTimestampFirstGet(self, default_value)

    def RxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last receieved packet or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RxTimestampLastGet(self, default_value)

    def TcpRxByteCountGet(self):
        r"""

        Returns number of bytes received by the TCP protocol. This includes the TCP
        header.

        """
        return _byteblower.HTTPMultiResultData_TcpRxByteCountGet(self)

    def TcpTxByteCountGet(self):
        r"""

        Returns number of bytes sent by the TCP protocol. This includes the TCP header
        and TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultData_TcpTxByteCountGet(self)

    def TcpRxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_TcpRxSpeedGet(self)

    def TcpTxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_TcpTxSpeedGet(self)

    def TcpRxSegmentCountGet(self):
        r"""

        Returns number of packets received by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultData_TcpRxSegmentCountGet(self)

    def TcpTxSegmentCountGet(self):
        r"""

        Returns number of packets sent by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultData_TcpTxSegmentCountGet(self)

    def TcpTxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted TCP segment or
        a default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpTxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpTxTimestampFirstGet(self, default_value)

    def TcpTxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted TCP segment or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available.

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpTxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpTxTimestampLastGet(self, default_value)

    def TcpRxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpRxTimestampFirstGet(100000))

        """
        return _byteblower.HTTPMultiResultData_TcpRxTimestampFirstGet(self, default_value)

    def TcpRxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpRxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpRxTimestampLastGet(self, default_value)

    def RoundTripTimeAverageGet(self, default_value):
        r"""

        Returns average TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RoundTripTimeAverageGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeAverageGet(self, default_value)

    def RoundTripTimeMinimumGet(self, default_value):
        r"""

        Returns minimum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RoundTripTimeMinimumGet(10000))



        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeMinimumGet(self, default_value)

    def RoundTripTimeMaximumGet(self, default_value):
        r"""

        Returns maximum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RoundTripTimeMaximumGet)

        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeMaximumGet(self, default_value)

    def RetransmissionsGet(self):
        r"""

        Returns number of TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultData_RetransmissionsGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the snapshot duration interval in nanoseconds.

        :return: intervalduration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

           	print(http_multi_data.IntervalDurationGet())


        """
        return _byteblower.HTTPMultiResultData_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TimestampGet())


        """
        return _byteblower.HTTPMultiResultData_TimestampGet(self)

    def ConnectionsAttemptedGet(self):
        r"""

        Returns the number of TCP connection attempts that were initiated.

        For the :class:`HTTPMultiClient` this means the number of active TCP connection
        attempts initiated. For the :class:`HTTPMultiServer` this means the number of
        passive TCP connection requests received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(http_multi_data.ConnectionsAttemptedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsAttemptedGet(self)

    def ConnectionsEstablishedGet(self):
        r"""

        Returns the number of succesful TCP connection attempts that reached ESTABLISHED state.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.ConnectionsEstablishedGet())

        """
        return _byteblower.HTTPMultiResultData_ConnectionsEstablishedGet(self)

    def ConnectionsAbortedGet(self):
        r"""

        Returns the number of aborted TCP connection attempts.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.ConnectionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsAbortedGet(self)

    def ConnectionsRefusedGet(self):
        r"""

        Returns the number of TCP connection attempts that were refused by the other side.

        For the :class:`HTTPMultiServer` this value is always zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.ConnectionsRefusedGet())

        """
        return _byteblower.HTTPMultiResultData_ConnectionsRefusedGet(self)

    def SessionsFinishedGet(self):
        r"""

        Returns the number HTTP requests that finished succesfully.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.SessionsFinishedGet())

        """
        return _byteblower.HTTPMultiResultData_SessionsFinishedGet(self)

    def SessionsAbortedGet(self):
        r"""

        Returns the number HTTP requests that failed because they were aborted locally.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.SessionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsAbortedGet(self)

    def SessionsResetByPeerGet(self):
        r"""

        Returns the number HTTP requests that failed because a TCP RESET message was
        received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.SessionsResetByPeerGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsResetByPeerGet(self)

    def DebugCountersNamesGet(self):
        r"""

        Returns a list of debug counter names.

        .. note:: The list of names is not backwards compatible.

        """
        return _byteblower.HTTPMultiResultData_DebugCountersNamesGet(self)

    def DebugCountersGetByName(self, name):
        r"""

        Returns a list of debug counter values.

        :param name: The name of the debug counter (obtained from
                     :meth:`DebugCountersNamesGet`).

        .. note:: The list of debug values is not backwards compatible.

        Example
        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.DebugCountersGetByName('State_Closing'))


        """
        return _byteblower.HTTPMultiResultData_DebugCountersGetByName(self, name)

# Register HTTPMultiResultData in _byteblower:
_byteblower.HTTPMultiResultData_swigregister(HTTPMultiResultData)

class HTTPMultiResultSnapshot(AbstractRefreshableResult):
    r"""

    Refreshable snapshot that contains the result counters for HTTPMultiClient or
    HTTPMultiServer.

    You can refresh the counters by calling the
    :meth:`HTTPMultiResultSnapshot.Refresh` method.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FinishedGet(self):
        r"""

        Indicates whether the flow has finished.

        :return:  bool indiciating if the flow has finished.

        For the :class:`HTTPMultiClient` this means that client state is Finished or
        Stopped. For the :class:`HTTPMultiServer` this means the server state is
        Stopped.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.FinishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_FinishedGet(self)

    def RxByteCountGet(self):
        r"""

        Returns number of received bytes.

        """
        return _byteblower.HTTPMultiResultSnapshot_RxByteCountGet(self)

    def TxByteCountGet(self):
        r"""

        Returns number of sent bytes.

        """
        return _byteblower.HTTPMultiResultSnapshot_TxByteCountGet(self)

    def RxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_RxSpeedGet(self)

    def TxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_TxSpeedGet(self)

    def TxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted packet or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TxTimestampFirstGet(self, default_value)

    def TxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted packet or a
        default value in case no packets were transmitted.

        :return:

        Timestamp in nanoseconds

        Example
        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TxTimestampLastGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TxTimestampLastGet(self, default_value)

    def RxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved packet or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RxTimestampFirstGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RxTimestampFirstGet(self, default_value)

    def RxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last receieved packet or a
        default value in case no packets were received.

        :return:

        Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RxTimestampLastGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RxTimestampLastGet(self, default_value)

    def TcpRxByteCountGet(self):
        r"""

        Returns number of bytes received by the TCP protocol. This includes the TCP
        header.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxByteCountGet(self)

    def TcpTxByteCountGet(self):
        r"""

        Returns number of bytes sent by the TCP protocol. This includes the TCP header
        and TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxByteCountGet(self)

    def TcpRxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_TcpRxSpeedGet(self)

    def TcpTxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_TcpTxSpeedGet(self)

    def TcpRxSegmentCountGet(self):
        r"""

        Returns number of packets received by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxSegmentCountGet(self)

    def TcpTxSegmentCountGet(self):
        r"""

        Returns number of packets sent by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxSegmentCountGet(self)

    def TcpTxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted TCP segment or
        a default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpTxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxTimestampFirstGet(self, default_value)

    def TcpTxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted TCP segment or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpTxTimestampLastGet(10000))

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxTimestampLastGet(self, default_value)

    def TcpRxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpRxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxTimestampFirstGet(self, default_value)

    def TcpRxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpRxTimestampLastGet(10000))

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxTimestampLastGet(self, default_value)

    def RoundTripTimeAverageGet(self, default_value):
        r"""

        Returns average TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RoundTripTimeAverageGet(10000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeAverageGet(self, default_value)

    def RoundTripTimeMinimumGet(self, default_value):
        r"""

        Returns minimum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RoundTripTimeMinimumGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeMinimumGet(self, default_value)

    def RoundTripTimeMaximumGet(self, default_value):
        r"""

        Returns maximum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RoundTripTimeMaximumGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeMaximumGet(self, default_value)

    def RetransmissionsGet(self):
        r"""

        Returns number of TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultSnapshot_RetransmissionsGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the duration (in nanoseconds) between snapshot objects.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.IntervalDurationGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TimestampGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_TimestampGet(self)

    def ConnectionsAttemptedGet(self):
        r"""

        Returns the number of TCP connection attempts that were initiated.

        For the :class:`HTTPMultiClient` this means the number of active TCP connection
        attempts initiated. For the :class:`HTTPMultiServer` this means the number of
        passive TCP connection requests received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.ConnectionsAttemptedGet())

        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsAttemptedGet(self)

    def ConnectionsEstablishedGet(self):
        r"""

        Returns the number of succesful TCP connection attempts that reached ESTABLISHED state.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.ConnectionsEstablishedGet())



        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsEstablishedGet(self)

    def ConnectionsAbortedGet(self):
        r"""

        Returns the number of aborted TCP connection attempts.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RetransmissionsGet())



        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsAbortedGet(self)

    def ConnectionsRefusedGet(self):
        r"""

        Returns the number of TCP connection attempts that were refused by the other side
        .

        For the :class:`HTTPMultiServer` this value is always zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(multiSnapshot.ConnectionsRefusedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsRefusedGet(self)

    def SessionsFinishedGet(self):
        r"""

        Returns the number HTTP requests that finished succesfully.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.SessionsFinishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsFinishedGet(self)

    def SessionsAbortedGet(self):
        r"""

        Returns the number HTTP requests that failed because they were aborted locally.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.SessionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsAbortedGet(self)

    def SessionsResetByPeerGet(self):
        r"""

        Returns the number HTTP requests that failed because a TCP RESET message was
        received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.SessionsResetByPeerGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsResetByPeerGet(self)

    def DebugCountersNamesGet(self):
        r"""

        Returns a list of debug counter names.

        .. note:: The list of names is not backwards compatible.

        """
        return _byteblower.HTTPMultiResultSnapshot_DebugCountersNamesGet(self)

    def DebugCountersGetByName(self, name):
        r"""

        Returns a list of debug counter values.

        .. note: : The list of debug values is not backwards compatible.

        :param name: The name of the debug counter (obtained from
                     :meth:`DebugCountersNamesGet`).

        """
        return _byteblower.HTTPMultiResultSnapshot_DebugCountersGetByName(self, name)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RefreshTimestampGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RefreshTimestampGet(self)

# Register HTTPMultiResultSnapshot in _byteblower:
_byteblower.HTTPMultiResultSnapshot_swigregister(HTTPMultiResultSnapshot)

class HTTPMultiResultHistory(AbstractRefreshableResult):
    r"""

    General interface for getting cumulative or interval results.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative results.

        :return: :class:`HTTPMultiResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeGet())

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: number of the snapshot to get

        :return: :class:`HTTPMultiResultData` cumulative counter object at the
                 specified index

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeGetByIndex(0))

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return: The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeLengthGet())

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: :class:`.HTTPMultiResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: The interval counter to fetch

        :return: :class:`HTTPMultiResultData` interval counter object at the specified
                 index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalGetByIndex(0).DescriptionGet())

        """
        return _byteblower.HTTPMultiResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalLengthGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeGetByTime(timestamp))


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalGetByTime(timestamp).DescriptionGet())

        """
        return _byteblower.HTTPMultiResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeLatestGet())

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalLatestGet().DescriptionGet())

        """
        return _byteblower.HTTPMultiResultHistory_IntervalLatestGet(self)

    def RefreshTimestampGet(self):
        r"""

        RefreshTimestampGet.

        :return: Timestamp in nanoseconds since epoch

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.RefreshTimestampGet())

        """
        return _byteblower.HTTPMultiResultHistory_RefreshTimestampGet(self)

    def Clear(self):
        r"""

        Clears the history.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_result_history.Clear()



        """
        return _byteblower.HTTPMultiResultHistory_Clear(self)

# Register HTTPMultiResultHistory in _byteblower:
_byteblower.HTTPMultiResultHistory_swigregister(HTTPMultiResultHistory)

class HTTPMultiClient(AbstractObject):
    r"""

    HTTPMultiClient can be used in combination with MultiServer to start multiple
    concurrent HTTP requests.

    When starting the flow, the configured number of HTTP requests will be started.
    Each time a request is finished (succesfully or unsuccesfully) it will be
    replaced by a new request. This is repeated until one of the configured stop
    conditions is reached. Possible stop conditions are: total duration, total size
    or number of connections created. If no stop conditions are configured then the
    flow continues indefinitely.

    Main parameters:

    MaximumConcurrentRequests
        Number of HTTP requests to run concurrently

    Duration
        Total duration of the flow

    Size
        Total number of bytes that may transmitted

    SessionDuration
        Duration of individual requests

    SessionSize
        Number of bytes transmitted by individual requests

    CumulativeConnectionLimit
        Maximum number of connections that may be created during the whole flow

    .. versionadded:: 2.10.0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StatusGet(self):
        r"""

        Returns the status of the flow.

        :return: :class:`.HTTPMultiClientStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.StatusGet()

        """
        return _byteblower.HTTPMultiClient_StatusGet(self)

    def FinishedGet(self):
        r"""

        Returns true if the flow has finished or was stopped explicitly.

        Example

        Check if the multi-session is finished

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.FinishedGet())


        """
        return _byteblower.HTTPMultiClient_FinishedGet(self)

    def DurationSet(self, value):
        r"""

        Sets the maximum total duration of the flow.

        A value of zero indicates unlimited duration.

        Default value: 0

        :param requestDuration: The total duration of the flow.

        Example

        Configure the flow to run for 15 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.DurationSet(15*60*1000000000)

        """
        return _byteblower.HTTPMultiClient_DurationSet(self, value)

    def DurationGet(self):
        r"""

        Returns the flow duration.

        A value of zero indicates unlimited duration.

        :return:  The configured request duration in nanoseconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.DurationGet())

        """
        return _byteblower.HTTPMultiClient_DurationGet(self)

    def SizeSet(self, value):
        r"""

        Puts a size limit on the total number of bytes that can be sent.

        A value of zero indicates unlimited size.

        Default value: 0

        :param requestsize: The maximum cumulative payload size of all flows.

        Example

        Allow a global payload of 1 GB

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SizeSet(1000000000)

        """
        return _byteblower.HTTPMultiClient_SizeSet(self, value)

    def SizeGet(self):
        r"""

        Returns the size limit.

        A value of zero indicates unlimited size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SizeGet())


        """
        return _byteblower.HTTPMultiClient_SizeGet(self)

    def SessionDurationSet(self, value):
        r"""

        Sets the duration for the individual HTTP requests.

        Each request will run for the configured duration. This duration will
        automatically be reduced near the end of the flow so that the global time limit
        (see :meth:`DurationSet`) is not exceeded.

        A value of zero indicates unlimited duration.

        Default value: 0

        :param requestDuration: The duration of each HTTP request.

        Example

        Configure each request to run for 10 seconds

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SessionDurationSet(10000000000))


        """
        return _byteblower.HTTPMultiClient_SessionDurationSet(self, value)

    def SessionDurationGet(self):
        r"""

        Returns the session duration expressed in nanoseconds.

        A value of zero indicates unlimited duration.

        Example

        .. code-block:: python
           :emphasize-lines: 1


           print(httpMultiClient.SessionDurationGet())

        """
        return _byteblower.HTTPMultiClient_SessionDurationGet(self)

    def SessionSizeSet(self, value):
        r"""

        Sets the size for the individual HTTP requests.

        Each new started request will send or receive the configured size in bytes.

        A value of zero indicates unlimited size.

        Default value: 0

        :param requestSize: The payload size in bytes of each HTTP request.

        Example

        Configure each request to send 15000 bytes:

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SessionSizeSet(1500)


        """
        return _byteblower.HTTPMultiClient_SessionSizeSet(self, value)

    def SessionSizeGet(self):
        r"""

        Returns the session size.

        A value of zero indicates unlimited size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SessionSizeGet())

        """
        return _byteblower.HTTPMultiClient_SessionSizeGet(self)

    def SessionRateLimitSet(self, bytes_per_second):
        r"""

        Sets a rate limit for the individual HTTP requests.

        A value of zero indicates no rate limit.

        Default value: 0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SessionRateLimitSet(1500)

        """
        return _byteblower.HTTPMultiClient_SessionRateLimitSet(self, bytes_per_second)

    def SessionRateLimitGet(self):
        r"""

        Returns the rate limit for the individual HTTP requests.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SessionRateLimitGet())

        """
        return _byteblower.HTTPMultiClient_SessionRateLimitGet(self)

    def MaximumConcurrentRequestsGet(self):
        r"""

        Returns the maximum number of concurrent requests.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.MaximumConcurrentRequestsGet())


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentRequestsGet(self)

    def MaximumConcurrentRequestsSet(self, value):
        r"""

        Sets the maximum number of concurrent requests.

        The flow will start the requested number of HTTP requests and then maintain
        this number by starting a new request every time a request has finished or
        failed.

        Default value: 1

        :param numberOfRequests: Maximum number of concurrent requests.

        Example

        Allow 100 concurrent HTTP requests:

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.MaximumConcurrentRequestsSet(100)

        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentRequestsSet(self, value)

    def CumulativeConnectionLimitGet(self):
        r"""

        Returns the limit on the total number of connections that may be created.

        A value of zero indicates no limit (infinite number of connections may be
        created).

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.CumulativeConnectionLimitGet())

        """
        return _byteblower.HTTPMultiClient_CumulativeConnectionLimitGet(self)

    def CumulativeConnectionLimitSet(self, value):
        r"""

        Sets a limit on the total number of connections that may be created.

        Once the total number of connection attempts has reached the configured limit
        no new connections will be created. If there are no active connections at that
        time then flow immediately enters Finished state. Otherwise the flow remains in
        Running state until all remaining requests have finished.

        A value of zero indicates no limit (infinite number of connections may be
        created).

        Default value: 0

        Example

        Allow 100 connection attempts in total

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.CumulativeConnectionLimitSet(100)

        """
        return _byteblower.HTTPMultiClient_CumulativeConnectionLimitSet(self, value)

    def MaximumConcurrentConnectionAttemptsGet(self):
        r"""

        Returns the maximum number of concurrent connection attempts.

        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentConnectionAttemptsGet(self)

    def MaximumConcurrentConnectionAttemptsSet(self, value):
        r"""

        Sets the maximum number of concurrent connection attempts.

        This method limits maximum number of requests that can be in the TCP SYN-SENT
        state.

        Default value: 1

        Example

        Allow 100 concurrent connection attempts:

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.MaximumConcurrentConnectionAttemptsSet(100)


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentConnectionAttemptsSet(self, value)

    def RemoteAddressSet(self, value):
        r"""

        Sets the remote address for the HTTP requests.

        :param address: The destination address for the HTTP requests.

        This should be the address of the :class:`HTTPMultiServer`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.RemoteAddressSet('1.1.1.1')

        """
        return _byteblower.HTTPMultiClient_RemoteAddressSet(self, value)

    def RemoteAddressGet(self):
        r"""

        Returns the remote address.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.RemoteAddressGet())


        """
        return _byteblower.HTTPMultiClient_RemoteAddressGet(self)

    def RemotePortSet(self, value):
        r"""

        Sets the remote port for the HTTP requests.

        :param portNumber: The destination port for the HTTP requests.

        This should be the port that the :class:`HTTPMultiServer` is listening to.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.RemotePortSet(80)


        """
        return _byteblower.HTTPMultiClient_RemotePortSet(self, value)

    def RemotePortGet(self):
        r"""

        Returns the remote port.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.RemotePortGet())

        """
        return _byteblower.HTTPMultiClient_RemotePortGet(self)

    def LocalPortRangeSet(self, _from, to):
        r"""

        Sets the local port range for the TCP connections.

        :param min: The minimum value of the port range.

        :param max: The maximum value of the port range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.LocalPortRangeSet(20000,30000)


        """
        return _byteblower.HTTPMultiClient_LocalPortRangeSet(self, _from, to)

    def LocalPortRangeGet(self):
        r"""

        Returns the port range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.LocalPortRangeGet())


        """
        return _byteblower.HTTPMultiClient_LocalPortRangeGet(self)

    def MaximumSegmentSizeSet(self, value):
        r"""

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.MaximumSegmentSizeSet(65535)

        """
        return _byteblower.HTTPMultiClient_MaximumSegmentSizeSet(self, value)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the TCP maximum segment size.

        Default value: 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.MaximumSegmentSizeGet())

        """
        return _byteblower.HTTPMultiClient_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, value):
        r"""

        Sets the TCP receive window.

        :param windowsize: New value of the TCP receive window. Must be between 1 and
                           65535 bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.ReceiveWindowInitialSizeSet(65535)

        """
        return _byteblower.HTTPMultiClient_ReceiveWindowInitialSizeSet(self, value)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Returns the TCP receive window.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.MaximumConcurrentConnectionAttemptsGet())

        """
        return _byteblower.HTTPMultiClient_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if TCP window scaling is enabled or not.

        Window scaling enables window sizes that are larger than 65535 bytes.

        :return: True: window scale enabled , False: window scale disabled

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ReceiveWindowScalingIsEnabled())

        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, inEnable):
        r"""

        Enables of disables the TCP window scale option.

        Window scaling window sizes that are larger than 65535 bytes.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Example

        To enable window scaling

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.ReceiveWindowScalingEnable(True)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingEnable(self, inEnable)

    def ReceiveWindowScalingValueSet(self, value):
        r"""

        Sets the TCP window scale value.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        rfc:`1323`.

        :param scale: Integer (0-8), which is used for bitwise shifting.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.ReceiveWindowScalingValueSet(3)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingValueSet(self, value)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the TCP window scale value.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        :return: current receive window scale

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingValueGet(self)

    def SlowStartThresholdSet(self, value):
        r"""

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :param ssthresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive
                 integer

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPMultiClient_SlowStartThresholdSet(self, value)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :return: Slow-start threshold

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SlowStartThresholdGet())


        """
        return _byteblower.HTTPMultiClient_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, value):
        r"""

        Configure the preferred TCP Congestion Avoidance Algorithm.

        :param congestionAvoidanceAlgorithm: Congestion Avoidance Algorithm to configure.

                                             - none
                                             - sack
                                             - newreno
                                             - sack-with-cubic
                                             - newreno-with-cubic

        :raises: python_error - Failed to parse enumerator: When the value could not be
                 interpreted as a valid TCAA

        Example

        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)

        """
        return _byteblower.HTTPMultiClient_TcpCongestionAvoidanceAlgorithmSet(self, value)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Returns the preferred TCP Congestion Avoidance Algorithm.

        :return: current Congestion Avoidance Algorithm.

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.TcpCongestionAvoidanceAlgorithmGet()==TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.HTTPMultiClient_TcpCongestionAvoidanceAlgorithmGet(self)

    def TypeOfServiceSet(self, value):
        r"""

        Sets the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        Both IP headers reserve space to specify the expected quality of service(QOS).
        IPv4 calls this field the 'Type Of Service'. In IPv6 one uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the method is generic, it is used for both IPv4 and IPv6 layers. The
        implementation will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase,thus before the
        parent ByteBlower port is started. Invoking the method at other moments will
        result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.TypeOfServiceSet(16)

        """
        return _byteblower.HTTPMultiClient_TypeOfServiceSet(self, value)

    def TypeOfServiceGet(self):
        r"""

        Returns the 'Type Of Service' or 'Traffic Class' value.

        """
        return _byteblower.HTTPMultiClient_TypeOfServiceGet(self)

    def FlowLabelSet(self, value):
        r"""

        Sets the flow label for IPv6 flows.

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.FlowLabelSet(1234)

        """
        return _byteblower.HTTPMultiClient_FlowLabelSet(self, value)

    def FlowLabelGet(self):
        r"""

        Returns the "Flow Label" for IPv6 flows.

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient = port.RemotePortGet()
           print(httpMultiClient.FlowLabelGet())

        """
        return _byteblower.HTTPMultiClient_FlowLabelGet(self)

    def HttpMethodSet(self, *args):
        r"""

        Sets the HTTP request method.

        There are 2 possible values:

        GET
            For HTTP GET requests (data will be downloaded from the HTTP server).

        PUT
            For HTTP PUT requests (data will be uploaded to the HTTP server).

        Default value: GET

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.HttpMethodSet(HTTPRequestMethod.Get))


        Sets the HTTP request method.

        There are 2 possible values:

        GET
            For HTTP GET requests (data will be downloaded from the HTTP server).

        PUT
            For HTTP PUT requests (data will be uploaded to the HTTP server).

        Default value: GET

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.HttpMethodSet(HTTPRequestMethod.Get))


        """
        return _byteblower.HTTPMultiClient_HttpMethodSet(self, *args)

    def HttpMethodGet(self):
        r"""

        Returns the HTTP request method.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.HttpMethodGet() == HTTPRequestMethod.Get)

        """
        return _byteblower.HTTPMultiClient_HttpMethodGet(self)

    def InitialTimeToWaitSet(self, ns):
        r"""

        Sets the initial time to wait before really starting the flow.

        This can be used if you want to different flows to start at different times.

        Default value: 0

        :param timetowait: Time to wait before the flow will start.

        Example

        Initial Time to wait of 60 seconds

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.InitialTimeToWaitSet(60000000000)


        """
        return _byteblower.HTTPMultiClient_InitialTimeToWaitSet(self, ns)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the initial time to wait value.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.InitialTimeToWaitGet())


        """
        return _byteblower.HTTPMultiClient_InitialTimeToWaitGet(self)

    def Start(self):
        r"""

        Starts the flow.

        :raises: :exc:`.ConfigError` This exception is thrown in case of an incomplete
                 configuration. For example if the remote IP or remote port is not set.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.Start()

        """
        return _byteblower.HTTPMultiClient_Start(self)

    def Stop(self):
        r"""

        Stops the flow.

        Explicitly stops a flow. Normally the flow finishes automatically when the
        configured duration or size has been reached. This method stops the flow
        immediately.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.Stop()

        """
        return _byteblower.HTTPMultiClient_Stop(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Returns the duration for the result snapshots.

        :param intervalDuraton: expressed as nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SamplingIntervalDurationGet())

        """
        return _byteblower.HTTPMultiClient_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, value):
        r"""

        Sets the duration of the result snapshots.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SamplingIntervalDurationSet(1500000)


        """
        return _byteblower.HTTPMultiClient_SamplingIntervalDurationSet(self, value)

    def SamplingBufferLengthGet(self):
        r"""

        Returns the snapshot buffer length.

        :return:  The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SamplingBufferLengthGet())

        """
        return _byteblower.HTTPMultiClient_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, value):
        r"""

        Configure the snapshot buffer size.

        ByteBlower server stores the snapshots in a circular buffer before they are
        transferred to the client. If the buffer overflows then the oldest snapshot is
        overwritten. This method configures the maximum size of the buffer.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SamplingBufferLengthSet(6)

        """
        return _byteblower.HTTPMultiClient_SamplingBufferLengthSet(self, value)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: :class:`HTTPMultiResultSnapshot` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ResultGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiClient_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the result history.

        This method returns a :class:`HTTPMultiResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time.

        :return: :class:`HTTPMultiResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiClient_ResultHistoryGet(self)

# Register HTTPMultiClient in _byteblower:
_byteblower.HTTPMultiClient_swigregister(HTTPMultiClient)

HTTPMultiServerStatus_Stopped = _byteblower.HTTPMultiServerStatus_Stopped
HTTPMultiServerStatus_Started = _byteblower.HTTPMultiServerStatus_Started
class HTTPMultiServer(AbstractObject):
    r"""

    HTTPMultiServer provides the server-side for HTTPMultiClient.

    See :class:`HTTPMultiClient` for more information.

    .. versionadded:: 2.10.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ByteBlowerServerGet(self):
        return _byteblower.HTTPMultiServer_ByteBlowerServerGet(self)

    def ByteBlowerPortGet(self):
        return _byteblower.HTTPMultiServer_ByteBlowerPortGet(self)

    def StatusGet(self):
        r"""

        Returns the HTTP server status.

        :return: :class:`.HTTPMultiServerStatus`

        Example

        Before starting the HTTP server:  `HTTPMultiServerStatus.Stopped`
        After starting the HTTP server:  `HTTPMultiServerStatus.Started`

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.StatusGet() == HTTPMultiServerStatus_Started)



        """
        return _byteblower.HTTPMultiServer_StatusGet(self)

    def PortSet(self, inPort):
        r"""

        Sets the TCP port on which the HTTP server will listen.

        :param port: The TCP port on which the HTTP server will listen for incoming
                     requests.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer
        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.PortSet(80)



        """
        return _byteblower.HTTPMultiServer_PortSet(self, inPort)

    def PortGet(self):
        r"""

        Returns the TCP port for the HTTP server.

        :return:  The configured TCP Port

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.PortGet())



        """
        return _byteblower.HTTPMultiServer_PortGet(self)

    def MaximumSegmentSizeSet(self, value):
        r"""

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result_history = http_server.MaximumSegmentSizeSet(65535)



        """
        return _byteblower.HTTPMultiServer_MaximumSegmentSizeSet(self, value)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the TCP maximum segment size.

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.MaximumSegmentSizeGet())



        """
        return _byteblower.HTTPMultiServer_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, value):
        r"""

        Sets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use
        good size for your configuration and network setup.

        :param windowsize: New value of the initial receive window.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.SlowStartThresholdSet(65535)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowInitialSizeSet(self, value)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Gets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.ReceiveWindowInitialSizeGet())



        """
        return _byteblower.HTTPMultiServer_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if window scaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True when scaling is enabled, false when scaling is disabled

        Example

        When enabled:

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, value):
        r"""

        Enables of disables windowscaling.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :param scaling: bool which will enable (True) or disable (False) windowscaling.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Example

        To enable window scaling  or  To disable window scaling  or

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.ReceiveWindowScalingEnable(True)

        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingEnable(self, value)

    def ReceiveWindowScalingValueSet(self, value):
        r"""

        Sets the window scale which will be used for new clients.

        This must be done before requesting a page from a client, because this option
        is negotiated at the beginning of the TCP session.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        :param scale: Integer (0-8), which is used for bitwise shifting.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.ReceiveWindowScalingValueSet(6)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingValueSet(self, value)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the current receive window scale.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        :return: current receive window scale

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.ReceiveWindowScalingValueGet())



        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingValueGet(self)

    def SlowStartThresholdSet(self, value):
        r"""

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :param ssthresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive
                 integer

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPMultiServer_SlowStartThresholdSet(self, value)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :return: Slow-start threshold

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.SlowStartThresholdGet())



        """
        return _byteblower.HTTPMultiServer_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, value):
        r"""

        Selects the TCP Congestion Avoidance Algorithm.

        Selects the TCP Congestion Avoidance Algorithm which will be used for new
        clients. This must be selected before requesting a page from a client,
        because for some algorithms, the congestion avoidance support is negotiated a
        the beginning of the TCP session.

        :parameter algorithm: Congestion Avoidance Algorithm to configure.

        Possible algorithms are:

        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        :raises: python_error: Failed to parse enumerator: When the value could not be
                 interpreted as a valid TCAA

        Example

        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)



        """
        return _byteblower.HTTPMultiServer_TcpCongestionAvoidanceAlgorithmSet(self, value)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Gets the current TCP Congestion Avoidance Algorithm for new clients.

        :return: current Congestion Avoidance Algorithm.

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.HTTPMultiServer_TcpCongestionAvoidanceAlgorithmGet(self)

    def Start(self):
        r"""

        Starts the HTTP server on the configured port with the configured
        configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.Start()


        """
        return _byteblower.HTTPMultiServer_Start(self)

    def Stop(self):
        r"""

        Stops the HTTP server.

        Running sessions will be aborted and incoming connection requests will be
        refused.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	http_server.Stop()



        """
        return _byteblower.HTTPMultiServer_Stop(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.SamplingIntervalDurationGet())



        """
        return _byteblower.HTTPMultiServer_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, value):
        r"""

        Sets the duration of one sampling interval.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.SamplingIntervalDurationGet())



        """
        return _byteblower.HTTPMultiServer_SamplingIntervalDurationSet(self, value)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold.

        :return: The length of the server sample buffer

        """
        return _byteblower.HTTPMultiServer_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, value):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.SamplingBufferLengthSet(6)



        """
        return _byteblower.HTTPMultiServer_SamplingBufferLengthSet(self, value)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return:  :class:`HTTPMultiResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server_result = http_server.ResultGet().DescriptionGet())



        """
        return _byteblower.HTTPMultiServer_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the result history.

        This method returns a :class:`HTTPMultiResultHistory` object. This will contain
        the Cumulative and the Interval counters over time.

        :return: :class:`HTTPMultiResultHistory`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result_history = http_server.ResultHistoryGet()



        """
        return _byteblower.HTTPMultiServer_ResultHistoryGet(self)

# Register HTTPMultiServer in _byteblower:
_byteblower.HTTPMultiServer_swigregister(HTTPMultiServer)

class HTTPClient(SchedulableObject):
    r"""

    HTTP client application that may schedule HTTP requests to real webservers or
    the HTTP server application.

    Using this class, you can simulate TCP (Transmission Control Protocol) traffic
    The TCP is simulated by a HTML request to the HTTPServer. This is the
    HttpClient that will perform the GET or the PUT. This request can be sent to
    the :class:`HTTPServer` or even a real HTTPServer.

    .. code-block:: python

    	httpClient = port.ProtocolHttpClientAdd()
        httpClient.RemoteAddressSet('1.1.1.1')
        httpClient.RemotePortSet(80)
        httpClient.CaptureEnable()
        httpClient.RequestDurationSet(10 * 1000)
        httpClient.ReceiveWindowScalingValueSet(7)
        httpClient.SlowStartThresholdSet(2000000000)
        httpClient.RequestStart()



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RequestStatusGet(self):
        r"""

        Returns the status of the HTTP request.

        :return: :class:`.HTTPRequestStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestStatusGet() == HTTPRequestStatus.Scheduled)


        """
        return _byteblower.HTTPClient_RequestStatusGet(self)

    def ErrorMessageGet(self):
        r"""

        Returns the error message.

        When the request status is "Error" then extra information can be obtained
        with this method.

        :return:  The error message string

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ErrorMessageGet())

        """
        return _byteblower.HTTPClient_ErrorMessageGet(self)

    def FinishedGet(self):
        r"""

        Returns whether or not the HTTP session has finished.

        :return: True: Finished (with or without error), False: Not Finished

        Example

        Check if the client is finished

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.FinishedGet())

        """
        return _byteblower.HTTPClient_FinishedGet(self)

    def HasSession(self):
        r"""

        Returns whether or not we have a HTTP session.

        :return:  True We have a session, False  We don't have a session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.MaximumSegmentSizeGet())

        """
        return _byteblower.HTTPClient_HasSession(self)

    def HasError(self):
        r"""

        Returns true if an error has occurred.

        :return: True: An error has occurred , False: No error has occurred

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.HasError())

        """
        return _byteblower.HTTPClient_HasError(self)

    def WaitUntilConnected(self, timeout):
        r"""

        Waits until connection is established or timeout has expired.

        Valid states in which this method may be called: scheduled, connecting,
        running and finished.

        Returns true immediately when called from running or finished states.

        Returns false if timeout expired before running state was reached.

        :raises: :exc:`ConfigError` if called from configuration or stopped state.

        When called from error state or if error state is reached while waiting then the
        server-side exception that caused the error state will be rethrown here.

        :param timeout: How long we should wait before giving up (and returning false).

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	while not httpClient.WaitUntilConnected(1000000000):
        		print('Waiting until connected...')

        """
        return _byteblower.HTTPClient_WaitUntilConnected(self, timeout)

    def WaitUntilFinished(self, timeout_ns):
        r"""

        Waits until request is finished or timeout has expired.

        Valid states in which this method may be called:

        - scheduled
        - connecting
        - running
        - finished.

        Returns true immediately when called from finished state.

        Returns false if timeout expired before finished state was reached.

        :raises: :exc:`ConfigError` if called from configuration or stopped state.

        When called from error state or if error state is reached while waiting then
        the server-side exception that caused the error state will be rethrown here.

        :param timeout: How long we should wait before giving up (and returning false).

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	while not httpClient.WaitUntilFinished(1000000000):
        		print('Wait until finished...')

        """
        return _byteblower.HTTPClient_WaitUntilFinished(self, timeout_ns)
    RequestStartType_Direct = _byteblower.HTTPClient_RequestStartType_Direct
    RequestStartType_Scheduled = _byteblower.HTTPClient_RequestStartType_Scheduled

    def RequestStartTypeSet(self, inRequestStartType):
        r"""

        Configures the Start Type of a HTTP Request.

        Configures the Start Type of a HTTP Request. There are 2 possible values:

        direct
            will send out the HTTP Request as soon as a 'Page', 'Size' or 'Duration' is
            requested.

        scheduled
            will send out the HTTP Request ('Page', 'Size' or 'Duration') as soon as
            soon as the ByteBlower Port starts sending.

        :param startType: Start Type of the HTTP request.
                          Must be 'direct' or 'scheduled'.

        Default value: direct

        Example

        Setting the startype to direct

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestStartTypeSet(RequestStartType.Direct)

        Setting the startype to scheduled use :meth:`RequestInitialTimeToWaitSet` to
        configure the schedule

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestStartTypeSet(RequestStartType.Scheduled)

        """
        return _byteblower.HTTPClient_RequestStartTypeSet(self, inRequestStartType)

    def RequestStartTypeGet(self):
        r"""

        Returns the current configured Start Type.

        Returns the current configured Start Type for a HTTP Request. There are 2
        possible values:

        direct
            will send out the HTTP Request as soon as a 'Page', 'Size' or 'Duration' is
            requested.

        scheduled
            will send out the HTTP Request ('Page', 'Size' or 'Duration') as soon as
            soon as the ByteBlower Port starts sending.

        Default value: direct

        :return: Configured start type: direct or scheduled

        Example

        On a httpClient with direct starttype

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestStartTypeGet() == RequestStartType.Scheduled)

        """
        return _byteblower.HTTPClient_RequestStartTypeGet(self)

    def RequestStart(self):
        r"""

        Start the current configured HTTP Request.

        The Start Type can be configured using :meth:`RequestStartTypeSet`

        Configuring the Request is done using :meth:`RequestSizeSet` and
        :meth:`RequestDurationSet`

        :raises: :exc:`.ConfigError` This exception is thrown when some  configurations
                  are incorrect. For example if the RemoteAddress is an IPv6 address
                  and the HTTPClient has a IPv4 address.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestStart()

        """
        return _byteblower.HTTPClient_RequestStart(self)

    def RequestStop(self):
        r"""

        This will stop the client.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestStop()



        """
        return _byteblower.HTTPClient_RequestStop(self)

    def RequestSizeSet(self, inRequestSize):
        r"""

        Method which will configure a page to send out an HTTP Request to request a
        certain number of Bytes.

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with the number of requested Bytes
        transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`
                  The Start Type defines when the HTTP Request will start.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        :param requestsize: The number of Bytes to send the HTTP Request for.

        Example

        Setting the requestsize to 10000000 Bytes

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestSizeSet(10000000)

        """
        return _byteblower.HTTPClient_RequestSizeSet(self, inRequestSize)

    def RequestSizeGet(self):
        r"""

        Method which will return the configured requested pagesize expressed in Bytes.

        :return: The configured requested pagesize in Bytes

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        Example

        Getting the configured requestsize

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestSizeGet())

        """
        return _byteblower.HTTPClient_RequestSizeGet(self)

    def RequestDurationSet(self, inDurationNs):
        r"""

        Method which will configure a page to send out an HTTP Request to transmit data
        during a certain time.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with data transferred over the
        network until the requested duration has passed.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HTTPMethodSet`. The HTTP Method defines the way the data
                  traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`. The Start Type defines when the HTTP
                  Request will     start.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        :param requestDuration: The duration of data traffic to send the HTTP Request
                                for.

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid time string

        Example

        will configure a request to transfer data during 1.5 seconds expressed in nano seconds

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestDurationSet(1.5 * 1000000000)

        """
        return _byteblower.HTTPClient_RequestDurationSet(self, inDurationNs)

    def RequestDurationGet(self):
        r"""

        Method which will return the configured HTTP Request duration.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        :return: The HTTP request duration.

        Example

        Get the configured request duration

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.RequestDurationGet())

        """
        return _byteblower.HTTPClient_RequestDurationGet(self)

    def RequestRateLimitSet(self, inRateLimitBytesps):
        r"""

        Method which will limit the rate of the HTTP traffic to a certain amount..

        :param rateLimit: The rate limit, in bytes per second.

        Example

        Setting the rate limit to 10 MBytesps

        .. code-block:: python
           :emphasize-lines: 2

        	httpClient.RequestRateLimitSet(10000000)

        Example

        Disable rate limit

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestRateLimitSet(0)

        """
        return _byteblower.HTTPClient_RequestRateLimitSet(self, inRateLimitBytesps)

    def RequestRateLimitGet(self):
        r"""

        Method which will return the configured rate-limit of the HTTP traffic.

        :return: rateLimit The rate limit, in bytes per second.

        Example

        Getting the configured rate limit.

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestRateLimitGet())

        """
        return _byteblower.HTTPClient_RequestRateLimitGet(self)

    def RequestPageSet(self, arg2):
        r"""

        Method which will set the HTML page which will be requested.

        If you are requesting on a ByteBlower HTTP Server, please check
        :meth:`RequestSizeSet` and :meth:`RequestDurationSet` for specialized HTTP
        Requests

        Method which will set the HTML page which will be requested. When
        :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        A typical use in ByteBlower is a request for a certain size to a ByteBlower
        HTTP server. e.g. `10000000.html` This will give us a nice TCP traffic test
        with the number of requested Bytes transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet` The HTTP Method defines the way the data
                  traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet` The Start Type defines the way the data
                  traffic will flow.

        :param pagename: The page to send the HTTP Request for.

        Example

        Setting the client to request for the page: 100000.html

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestPageSet('100000.html')


        """
        return _byteblower.HTTPClient_RequestPageSet(self, arg2)

    def RequestPageGet(self):
        r"""

        Method which will get the HTML page which will be requested.

        If you are requesting on a ByteBlower HTTP Server, please check
        :meth:`RequestSizeSet` and :meth:`RequestDurationSet` for specialized HTTP
        Requests

        Method which will set the HTML page which will be requested. When
        :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        A typical use in ByteBlower is a request for a certain size to a ByteBlower
        HTTP server. e.g. 10000000.html This will give us a nice TCP traffic test with
        the number of requested Bytes transferred over the network.

        :return: the HTML page name that will be requested

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`
                  The Start Type defines when the data traffic will start.

        Example


        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestPageGet())


        """
        return _byteblower.HTTPClient_RequestPageGet(self)

    def RequestUriSet(self, inURI):
        r"""

        Method which will set the URI, it contains the complete HTTP URI which will be requested.

        When :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        Different from the :meth:`RequestPageSet` method, this method allows you to
        configure a HTTP Request to external (non-ByteBlower) HTTP servers without
        adding the 'server-client-id' to the HTTP Request page's path. Configuring the
        URI will also configure the HTTP Server address and HTTP Server TCP to which
        the HTTP Request is sent.

        .. note:: DNS resolution is not supported for the URI, so the HTTP Server needs
                  to be an IPv4 or IPv6 address.

        :param uri: The URI the httpClient must request.

        Example

        configure the HTTP Client to send a request to HTTP Server 1.1.1.1, on the
        default TCP port 80, for page '/test/index.html'

        .. code-block:: python
           :emphasize-lines: 2

        	httpClient.RequestUriSet(http://1.1.1.1/test/index.html)

        configure the HTTP Client to send a request to HTTP Server 10.10.10.2, on TCP
        port 8080, for page '/project/index.html'

        .. code-block:: python
           :emphasize-lines: 2

        	httpClient.RequestUriSet(http://10.10.10.2:8080/project/index.html)


        """
        return _byteblower.HTTPClient_RequestUriSet(self, inURI)

    def RequestUriGet(self):
        r"""

        Returns the requested URI.

        Returns the URI like it is or will be requested by the client.

        :return: HTTP Request URI as configured by :meth:`RequestUriSet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestUriGet())

        """
        return _byteblower.HTTPClient_RequestUriGet(self)

    def LocalPortSet(self, inPort):
        r"""

        Configure the TCP port for the client to use.

        This method will set the TCP port for the client.

        :param port: TCP port on which the client will listen or replies and send its
                     requests.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.LocalPortSet(45780)


        """
        return _byteblower.HTTPClient_LocalPortSet(self, inPort)

    def LocalPortGet(self):
        r"""

        Returns the TCP the httpclient will use to send its HTTPRequest.

        :return: The TCP port the client uses.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.LocalPortGet())

        """
        return _byteblower.HTTPClient_LocalPortGet(self)

    def RemoteAddressSet(self, inAddress):
        r"""

        Configure the destination address.

        Method to configure the address of the HTTP server which this client will try
        to contact.

        .. note:: Be aware that only addresses are used, no DNS is supported at this
                  moment.

        :param address: Address of the HTTP server this client will use.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RemoteAddressSet('1.1.1.1')

        """
        return _byteblower.HTTPClient_RemoteAddressSet(self, inAddress)

    def RemoteAddressGet(self):
        r"""

        Return the configured destination address.

        Returns the current configured remote site address.

        :return: destination address

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RemoteAddressGet())

        """
        return _byteblower.HTTPClient_RemoteAddressGet(self)

    def RemotePortSet(self, inRemotePort):
        r"""

        Configure the TCP port which the client will use as destination port.

        This method is used to configure the TCP port of the server which the client
        will try to contact.

        :param port: TCP port of the HTTP server which the client will try to contact.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        Configure the client to use port 80 as destination port

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RemotePortSet(80)


        """
        return _byteblower.HTTPClient_RemotePortSet(self, inRemotePort)

    def RemotePortGet(self):
        r"""

        Returns the configured destination port.

        This method returns the current configured TCP port of the HTTP server which
        this client will try to contact.

        :return: the remote (destination) tcp port

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	port = httpClient.RemotePortGet()

        """
        return _byteblower.HTTPClient_RemotePortGet(self)

    def MaximumSegmentSizeSet(self, inValue):
        r"""

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.MaximumSegmentSizeSet(65535)

        """
        return _byteblower.HTTPClient_MaximumSegmentSizeSet(self, inValue)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the configured TCP maximum segment size.

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPClient_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, inValue):
        r"""

        Sets the initial receive window for the client.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :param windowsize: New value of the initial receive window.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowInitialSizeSet(65535)

        """
        return _byteblower.HTTPClient_ReceiveWindowInitialSizeSet(self, inValue)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Gets the initial receive window for the client.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Default value: 65535

        :return: The configured initial receive window size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ReceiveWindowInitialSizeGet())


        """
        return _byteblower.HTTPClient_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if windowscaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True window scale enabled, False window scale disabled

        Default value: True

        Example

        When enabled:

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ReceiveWindowScalingIsEnabled())

        """
        return _byteblower.HTTPClient_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, inEnable):
        r"""

        Enables of disables windowscaling.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :param scaling: bool: which will enable (True) or disable (false)
                        windowscaling.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Default value: true

        Example

        To enable window scaling

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowScalingEnable(False)

        or to disable window scaling

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowScalingEnable(False)

        """
        return _byteblower.HTTPClient_ReceiveWindowScalingEnable(self, inEnable)

    def ReceiveWindowScalingValueSet(self, inValue):
        r"""

        Configures the window scale which will be used for the client.

        .. note:: This must be done before requesting the page, because this option is
                  negotiated at the beginning of the TCP session.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an Integer

        :raises: :exc:`.ConfigError` when the value is not in the range 0-8

        :param scale: Integer (0-8), which is used for bitwise shifting.

        Default value: 3

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowScalingValueSet()

        """
        return _byteblower.HTTPClient_ReceiveWindowScalingValueSet(self, inValue)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the current receive window scale.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        rfc:`1323`.

        Default value: 3

        :return:  the current receive window scale

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPClient_ReceiveWindowScalingValueGet(self)

    def SlowStartThresholdSet(self, inValue):
        r"""

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput.
        See :rfc:`5681` "TCP Congestion Control" for more information on this topic.

        :param sstresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive integer

        Default value: 65535

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.SlowStartThresholdSet(1000000)

        """
        return _byteblower.HTTPClient_SlowStartThresholdSet(self, inValue)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681` "TCP
        Congestion Control" for more information on this topic.

        :return: slowstart threshold

        Default value: 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.SlowStartThresholdGet())

        """
        return _byteblower.HTTPClient_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, inValue):
        r"""

        Selects the used TCP Congestion Avoidance Algorithm (TCAA).

        This must be selected before requesting the page, because for some algorithms,
        the congestion avoidance support is negotiated a the beginning of the TCP
        session.

        :param algorithm: Congestion Avoidance Algorithm to configure.
                          Possible values are:

                          - none
                          - sack
                          - newreno
                          - sack-with-cubic
                          - newreno-with-cubic

        Default value: None

        :raises: :exc:`.ConfigError` Invalid TCP congestion avoidance algorithm: When
                 the value could not be interpreted as a valid TCAA

        Example
        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)


        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)


        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)


        """
        return _byteblower.HTTPClient_TcpCongestionAvoidanceAlgorithmSet(self, inValue)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Gets the current configured TCP Congestion Avoidance Algorithm.

        :return: current Congestion Avoidance Algorithm.
                 Possible values are:

                 - none
                 - sack
                 - newreno
                 - sack-with-cubic
                 - newreno-with-cubic

        Default value: None

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewRenoWithCubic)

        """
        return _byteblower.HTTPClient_TcpCongestionAvoidanceAlgorithmGet(self)

    def RequestInitialTimeToWaitGet(self):
        r"""

        Returns the initial time to wait before a scheduled Request starts.

        :return: The initial time to wait before a scheduled request starts.
                 Units are ns

        Default value: 0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.RequestInitialTimeToWaitGet())

        """
        return _byteblower.HTTPClient_RequestInitialTimeToWaitGet(self)

    def RequestInitialTimeToWaitSet(self, inDelay):
        r"""

        Sets the initial time to wait before really requesting a page (for a scheduled
        Request).

        This can be used if you want to start different request on different timestamps.

        :param timetowait: Time to wait before the request will be really sent.
                           Units are ns

        Default value: 0

        :raises: python_error: - bad lexical cast: When the value could not be
                 interpreted as a valid time string

        Example

        Initial Time to wait of 60 seconds expressed in nanoseconds

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestInitialTimeToWaitSet(60000000000)


        """
        return _byteblower.HTTPClient_RequestInitialTimeToWaitSet(self, inDelay)

    def HttpSessionInfoGet(self):
        r"""

        Returns the HttpSessionInfo from this session.

        The HttpSessionInfo contains all the information of the current session. From
        state until the counters of received/transmitted bytes

        :return: :class:`HTTPSessionInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionInfoGet = httpClient.HttpSessionInfoGet()

        """
        return _byteblower.HTTPClient_HttpSessionInfoGet(self)

    def HttpSessionInfoDestroy(self):
        return _byteblower.HTTPClient_HttpSessionInfoDestroy(self)

    def HttpMethodSet(self, *args):
        r"""

        Configures the HTTPRequest method to be used.

        There are 2 possible values:

        GET
            The HTTP Request method will be a GET.

        PUT
            The HTTP Request method will be a PUT.

        Default value: GET

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HttpMethodSet(HTTPRequestMethod.Get)


        Configures the HTTPRequest method to be used.

        There are 2 possible values:

        GET
            The HTTP Request method will be a GET.

        PUT
            The HTTP Request method will be a PUT.

        Default value: GET

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HttpMethodSet(HTTPRequestMethod.Get)


        """
        return _byteblower.HTTPClient_HttpMethodSet(self, *args)

    def HttpMethodGet(self):
        r"""

        Returns the used HTTPRequest method.

        There are 2 possible values:

        GET
            The HTTP Request method will be a GET.
        PUT
            The HTTP Request method will be a PUT.

        Default value: GET

        :return:  The current selected HTTP request method

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.HTTPClient_HttpMethodGet(self)

    def CaptureEnable(self, inValue=True):
        r"""

        Enable the capture of the HTTPData.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.CaptureEnable()

        Enable the capture of the HTTPData.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.CaptureEnable()

        """
        return _byteblower.HTTPClient_CaptureEnable(self, inValue)

    def IsCaptureEnabled(self):
        return _byteblower.HTTPClient_IsCaptureEnabled(self)

    def CaptureGet(self):
        r"""

        Return the captured HTTP Data.

        :return: :class:`CapturedHTTPData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.CaptureGet().DescriptionGet())

        """
        return _byteblower.HTTPClient_CaptureGet(self)

    def CaptureClear(self):
        return _byteblower.HTTPClient_CaptureClear(self)

    def ClientIdGet(self):
        r"""

        Returns the unique client ID.

        Each client has a unique ID so that information about the same connection can
        be requested on a HTTP server object. This method returns the unique ClientID
        for this HTTP client.

        :return:  the httpclient unique ID

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ClientIdGet())

        """
        return _byteblower.HTTPClient_ClientIdGet(self)

    def ServerIdGet(self):
        r"""

        Returns the unique ByteBlower Server ID.

        :return: str The ByteBlower server unique ID.

        Each ByteBlower server has a unique ID. This identifier stays persistant over
        the lifetime of the ByteBlowerServers (changed when rebooted).  This serverId
        together with the clientId identifies a HTTPConnection. By adding those 2 id's
        together it is unlikely that 2 httpclients each running on a different server
        end up with the same connection ID.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ServerIdGet())

        """
        return _byteblower.HTTPClient_ServerIdGet(self)

    def ServerClientIdGet(self):
        r"""

        This method returns the combination of the server Id ( aka ByteBlower Server Id ) and client Id.

        This returns a combination of the ServerId and the Client Id. This combination
        will identify a HTTP connection. It is this combination of id's you can use to
        request the :class:`HTTPSessionInfo` on the HTTP server
        (:meth:`HTTPServer.HTTPSessionInfoGet`)

        :return:  The combined server- and client Id

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ServerClientIdGet())

        """
        return _byteblower.HTTPClient_ServerClientIdGet(self)

    def ResultGet(self):
        return _byteblower.HTTPClient_ResultGet(self)

    def ResultHistoryGet(self):
        return _byteblower.HTTPClient_ResultHistoryGet(self)

    def HistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.HistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPClient_HistorySamplingIntervalDurationGet(self)

    def HistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.HistorySamplingBufferLengthGet())

        """
        return _byteblower.HTTPClient_HistorySamplingBufferLengthGet(self)

    def HistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the HTTP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HistorySamplingIntervalDurationSet(500)

        """
        return _byteblower.HTTPClient_HistorySamplingIntervalDurationSet(self, inDuration)

    def HistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the HTTP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HistorySamplingBufferLengthSet(10)

        """
        return _byteblower.HTTPClient_HistorySamplingBufferLengthSet(self, inLength)

    def TcpHistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.TcpHistorySamplingIntervalDurationGet())

        """
        return _byteblower.HTTPClient_TcpHistorySamplingIntervalDurationGet(self)

    def TcpHistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.TcpHistorySamplingBufferLengthGet())

        """
        return _byteblower.HTTPClient_TcpHistorySamplingBufferLengthGet(self)

    def TcpHistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the TCP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TcpHistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPClient_TcpHistorySamplingIntervalDurationSet(self, inDuration)

    def TcpHistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the TCP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.TcpHistorySamplingBufferLengthSet(12)

        """
        return _byteblower.HTTPClient_TcpHistorySamplingBufferLengthSet(self, inLength)

    def TypeOfServiceSet(self, value):
        r"""

        Configures the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        Both IP headers reserve space to specify the expected quality of service (QOS).
        IPv4 calls this field the 'Type Of Service'. In IPv6 one uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the method is generic, it is used for both IPv4 and IPv6 layers. The
        implementaion will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase,thus before the
        parent ByteBlower port is started. Invoking the method at other moments will
        result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TypeOfServiceSet(16)

        """
        return _byteblower.HTTPClient_TypeOfServiceSet(self, value)

    def TypeOfServiceGet(self):
        r"""

        Retrieves the 'Type Of Service' or 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        Both IP headers reserve space to for an the expected quality of service (QOS)
        field. In IPv4 this field is called the 'Type Of Service'. IPv6 uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the getter is generic, it is used for both IPv4 and IPv6 layers.

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	type = httpClient.TypeOfServiceGet()

        """
        return _byteblower.HTTPClient_TypeOfServiceGet(self)

    def FlowLabelSet(self, value):
        r"""

        Configures the flow label for IPv6 flows.

        .. versionadded:: 2.7.0

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.FlowLabelSet(1234)

        """
        return _byteblower.HTTPClient_FlowLabelSet(self, value)

    def FlowLabelGet(self):
        r"""

        Returns the configured "Flow Label" for IPv6 flows.

        .. versionadded:: 2.7.0

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.FlowLabelGet())

        """
        return _byteblower.HTTPClient_FlowLabelGet(self)

# Register HTTPClient in _byteblower:
_byteblower.HTTPClient_swigregister(HTTPClient)


def ConvertRequestStartTypeToString(inRequestStartType):
    return _byteblower.ConvertRequestStartTypeToString(inRequestStartType)

def ParseRequestStartType(inStr):
    return _byteblower.ParseRequestStartType(inStr)
class HTTPClientMobile(AbstractObject):
    r"""

    HTTP client application that may schedule HTTP requests to the HTTP server
    application.

    .. versionadded:: 2.6.0

    Using this class, you can simulate TCP (Transmission Control Protocol) traffic
    The TCP is simulated by a HTML request to the HTTPServer. This is the HttpClient
    that will perform the GET or the PUT. This request can be sent to the
    :class:`HTTPServer` object

    Example

    .. code-block:: python
       :caption: Standard usage of the HTTPClient for WirelessEndpoints

       http_client = wireless_endpoint.ProtocolHttpClientAdd()

       # configure the HTTP server to talk with
       http_client.RemoteAddressSet('10.4.8.2')
       http_client.RemotePortSet(8080)

       # we want a session of 10 seconds
       nanoseconds_per_second = 1 * 1000 * 1000 * 1000
       http_client.RequestDurationSet(10 * nanoseconds_per_second)

       # we do not want to start immediately
       http_client.RequestInitialTimeToWaitSet(1 * nanoseconds_per_second)

       # we want the client to restart if the connection is broken
       # e.g. when the access point restarts
       http_client.RestartEnable(True)

       # start the wireless endpoint 
       wireless_endpoint.Prepare()
       wireless_endpoint.Start()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RequestDurationSet(self, inDurationNs):
        r"""

        Method which will configure a page to send out an HTTP Request to transmit data
        during a certain time.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with data transferred over the
        network until the requested duration has passed.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`


        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        :param requestDuration: The duration of data traffic to send the HTTP Request
                                for.
        :type requestDuration: int

        :raies: python_error: bad lexical cast: When the value could not be interpreted
                as a valid time string

        Example

        .. code-block:: python
           :emphasize-lines: 4
           :caption: Request a data transfer for 3 seconds.

           nanoseconds_per_second = 1000 * 1000 * 1000

           http_client.RequestDurationSet(3 * nanoseconds_per_second)

        """
        return _byteblower.HTTPClientMobile_RequestDurationSet(self, inDurationNs)

    def RequestDurationGet(self):
        r"""

        Method which will return the configured HTTP Request duration.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        :return: The HTTP request duration.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Prints the configured request duration

           print(http_client.RequestDurationGet())


        """
        return _byteblower.HTTPClientMobile_RequestDurationGet(self)

    def LocalPortSet(self, inPort):
        r"""

        Configure the TCP port for the client to use.

        This method will set the TCP port for the client.

        :param port: TCP port on the client will use to communicate with the HTTP 
                     server. Valid range: 1-65535

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the local TCP port to 20000

           http_client.LocalPortSet(20000)

        """
        return _byteblower.HTTPClientMobile_LocalPortSet(self, inPort)

    def LocalPortGet(self):
        r"""

        Returns the TCP the HTTPClientMobile will use to send its HTTPRequest.

        :return: The TCP port the client uses.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.LocalPortGet())

        """
        return _byteblower.HTTPClientMobile_LocalPortGet(self)

    def RemoteAddressSet(self, inAddress):
        r"""

        Configure the destination address.

        Method to configure the address of the HTTP server which this client will try
        to contact.

        .. note:: Be aware that only addresses are used, no DNS is supported at this
                  moment.

        :param address: IP address of the HTTP server this client will use.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RemoteAddressSet('192.168.0.4')

        """
        return _byteblower.HTTPClientMobile_RemoteAddressSet(self, inAddress)

    def RemoteAddressGet(self):
        r"""

        Return the configured destination address.

        :return: destination address
        :rtype: string

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RemoteAddressGet())

        """
        return _byteblower.HTTPClientMobile_RemoteAddressGet(self)

    def RemotePortSet(self, inRemotePort):
        r"""

        Configure the TCP port which the client will use as destination port.

        This method is used to configure the TCP port of the server which the client
        will try to contact.

        :param port:  TCP port of the HTTP server which the client will try to contact.
        :type port: int

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the remote port to port 80.

           http_client.RemotePortSet(80)

        """
        return _byteblower.HTTPClientMobile_RemotePortSet(self, inRemotePort)

    def RemotePortGet(self):
        r"""

        Returns the configured destination port.

        This method returns the current configured TCP port of the HTTP server which
        this client will try to contact.

        :return: the remote (destination) tcp port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RemotePortGet())

        """
        return _byteblower.HTTPClientMobile_RemotePortGet(self)

    def RequestInitialTimeToWaitGet(self):
        r"""

        Returns the initial time to wait before a scheduled Request starts.

        :return: The initial time in nanoseconds to wait before a scheduled request 
                 starts. (default 0)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RequestInitialTimeToWaitGet())

        """
        return _byteblower.HTTPClientMobile_RequestInitialTimeToWaitGet(self)

    def RequestInitialTimeToWaitSet(self, inDelay):
        r"""

        Sets the initial time to wait before really requesting a page (for a scheduled
        Request).

        This can be used if you want to start different request on different
        timestamps.

        :param timetowait: Time in nanoseconds to wait before the request will be really 
                           sent. (default: 0)
        :type timetowait: int

        .. todo:: figure out what the exception will be.

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid time string

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RequestInitialTimeToWaitSet(1000000000)

        """
        return _byteblower.HTTPClientMobile_RequestInitialTimeToWaitSet(self, inDelay)

    def HttpMethodSet(self, *args):
        r"""

        Configures the HTTPRequest method to be used.

        .. note:: Only 2 HTTP methods are supported for now:

                  - :attr:`HTTPRequestMethod.Get`: (default) starts a download
                  - :attr:`HTTPRequestMethod.Put`: starts an upload

        :param method: The method to be used.               
        :type method: :class:`HTTPRequestMethod`

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.HttpMethodSet(HTTPRequestMethod.Put)

        Configures the HTTPRequest method to be used.

        .. note:: Only 2 HTTP methods are supported for now:

                  - :attr:`HTTPRequestMethod.Get`: (default) starts a download
                  - :attr:`HTTPRequestMethod.Put`: starts an upload

        :param method: The method to be used.               
        :type method: :class:`HTTPRequestMethod`

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.HttpMethodSet(HTTPRequestMethod.Put)

        """
        return _byteblower.HTTPClientMobile_HttpMethodSet(self, *args)

    def HttpMethodGet(self):
        r"""

        Returns the used HTTPRequest method.

        Default value: :attr:`.HTTPRequestMethod.Get`

        :return: The current selected HTTP request method
        :rtype: :class:`HTTPRequestMethod`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.HttpMethodGet() == HTTPRequestMethod.Get)

        """
        return _byteblower.HTTPClientMobile_HttpMethodGet(self)

    def RequestRateLimitSet(self, inRateLimitBytesps):
        r"""

        Method which will limit the rate of the HTTP traffic to a certain amount..

        :param ratelimit: The rate limit, in bytes per second.  0 disables the rate limit.
        :type ratelimit: int

        Example

        .. code-block:: python
           :emphasize-lines: 4
           :caption: Set the ratelimit to 10 megabytes per second

           bytes_per_megabyte = 1000 * 1000

           http_client = wireless_endpoint.ProtocolHttpClientAdd()
           http_client.RequestRateLimitSet(10 * bytes_per_megabyte)

        Example

        Disable rate limit

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RequestRateLimitSet(0)

        """
        return _byteblower.HTTPClientMobile_RequestRateLimitSet(self, inRateLimitBytesps)

    def RequestRateLimitGet(self):
        r"""

        Method which will return the configured rate-limit of the HTTP traffic.

        :return: rateLimit The rate limit, in bytes per second.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the configured rate limit in bytes per second

           print(http_client.RequestRateLimitGet())

        """
        return _byteblower.HTTPClientMobile_RequestRateLimitGet(self)

    def RestartIsEnabled(self):
        r"""

        Method which will return whether or not the HTTP Client will restart the
        session when the connection fails.

        :return: True if enabled, false otherwise.
        :rtype: bool

        .. versionadded:: 2.10.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RestartIsEnabled())

        """
        return _byteblower.HTTPClientMobile_RestartIsEnabled(self)

    def RestartEnable(self, arg2):
        r"""

        Let the HTTP Client try to restart the session when a connection fails.

        The HTTP Client will setup a new HTTP connection when the connection is lost for
        some reason. Possible reasons are loss of the network connection on the device,
        loss of the TCP connection due to a rebooting device somewhere in the network...

        To distinguish the different sessions, the ClientServerId is used as a prefix.
        The connection attempt number is appended to the ID

        .. versionadded:: 2.10.0

        :param enable: True to enable, False to disable.
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Enable the restart behaviour

           http_client.RestartEnable(True)

        """
        return _byteblower.HTTPClientMobile_RestartEnable(self, arg2)

    def ClientIdGet(self):
        r"""

        Returns the unique client ID.

        Each client has a unique ID so that information about the same connection can
        be requested on a HTTP server object. This method returns the unique ClientID
        for this HTTP client.

        :return: the HTTPClientMobile unique ID
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.ClientId())

        """
        return _byteblower.HTTPClientMobile_ClientIdGet(self)

    def ServerIdGet(self):
        r"""

        Returns the unique ByteBlower Server ID.

        :return: The ByteBlower server unique ID.
        :rtype: str

        Each ByteBlower server has a unique ID. This identifier stays persistent over
        the lifetime of the ByteBlowerServers ( changed when rebooted ). This serverId
        together with the clientId identifies a HTTPConnection. By adding those 2 id's
        together it is unlikely that 2 HTTPClientMobiles each running on a different
        server end up with the same connection ID.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the Server ID

           print(http_client.ServerIdGet())

        """
        return _byteblower.HTTPClientMobile_ServerIdGet(self)

    def ServerClientIdGet(self):
        r"""

        This method returns the combination of the server Id (aka ByteBlower Server Id)
        and client Id.

        This returns a combination of the ServerId and the Client Id. This combination
        will identify a HTTP connection. It is this combination of id's you can use to
        request the :class:`HTTPSessionInfo` on the HTTP server :class:`HTTPServer`

        :return: The combined server- and client Id
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.ServerClientIdGet())

        """
        return _byteblower.HTTPClientMobile_ServerClientIdGet(self)

    def TypeOfServiceSet(self, value):
        r"""

        Configures the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        This method sets the :term:`Type of Service` for an IPv4 connection or the
        :term:`Traffic Class` for an IPv6 connection. Despite naming, they are both 
        8 bits wide. For ease of use, the method is generic, it is used for both IPv4
        and IPv6 layers. The implementation will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before 
        the parent ByteBlower port is started. Invoking the method at other moments 
        will result in error.

        :param tos: The literal value to be set (0-255)
        :type tos: integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.TypeOfServiceSet(8)

        """
        return _byteblower.HTTPClientMobile_TypeOfServiceSet(self, value)

    def TypeOfServiceGet(self):
        r"""

        Retrieves the 'Type Of Service' or 'Traffic Class' configuration of the IP
        layer.

        .. versionadded:: 2.5.0

        Both IP headers reserve space to for an the expected quality of service(QOS)
        field. In IPv4 this field is called the 'Type Of Service'. IPv6 uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the getter is generic, it is used for both IPv4 and IPv6 layers.

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.TypeOfServiceGet())

        """
        return _byteblower.HTTPClientMobile_TypeOfServiceGet(self)

# Register HTTPClientMobile in _byteblower:
_byteblower.HTTPClientMobile_swigregister(HTTPClientMobile)

HTTPServerStatus_Running = _byteblower.HTTPServerStatus_Running
HTTPServerStatus_Stopped = _byteblower.HTTPServerStatus_Stopped
HTTPServerStatus_Error = _byteblower.HTTPServerStatus_Error
HTTPServerStatus_Unknown = _byteblower.HTTPServerStatus_Unknown
class HTTPServer(AbstractObject):
    r"""

    HTTP server application that handles incoming HTTP requests with the correct
    URL format by returning a document of the appropriate size.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ByteBlowerServerGet(self):
        return _byteblower.HTTPServer_ByteBlowerServerGet(self)

    def ByteBlowerPortGet(self):
        return _byteblower.HTTPServer_ByteBlowerPortGet(self)

    def Start(self):
        r"""

        Starts the HTTP server on the configured port with the configured
        configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.Start()


        """
        return _byteblower.HTTPServer_Start(self)

    def Stop(self):
        r"""

        Stops the HTTP server.

        Running sessions will be stopped and new requests will be ignored.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.Stop()



        """
        return _byteblower.HTTPServer_Stop(self)

    def StatusGet(self):
        r"""

        Returns the HTTP server status.

        :return: :class:`.HTTPServerStatus`

        Example

        Before starting the HTTP server:  {stopped} After starting the HTTP server:
        {running}

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.StatusGet() == HTTPRequestStatus.Connecting)


        """
        return _byteblower.HTTPServer_StatusGet(self)

    def PortSet(self, inPort):
        r"""

        Configures the TCP port on which the HTTP server will listen.

        :param port: The TCP port on which the HTTP server will listen for incoming
                     requests.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.PortSet(80)


        """
        return _byteblower.HTTPServer_PortSet(self, inPort)

    def PortGet(self):
        r"""

        Returns the configured TCP port for the HTTP server.

        :return: The configured TCP Port

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(httpServer.PortGet())


        """
        return _byteblower.HTTPServer_PortGet(self)

    def HttpSessionInfoGet(self, inServerClientId):
        r"""

        Returns the :class:`.HTTPSessionInfo` from this session.

        The HttpSessionInfo contains all the information of the current session. From
        state until the counters of received/transmitted bytes

        :param clientID: ID of the client which has connected with this server. This ID
                         can be retrieved from the :meth:`HTTPClient.ServerClientIdGet`
                         method on the HTTPClient.

        .. warning:: call :meth:`HasSession` to verify that the client session exists,
                     before calling this function. Otherwise, an exception may be
                     thrown.

        :return: :class:`.HTTPSessionInfo`

        :raises: :exc:`.ConfigError` when the HTTP Server did not setup the given HTTP
                 session (e.g. when the TCP connection failed)

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.HttpSessionInfoGet())


        """
        return _byteblower.HTTPServer_HttpSessionInfoGet(self, inServerClientId)

    def HasSession(self, inServerClientId):
        r"""

        Returns whether or not a client session exists with the given
        server-client-identifier.

        :return: True when we have a Session, False if we don't

        See also: :meth:`.HTTPClient.ServerClientIdGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.HasSession('BBhttpS2502398654/BBhttpC1146349503' ))



        """
        return _byteblower.HTTPServer_HasSession(self, inServerClientId)

    def ResultGet(self, inServerClientId):
        return _byteblower.HTTPServer_ResultGet(self, inServerClientId)

    def ResultHistoryGet(self, inServerClientId):
        return _byteblower.HTTPServer_ResultHistoryGet(self, inServerClientId)

    def HttpSessionInfoDestroy(self, inServerClientId):
        return _byteblower.HTTPServer_HttpSessionInfoDestroy(self, inServerClientId)

    def MaximumSegmentSizeSet(self, inValue):
        r"""

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.MaximumSegmentSizeSet(65525)


        """
        return _byteblower.HTTPServer_MaximumSegmentSizeSet(self, inValue)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the configured TCP maximum segment size.

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.MaximumSegmentSizeGet())



        """
        return _byteblower.HTTPServer_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, inValue):
        r"""

        Sets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :param windowsize: New value of the initial receive window.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.ReceiveWindowInitialSizeSet(65535)



        """
        return _byteblower.HTTPServer_ReceiveWindowInitialSizeSet(self, inValue)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Gets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(httpServer.ReceiveWindowInitialSizeGet())

        """
        return _byteblower.HTTPServer_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if window scaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True: Window scaling is enabled, False when disabled


        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, inWindowScaling):
        r"""

        Enables of disables windowscaling.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :param scaling: Boolean which will enable ( true ) or disable ( false )
                        windowscaling.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Example

        To enable window scaling  or  To disable window scaling  or

        .. code-block:: python
           :emphasize-lines: 1

        	httppServer.ReceiveWindowScalingEnable(True)



        """
        return _byteblower.HTTPServer_ReceiveWindowScalingEnable(self, inWindowScaling)

    def SessionStorageIsEnabled(self):
        r"""


        """
        return _byteblower.HTTPServer_SessionStorageIsEnabled(self)

    def SessionStorageEnable(self, value):
        r"""


        """
        return _byteblower.HTTPServer_SessionStorageEnable(self, value)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the current receive window scale.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in
        :rfc:`1323`.

        :return: current receive window scale

        Default value: 3

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingValueGet(self)

    def ReceiveWindowScalingValueSet(self, inRcvWindowScale):
        r"""

        Configures the window scale which will be used for new clients.

        This must be done before requesting a page from a client, because this option
        is negotiated at the beginning of the TCP session.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in
        IETF rfc:`1323`.

        :param scale: Integer (0-8), which is used for bitwise shifting.

        Default value: 3

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.ReceiveWindowScalingValueSet(7)



        """
        return _byteblower.HTTPServer_ReceiveWindowScalingValueSet(self, inRcvWindowScale)

    def SlowStartThresholdSet(self, inValue):
        r"""

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :param ssthresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive
                 integer

        Default value: 65535

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.SlowStartThresholdSet(1000000)



        """
        return _byteblower.HTTPServer_SlowStartThresholdSet(self, inValue)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :return: Slow-start threshold

        Default value: 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.SlowStartThresholdGet())



        """
        return _byteblower.HTTPServer_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, inValue):
        r"""

        Selects the TCP Congestion Avoidance Algorithm.

        Selects the TCP Congestion Avoidance Algorithm which will be used for new
        clients. This must be selected before requesting a page from a client, because
        for some algorithms, the congestion avoidance support is negotiated a the
        beginning of the TCP session.

        :param algorithm: Congestion Avoidance Algorithm to configure.

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Default value: None

        :raises: python_error: Failed to parse enumerator: When the value could not be
                 interpreted as a valid TCAA

        Example

        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)



        """
        return _byteblower.HTTPServer_TcpCongestionAvoidanceAlgorithmSet(self, inValue)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Gets the current configured TCP Congestion Avoidance Algorithm for new clients.

        :return: current Congestion Avoidance Algorithm.
        :rtype: :class:`.TCPCongestionAvoidanceAlgorithm`

        Default value: :attr:`.TCPCongestionAvoidanceAlgorithm.No_Algorithm`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewRenoWithCubic)



        """
        return _byteblower.HTTPServer_TcpCongestionAvoidanceAlgorithmGet(self)

    def ClientIdentifiersGet(self):
        r"""

        Returns the list of known identifiers of HTTP clients which made a connection
        to this server.

        :return: List of Client Identifiers which have connected this server.

        See also: :meth:`HTTPClient.ServerClientIdGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.ClientIdentifiersGet()[0])



        """
        return _byteblower.HTTPServer_ClientIdentifiersGet(self)

    def HistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.HistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPServer_HistorySamplingIntervalDurationGet(self)

    def HistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.HistorySamplingBufferLengthGet())



        """
        return _byteblower.HTTPServer_HistorySamplingBufferLengthGet(self)

    def HistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.HistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPServer_HistorySamplingIntervalDurationSet(self, inDuration)

    def HistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.HistorySamplingBufferLengthSet(10)


        """
        return _byteblower.HTTPServer_HistorySamplingBufferLengthSet(self, inLength)

    def TcpHistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.TcpHistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPServer_TcpHistorySamplingIntervalDurationGet(self)

    def TcpHistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.TcpHistorySamplingBufferLengthGet())

        """
        return _byteblower.HTTPServer_TcpHistorySamplingBufferLengthGet(self)

    def TcpHistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.TcpHistorySamplingIntervalDurationSet(500)



        """
        return _byteblower.HTTPServer_TcpHistorySamplingIntervalDurationSet(self, inDuration)

    def TcpHistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.TcpHistorySamplingBufferLengthSet(10)



        """
        return _byteblower.HTTPServer_TcpHistorySamplingBufferLengthSet(self, inLength)

# Register HTTPServer in _byteblower:
_byteblower.HTTPServer_swigregister(HTTPServer)

class ICMPEchoSession(AbstractObject):
    r"""

    Session for handling ICMP Echo Requests and Replies.

    This Session uses the ICMP protocol for receiving and / or transmitting
    ICMP Echo Request and / or Replies

    Some use cases for this session are:

    - DUT validation

      - Verify Echo Request / Replies are either or not filtered out

      - Verify public / private connectivity for Routers, NAT gateways, ...

    - DUT stability

      - Verify Echo Replies are received during some stability tests


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RemoteAddressSet(self, inIPAddress):
        r"""

        Configure the destination IPv4 address.

        .. versionadded:: 2.3.0

        This method configures the destination IPv4 address for our ICMP Echo packets

        The destination IPv4 address defines to where the ICMP Echo Requests will be
        sent or from where ICMP Echo Responses are / were received.

        :param ipv4Address: The Destination IPv4 Address for this session.

        :raises: <python_error> - Invalid IPv4 address: When the value could not
                 be interpreted as an IPv4 address

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.RemoteAddressSet('10.8.254.69')



        """
        return _byteblower.ICMPEchoSession_RemoteAddressSet(self, inIPAddress)

    def RemoteAddressGet(self):
        r"""

        Returns the ICMP Echo Request destination IPv4 address.

        .. versionadded:: 2.3.0

        This method returns the IPv4 address which has been configured with
        :meth:`RemoteAddressSet`

        :return: The Destination IPv4 address for this session.

        :raises: ByteBlower.Session - When the destination IPv4 address was not yet
                 configured

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RemoteAddressGet())



        """
        return _byteblower.ICMPEchoSession_RemoteAddressGet(self)

    def TtlSet(self, inTTL):
        r"""

        Configures the IPv4 time-to-live.

        This method configures the IPv4 TTL (time-to-live) for the ICMP Echo packets.

        The TTL defines the maximum lifetime of an IPv4 (in this case ICMP) packet in
        the network. Every router that the packet passes decrements the TTL field in
        the packet. When the TTL reaches value 0 before it is delivered at its
        destination, it will be dropped. The router will respond to the sender with an
        ICMP packet type 11 (Time Exceeded).

        .. note:: The IPv4 TTL applies for all ICMP Echo packets (Requests and Responses)

        .. note:: The TTL only applies for this session, other sessions in this
                  `class:`.ICMPProtocol` are not affected.

        :param ttl: The IPv4 TTL you wish to configure. (Valid range: 0 to 255.)
                    Default: 255

        :raises: <python_error> - bad lexical cast: When the value could not be
                                  interpreted as a valid integer
        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        .. versionadded:: 1.8.18

        Example

        Configure a TTL of 127 for the ICMP Request and Reply packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.TtlSet(127)


        """
        return _byteblower.ICMPEchoSession_TtlSet(self, inTTL)

    def TtlGet(self):
        r"""

        Returns the current IPv4 time-to-live.

        This method returns the current IPv4 TTL (time-to-live) for the
        ICMP Echo packets.

        The TTL defines the maximum lifetime of an IPv4 (in this case ICMP) packet in
        the network. Every router that the packet passes decrements the TTL field in
        the packet. When the TTL reaches value 0 before it is delivered at its
        destination, it will be dropped. The router will respond to the sender with an
        ICMP packet type 11 (Time Exceeded).

        .. note:: The IPv4 TTL applies for all ICMP Echo packets (Requests and Responses)

        Default value: 255

        :return: IPv4 time-to-live for all ICMP Echo packets

        .. versionadded:: 1.8.18

        """
        return _byteblower.ICMPEchoSession_TtlGet(self)

    def TypeOfServiceSet(self, inTOS):
        r"""

        Configures the 'Type Of Service' used at the IP layer.

        .. versionadded:: 2.5.0

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before
        the parent ByteBlower port is started. Invoking the method at other moments
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.TypeOfServiceSet(16)


        """
        return _byteblower.ICMPEchoSession_TypeOfServiceSet(self, inTOS)

    def TypeOfServiceGet(self):
        r"""

        Retrieves the 'Type Of Service' configuration of the IP layer.

        .. versionadded:: 2.5.0

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.TypeOfServiceGet())



        """
        return _byteblower.ICMPEchoSession_TypeOfServiceGet(self)

    def IdentifierGet(self):
        r"""

        Returns the ICMP Echo Request ICMPID.

        This method returns the ICMP Echo Request ICMPID.
        This is also known as the Application ID

        The Application ID is either generated randomly or is the one that has been
        provided with :meth:`.ICMPProtocol.SessionAdd`

        :return: The ICMP Echo Request ICMP ID for this Session.

        Example

        Returns the (integer) value of the ICMP ID (Application ID)

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.IdentifierGet())



        """
        return _byteblower.ICMPEchoSession_IdentifierGet(self)

    def DataSizeSet(self, inDataSize):
        r"""

        Configures the data size.

        This method configures the data size of our ICMP Echo Requests

        The data size of our ICMP Echo Requests is the payload size of the packet

        :param dataSize: The ICMP data size you wish to configure.

        The valid range of `dataSize` is:
        (0 to *<port_mdl>*) - *<ICMP_header_size>*.

        Where

        <port_mdl>
            Value of :meth:`.ByteBlowerPort.MDLGet`

        *<ICMP_header_size>*
            Ethernet header size (14) + IPv4 header size (20) + ICMP header size (8)

        Default value: 56

        :raises: <python_error> - bad lexical cast: When the value could not be
                 interpreted as a valid integer
        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        Example

        Configure 92Bytes payload for the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.DataSizeSet(92)


        """
        return _byteblower.ICMPEchoSession_DataSizeSet(self, inDataSize)

    def DataSizeGet(self):
        r"""

        Returns the data size.

        This method returns the data size of our ICMP Echo Requests

        The data size of our ICMP Echo Requests is the payload size of the packet

        Default value: 56

        :return: ICMP Echo data size

        Example

        The ICMP session has been configure to add 76Bytes payload in the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 2

        	print(icmpEchoSession.DataSizeGet())


        """
        return _byteblower.ICMPEchoSession_DataSizeGet(self)

    def EchoRequestSend(self):
        r"""

        Transmit an ICMP Echo Request.

        This method sends one ICMP Echo Request.

        .. note:: This method call is (partially) non-blocking. The call will not
                  return as soon the session is setup and the request is sent or an
                  error occurred (exception is thrown). The call does not wait until
                  an Echo Reply is received.


        .. note:: The Destination IPv4 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: ByteBlower.Session.Unavailable - When the destination IPv4 address was
                 not yet configured
        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv4
                 address cannot be reached

        """
        return _byteblower.ICMPEchoSession_EchoRequestSend(self)

    def EchoStatsClear(self):
        r"""

        Resets the ICMP Session statistics.

        .. deprecated:: 2.3.0
                        The recommended approach is to destruct this session and create
                        a new one.

        This method resets the ICMP Session statistics.

        """
        return _byteblower.ICMPEchoSession_EchoStatsClear(self)

    def EchoLoopIntervalSet(self, inTimeNs):
        r"""

        Configures the Echo Request interval.

        This method configures the interval between subsequent Echo Request packets
        when sending in a loop.

        The interval has a nanosecond resolution. You can provide a time unit for the
        loop interval value.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param loopInterval: The interval between two ICMP Echo Request packets [ns].
                             Valid range: 0 to *<max_uint64>*[ns]
                             Where *<max_uint64>*  = 0xFFFFFFFFFFFFFFFF = 18446744073709551615
                             (= maximum unsigned 64bit integer)
        :type loopInterval: int

        Default value: 1s

        :raises: <python_error> - Failed to parse time string: When the value could not
                 be interpreted as a valid time string

        Example

        Configure an interval of 50 microseconds (50000 nanoseconds)

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(50000)

        Configure an interval of 500 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(500000000)


        Configure an interval of 1.25 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(1250000)



        """
        return _byteblower.ICMPEchoSession_EchoLoopIntervalSet(self, inTimeNs)

    def EchoLoopIntervalGet(self):
        r"""

        Returns the Echo Request interval.

        This method returns the interval between subsequent Echo Request packets when
        sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        .. note:: The interval is always returned in nanoseconds resolution. No unit is
                  added to the value.

        Default value: 1s

        :return: The interval between two ICMP Echo Request packets [ns]
        :rtype: int

        Example

        The transmit loop is configured with an interval of 625 microseconds

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.EchoLoopIntervalGet())


        """
        return _byteblower.ICMPEchoSession_EchoLoopIntervalGet(self)

    def EchoLoopCountSet(self, inCount):
        r"""

        Configures the Echo Request count.

        This method configures the number of Echo Requests which will be transmitted
        when sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param packetCount: The number of ICMP Echo Request packets to transmit

        Default value: infinite

        The actual value is *<max_uint64>* = 0xFFFFFFFFFFFFFFFF = 18446744073709551615)

        :except: <python_error> - bad lexical cast: When the value could not be
                 interpreted as a valid integer

        .. versionadded:: 1.8.18

        Example

        Configure the loop to transmit 100 ICMP Echo Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopCountSet(100)


        """
        return _byteblower.ICMPEchoSession_EchoLoopCountSet(self, inCount)

    def EchoLoopCountGet(self):
        r"""

        Returns the Echo Request count.

        This method returns the number of Echo Requests which will be transmitted when
        sending in a loop.

        Default value: infinite
        (*<max_uint64>* = 0xFFFFFFFFFFFFFFFF = 18446744073709551615)

        :return: The number of ICMP Echo Request packets in a loop

        .. versionadded:: 1.8.18

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

            print(icmpEchoSession.EchoLoopCountGet())



        """
        return _byteblower.ICMPEchoSession_EchoLoopCountGet(self)

    def EchoLoopStart(self):
        r"""

        Starts sending Echo Requests in a loop.

        This method start sending Echo Requests in a loop.

        The interval between Echo Request can be configured using the method
        :meth:`EchoLoopIntervalSet`

        If a limited number of Echo Request is desired, this can be configured using
        the method :meth:`EchoLoopCountSet`

        .. note:: This method call is (partially) non-blocking. The call will return as
                  soon as the session is started an the loop is running or an error
                  occurred during session initialization.

        .. note:: The Destination IPv4 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: ByteBlower.Session.Unavailable - When the destination IPv4 address
                 was not yet configured
        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv4
                 address cannot be reached

        """
        return _byteblower.ICMPEchoSession_EchoLoopStart(self)

    def EchoLoopStop(self):
        r"""

        Stops sending Echo Requests in a loop.

        This method stops sending Echo Requests in a loop. The loop can be started with
        :meth:`EchoLoopStart`

        .. note:: This method does not throw an exception if the loop was not started

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopStop()



        """
        return _byteblower.ICMPEchoSession_EchoLoopStop(self)

    def GetICMPProtocol(self):
        return _byteblower.ICMPEchoSession_GetICMPProtocol(self)

    def SessionInfoGet(self):
        r"""

        Returns the session information.

        .. versionadded:: 2.3.0

        This method returns the SessionInfo object.

        :return: The session information in an object.
        :rtype: A :class:`ICMPEchoSessionInfo` object

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopStart()


        """
        return _byteblower.ICMPEchoSession_SessionInfoGet(self)

# Register ICMPEchoSession in _byteblower:
_byteblower.ICMPEchoSession_swigregister(ICMPEchoSession)

class ICMPEchoSessionInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were transmitted for the session.

        :return: The number of ICMP Echo requests which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(icmpEchoSessionInfo.TxEchoRequestsGet())



        """
        return _byteblower.ICMPEchoSessionInfo_TxEchoRequestsGet(self)

    def TxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were transmitted for the session.

        :return: The number of ICMP Echo replies which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(icmpEchoSessionInfo.TxEchoRepliesGet())



        """
        return _byteblower.ICMPEchoSessionInfo_TxEchoRepliesGet(self)

    def RxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were received for the session.

        :return: The number of ICMP Echo requests which were received during the
                 session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSessionInfo.RxEchoRequestsGet())



        """
        return _byteblower.ICMPEchoSessionInfo_RxEchoRequestsGet(self)

    def RxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were received for the session.

        :return: The number of ICMP Echo replies which were received during the session

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(icmpEchoSessionInfo.RxEchoRepliesGet())


        """
        return _byteblower.ICMPEchoSessionInfo_RxEchoRepliesGet(self)

    def RefreshTimestampGet(self):
        r"""

        Gets the timestamp on the server of when the session info was refreshed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.RefreshTimestampGet())



        """
        return _byteblower.ICMPEchoSessionInfo_RefreshTimestampGet(self)

# Register ICMPEchoSessionInfo in _byteblower:
_byteblower.ICMPEchoSessionInfo_swigregister(ICMPEchoSessionInfo)

class ICMPProtocol(AbstractObject):
    r"""

    The ICMP protocol is attached to the IPv4 protocol and allows the host to start
    ICMP sessions, through which it can communicate with the Layer3 IP network.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.ICMPProtocol_ServerGet(self)

    def PortGet(self):
        return _byteblower.ICMPProtocol_PortGet(self)

    def SessionAdd(self, *args):
        r"""

        Creates an ICMP Echo Session, through which this host can query the Layer3 IP network.

        See :class:`ICMPEchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed in :meth:`SessionGet`.
        If you want such sessions to be listed there, you will need to call
        :meth:`SessionAdd` given the `applicationId` that is used by the external tool.

        :param applicationId: Provide an application id for this session.
                              This should be unique across the host. If none is given,
                              a random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPEchoSession` - The created echo session is immediately
                 returned.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        Creates an ICMP Echo Session, through which this host can query the Layer3 IP network.

        See :class:`ICMPEchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed in :meth:`SessionGet`.
        If you want such sessions to be listed there, you will need to call
        :meth:`SessionAdd` given the `applicationId` that is used by the external tool.

        :param applicationId: Provide an application id for this session.
                              This should be unique across the host. If none is given,
                              a random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPEchoSession` - The created echo session is immediately
                 returned.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        """
        return _byteblower.ICMPProtocol_SessionAdd(self, *args)

    def SessionGet(self):
        r"""

        Returns the active list of ICMP Echo Sessions.

        .. note:: The ICMP Protocol may have more active sessions at *server-side* than
                  listed here.

                  This list only returns the :class:`ICMPEchoSession` objects for which
                  a handle has been created at client-side. See below for more
                  information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed here. If you want such sessions
        to be listed here, you will need to call :meth:`SessionAdd` given the
        `applicationId` that is used by the external tool.

        :return: A :class:`ICMPEchoSessionList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           list = icmpProtocol.SessionGet()


        """
        return _byteblower.ICMPProtocol_SessionGet(self)

    def SessionDestroy(self, inSession):
        return _byteblower.ICMPProtocol_SessionDestroy(self, inSession)

# Register ICMPProtocol in _byteblower:
_byteblower.ICMPProtocol_swigregister(ICMPProtocol)

class ICMPv6EchoSession(AbstractObject):
    r"""

    Session for handling ICMPv6 Echo Requests and Replies.

    This Session uses the ICMPv6 protocol for receiving and / or transmitting
    ICMPv6 Echo Request and / or Replies An ICMPv6 session can be created using
    :meth:`.ICMPv6Protocol.SessionAdd`

    Some use cases for this session are:

    DUT validation
        Verify some DUT behavioural items

        - Verify whether Echo Request / Replies are filtered out or not
        - Verify public / private connectivity for Routers, NAT gateways, ...

    DUT stability
        Verify that Echo Replies are received during stability tests


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RemoteAddressSet(self, inIPAddress):
        r"""

        Configure the destination IPv6 address.

        .. versionadded:: 2.3.0

        This method configures the destination IPv6 address for our ICMPv6 Echo packets

        The destination IPv6 address defines to where the ICMPv6 Echo Requests will be
        sent or from where ICMPv6 Echo Responses are / were received.

        :param ipv6address: The Destination IPv6 Address for this session.

        :raises: python_error: Invalid IPv6 address: When the value could not be
                 interpreted as an IPv6 address

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.RemoteAddressSet(2001:0db8:85a3:0042:1000:8a2e:0370:7334)



        """
        return _byteblower.ICMPv6EchoSession_RemoteAddressSet(self, inIPAddress)

    def RemoteAddressGet(self):
        r"""

        Returns the ICMPv6 Echo Request destination IPv6 address.

        .. versionadded:: 2.3.0

        This method returns the IPv6 address which has been configured with
        :meth:`RemoteAddressSet`

        :return: The Destination IPv6 address for this session.

        :raises: ByteBlower.Session - When the destination IPv6 address was not yet
                 configured

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(icmpEchoSession.RemoteAddressGet())


        """
        return _byteblower.ICMPv6EchoSession_RemoteAddressGet(self)

    def DataSizeSet(self, inDataSize):
        r"""

        Configures the data size.

        This method configures the data size of our ICMPv6 Echo Requests

        The data size of our ICMPv6 Echo Requests is the payload size of the packet

        :param datasize: The ICMPv6 data size you wish to configure.

        Valid range: 0 to *<port_mdl>* - *<ICMPv6_header_size>*.
        Where

        *<port_mdl>*
            Value of :meth:`ByteBlowerPort.MDLGet`

        *<ICMPv6_header_size>*
            Ethernet header size  (14) + IPv6 header size (40) + ICMPv6 header size (8)

        Default value: 56

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid integer

        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        Example

        Configure 92Bytes payload for the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.DataSizeSet(92)



        """
        return _byteblower.ICMPv6EchoSession_DataSizeSet(self, inDataSize)

    def DataSizeGet(self):
        r"""

        Returns the data size of our ICMPv6 Echo Requests.

        The data size of our ICMPv6 Echo Requests is the payload size of the packet

        Default value: 56

        :return: ICMPv6 Echo data size

        Example

        The ICMPv6 session has been configure to add 76 Bytes payload in the ICMPv6
        Request packets

        .. code-block:: python
           :emphasize-lines: 3

           pritn(icmpEchoSession.DataSizeGet())


        """
        return _byteblower.ICMPv6EchoSession_DataSizeGet(self)

    def IdentifierGet(self):
        r"""

        Getting the ICMPv6 Echo Request Identifier (Application ID)

        :return: The ICMPv6 Echo Request ICMPv6 Identifier for this Session.

        Example

        Returns the (integer) value of the ICMP ID (Application ID)

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.IdentifierGet())



        """
        return _byteblower.ICMPv6EchoSession_IdentifierGet(self)

    def EchoRequestSend(self):
        r"""

        Transmit an ICMPv6 Echo Request.

        This method sends one ICMPv6 Echo Request.

        .. note:: This method call is (partially) non-blocking. The call will not
                  return as soon the session is setup and the request is sent or an
                  error occurred (exception is thrown). The call does not wait until an
                  Echo Reply is received.

        .. note:: The Destination IPv6 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: ByteBlower.Session.Unavailable - When the destination IPv6 address was
                 not yet configured

        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv6
                 address cannot be reached

        """
        return _byteblower.ICMPv6EchoSession_EchoRequestSend(self)

    def EchoStatisticsClear(self):
        r"""

        Resets the ICMPv6 Session statistics.

        .. deprecated:: 2.3.0.
           The recommended approach is to destruct this session and create a new one.

        This method resets the ICMPv6 Session statistics.

        """
        return _byteblower.ICMPv6EchoSession_EchoStatisticsClear(self)

    def EchoLoopIntervalSet(self, inTimeNs):
        r"""

        Configures the Echo Request interval.

        This method configures the interval between subsequent Echo Request packets
        when sending in a loop.

        The interval has a nanosecond resolution. You can provide a time unit for the
        loop interval value.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param loopInterval: The interval between two ICMPv6 Echo Request packets [ns].
        :type loopInterval: int

        Valid range: 0 to *<max_uint64>*

            Where *<max_uint64>*    0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            (= maximum unsigned 64bit integer)

        Default value: 1s

        :raises: python_error: Failed to parse time string:
                 When the value could not be interpreted as a valid time string

        Example

        Configure an interval of 50 microseconds (50000 nanoseconds)

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.EchoLoopIntervalSet(50000)

        Configure an interval of 500 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(500000000)


        Configure an interval of 1.25 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(1250000)



        """
        return _byteblower.ICMPv6EchoSession_EchoLoopIntervalSet(self, inTimeNs)

    def EchoLoopIntervalGet(self):
        r"""

        Returns the Echo Request interval.

        This method returns the interval between subsequent Echo Request packets when
        sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        .. note:: The interval is always returned in nanoseconds resolution.
                  No unit is added to the value.

        Default value: 1s

        :return: The interval between two ICMPv6 Echo Request packets [ns]

        Example

        The transmit loop is configured with an interval of 625 microseconds

        .. code-block:: python
           :emphasize-lines: 3

        	print(icmpEchoSession.EchoLoopIntervalGet())


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopIntervalGet(self)

    def EchoLoopCountSet(self, arg2):
        r"""

        Configures the Echo Request count.

        This method configures the number of Echo Requests which will be transmitted
        when sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param packetcount: The number of ICMPv6 Echo Request packets to transmit

        Default value: infinite
        The actual value is

            *<max_uint64>*
            = 0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            (= maximum unsigned 64bit integer)

        :raises: python_error bad lexical cast: When the value could not be
                 interpreted as a valid integer

        .. versionadded:: 1.8.18

        Example

        Configure the loop to transmit 500 ICMP Echo Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopCountSet(500)


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopCountSet(self, arg2)

    def EchoLoopCountGet(self):
        r"""

        Returns the Echo Request count.

        This method returns the number of Echo Requests which will be transmitted when
        sending in a loop.

        Default value: infinite

            The actual value is *<max_uint64>*
            = 0xFFFFFFFFFFFFFFFF
            = 18446744073709551615 (= maximum unsigned 64bit integer)

        :return: The number of ICMPv6 Echo Request packets in a loop

        .. versionadded:: 1.8.18

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.EchoLoopCountGet())



        """
        return _byteblower.ICMPv6EchoSession_EchoLoopCountGet(self)

    def EchoLoopStart(self):
        r"""

        Starts sending Echo Requests in a loop.

        This method start sending Echo Requests in a loop.

        The interval between Echo Request can be configured using the method
        :meth:`EchoLoopIntervalSet`

        If a limited number of Echo Request is desired, this can be configured using
        the method :meth:`EchoLoopCountSet`

        .. note:: This method call is (partially) non-blocking. The call will return as
                  soon as the session is started an the loop is running or an error
                  occurred during session initialization.

        .. note:: The Destination IPv6 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: Session.Unavailable - When the destination IPv6 address was not yet
                 configured

        :raises: Protocol.Session.CreationFailed - When the destination IPv6 address
                 cannot be reached

        """
        return _byteblower.ICMPv6EchoSession_EchoLoopStart(self)

    def EchoLoopStop(self):
        r"""

        Stops sending Echo Requests in a loop.

        This method stops sending Echo Requests in a loop. The loop can be started with
        :meth:`EchoLoopStart`

        .. note:: This method does not throw an exception if the loop was not started

        """
        return _byteblower.ICMPv6EchoSession_EchoLoopStop(self)

    def HopLimitSet(self, arg2):
        r"""

        Setting the ICMPv6 Echo Request HopLimit.

        The Hop Limit field is decremented when the packet is forwarded by a router.

        :param hopLimit: The ICMPv6 Echo Request ICMPv6 HopLimit for this Session.
                         The maximum legal value is 255.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.HopLimitSet(123)



        """
        return _byteblower.ICMPv6EchoSession_HopLimitSet(self, arg2)

    def HopLimitGet(self):
        r"""

        Getting the ICMPv6 Echo Request HopLimit.

        :return: The ICMPv6 Echo Request ICMPv6 HopLimit for this Session.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.HopLimitGet())



        """
        return _byteblower.ICMPv6EchoSession_HopLimitGet(self)

    def TrafficClassSet(self, inTrafficClass):
        r"""

        Configures the 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before
        the parent ByteBlower port is started. Invoking the method at other moments
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.TrafficClassSet(16)


        """
        return _byteblower.ICMPv6EchoSession_TrafficClassSet(self, inTrafficClass)

    def TrafficClassGet(self):
        r"""

        Retrieves the 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.

        The default value is 0.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.TrafficClassGet())



        """
        return _byteblower.ICMPv6EchoSession_TrafficClassGet(self)

    def SessionInfoGet(self):
        r"""

        Returns the session information.

        .. versionadded:: 2.3.0

        This method returns the :class:`ICMPv6SessionInfo` object.

        :return: :class:`.ICMPv6SessionInfo`

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.SessionInfoGet().DescriptionGet())



        """
        return _byteblower.ICMPv6EchoSession_SessionInfoGet(self)

    def GetICMPv6Protocol(self):
        return _byteblower.ICMPv6EchoSession_GetICMPv6Protocol(self)

# Register ICMPv6EchoSession in _byteblower:
_byteblower.ICMPv6EchoSession_swigregister(ICMPv6EchoSession)

class ICMPv6EchoSessionInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were transmitted for the session.

        :return: The number of ICMP Echo requests which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.TxEchoRequestsGet()



        """
        return _byteblower.ICMPv6EchoSessionInfo_TxEchoRequestsGet(self)

    def TxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were transmitted for the session.

        :return: The number of ICMP Echo replies which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.TxEchoRepliesGet())



        """
        return _byteblower.ICMPv6EchoSessionInfo_TxEchoRepliesGet(self)

    def RxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were received for the session.

        :return: The number of ICMP Echo requests which were received during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RxEchoRequestsGet())



        """
        return _byteblower.ICMPv6EchoSessionInfo_RxEchoRequestsGet(self)

    def RxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were received for the session.

        :return: The number of ICMP Echo replies which were received during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RxEchoRepliesGet())



        """
        return _byteblower.ICMPv6EchoSessionInfo_RxEchoRepliesGet(self)

    def RefreshTimestampGet(self):
        r"""

        Gets the timestamp on the server of when the session info was refreshed.

        :return: Returns the timestamp of the refresh

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RefreshTimestampGet())


        """
        return _byteblower.ICMPv6EchoSessionInfo_RefreshTimestampGet(self)

# Register ICMPv6EchoSessionInfo in _byteblower:
_byteblower.ICMPv6EchoSessionInfo_swigregister(ICMPv6EchoSessionInfo)

class ICMPv6Protocol(AbstractObject):
    r"""

    ICMPv6 Protocol.

    Every :class:`IPv6Configuration` has a ICMPv6Protocol attached. With this class
    you can create a :class:`.ICMPv6EchoSession` to send Echo Requests


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.ICMPv6Protocol_PortGet(self)

    def SessionAdd(self, *args):
        r"""

        Creates an ICMPv6 Echo Session, through which this host can query the Layer3
        IP network.

        See :class:`.ICMPv6EchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMPv6 session
        (e.g. `ping6`), that session will not be listed in :meth:`SessionGet`. If you
        want such sessions to be listed there, you will need to call :meth:`SessionAdd`
        given the `applicationId` that is used by the
        external tool.

        :param applicationId: Provide an ICMPv6 application id for this session. This
                              should be unique across the host. If none is given, a
                              random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPv6EchoSession` - The created echo session.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        Creates an ICMPv6 Echo Session, through which this host can query the Layer3
        IP network.

        See :class:`.ICMPv6EchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMPv6 session
        (e.g. `ping6`), that session will not be listed in :meth:`SessionGet`. If you
        want such sessions to be listed there, you will need to call :meth:`SessionAdd`
        given the `applicationId` that is used by the
        external tool.

        :param applicationId: Provide an ICMPv6 application id for this session. This
                              should be unique across the host. If none is given, a
                              random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPv6EchoSession` - The created echo session.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        """
        return _byteblower.ICMPv6Protocol_SessionAdd(self, *args)

    def SessionGet(self):
        r"""

        Returns the active list of ICMPv6 Echo Sessions.

        .. note:: The ICMPv6 Protocol may have more active sessions at *server-side*
                  than listed here. This list only returns the
                  :class:`.ICMPv6EchoSession` objects for which a handle has been
                  created at client-side. See below for more information.

        When an external tool connects to the :class:`.ByteBlowerPort` with an ICMPv6
        session (e.g. `ping6`), that session will not be listed here. If you want such
        sessions to be listed here, you will need to call :meth:`SessionAdd` given the
        `applicationId` that is used by the external tool.

        :return: :class:`.ICMPv6EchoSessionList` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

           list = icmpProtocol.SessionGet()


        """
        return _byteblower.ICMPv6Protocol_SessionGet(self)

    def SessionDestroy(self, inSession):
        return _byteblower.ICMPv6Protocol_SessionDestroy(self, inSession)

# Register ICMPv6Protocol in _byteblower:
_byteblower.ICMPv6Protocol_swigregister(ICMPv6Protocol)

class IGMPProtocol(AbstractObject):
    r"""

    The Internet Group Management Protocol (IGMP) Protocol for IPv4 manages
    multicast group membership for a given IPv4 host.

    This class support three IGMP Protocol versions:

    IGMPv1
        :rfc:1112

    IGMPv2
        :rfc:2236. IGMPv2 allows group membership termination to be quickly
        reported to the routing protocol, which is important for high-bandwidth
        multicast groups and/or subnets with highly volatile group membership.

    IGMPv3
        :rfc:3376. Version 3 of IGMP adds support for "source filtering", that
        is, the ability for a system to report interest in receiving packets
        **only** from specific source addresses, or from **all but** specific
        source addresses, sent to a particular multicast address. That information
        may be used by multicast routing protocols to avoid delivering multicast
        packets from specific sources to networks where there are no interested
        receivers.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolInfoGet(self):
        r"""

        Returns the ProtocolInfo object that contains various stats on the IGMPProtocol

        :return: :class:`.IGMPProtocolInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 1
                protocolInfo = icmpProtocol.ProtocolInfoGet()


        """
        return _byteblower.IGMPProtocol_ProtocolInfoGet(self)

    def ProtocolInfoDestroy(self, inIGMPProtocolInfo):
        return _byteblower.IGMPProtocol_ProtocolInfoDestroy(self, inIGMPProtocolInfo)

    def SessionV1Add(self, inGroupAddress):
        r"""

        Adding a IGMPv1 Session.

        :return: :class:`IGMPv1MemberSession`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionv1 = icmpProtocol.SessionV1Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV1Add(self, inGroupAddress)

    def SessionV2Add(self, inGroupAddress):
        r"""

        Adding a IGMPv2 Session.

        :return: :class:`IGMPv2MemberSession`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionv2 = icmpProtocol.SessionV2Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV2Add(self, inGroupAddress)

    def SessionV3Add(self, inGroupAddress):
        r"""

        Adding a IVMPv3 Session.

        :return: :class:`IGMPv3MemberSession`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionv3 = icmpProtocol.SessionV3Add('235.0.0.1')



        """
        return _byteblower.IGMPProtocol_SessionV3Add(self, inGroupAddress)

    def SessionDestroy(self, *args):
        return _byteblower.IGMPProtocol_SessionDestroy(self, *args)

# Register IGMPProtocol in _byteblower:
_byteblower.IGMPProtocol_swigregister(IGMPProtocol)

class IGMPProtocolInfo(AbstractRefreshableResult):
    r"""

    Class: IGMPProtocolInfo


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        return _byteblower.IGMPProtocolInfo_RxGet(self)

    def RxQueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxQueriesGet(self)

    def RxReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxReportsGet(self)

    def RxVersion1QueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion1QueriesGet(self)

    def RxVersion1ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion1ReportsGet(self)

    def RxVersion2QueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion2QueriesGet(self)

    def RxVersion2ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion2ReportsGet(self)

    def RxVersion2LeavesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion2LeavesGet(self)

    def RxVersion3QueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion3QueriesGet(self)

    def RxVersion3ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion3ReportsGet(self)

    def TxGet(self):
        return _byteblower.IGMPProtocolInfo_TxGet(self)

    def TxReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxReportsGet(self)

    def TxVersion1ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion1ReportsGet(self)

    def TxVersion2ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion2ReportsGet(self)

    def TxVersion2LeavesGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion2LeavesGet(self)

    def TxVersion3ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion3ReportsGet(self)

    def RefreshTimestampGet(self):
        r"""




        """
        return _byteblower.IGMPProtocolInfo_RefreshTimestampGet(self)

# Register IGMPProtocolInfo in _byteblower:
_byteblower.IGMPProtocolInfo_swigregister(IGMPProtocolInfo)

class IGMPMemberSession(SchedulableObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def MulticastAddressGet(self):
        return _byteblower.IGMPMemberSession_MulticastAddressGet(self)

    def VersionGet(self):
        return _byteblower.IGMPMemberSession_VersionGet(self)

    def SessionInfoGet(self):
        return _byteblower.IGMPMemberSession_SessionInfoGet(self)

    def SessionInfoDestroy(self, inMemberSessionInfo):
        return _byteblower.IGMPMemberSession_SessionInfoDestroy(self, inMemberSessionInfo)

# Register IGMPMemberSession in _byteblower:
_byteblower.IGMPMemberSession_swigregister(IGMPMemberSession)

class IGMPv1MemberSession(IGMPMemberSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Join(self):
        r"""


        """
        return _byteblower.IGMPv1MemberSession_Join(self)

    def Leave(self):
        r"""


        """
        return _byteblower.IGMPv1MemberSession_Leave(self)

# Register IGMPv1MemberSession in _byteblower:
_byteblower.IGMPv1MemberSession_swigregister(IGMPv1MemberSession)

class IGMPv2MemberSession(IGMPMemberSession):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Join(self):
        r"""


        """
        return _byteblower.IGMPv2MemberSession_Join(self)

    def Leave(self):
        r"""


        """
        return _byteblower.IGMPv2MemberSession_Leave(self)

# Register IGMPv2MemberSession in _byteblower:
_byteblower.IGMPv2MemberSession_swigregister(IGMPv2MemberSession)

class IGMPv3MemberSession(IGMPMemberSession):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MulticastListen(self, inSourceFilter, inSourceList):
        r"""


        """
        return _byteblower.IGMPv3MemberSession_MulticastListen(self, inSourceFilter, inSourceList)

    def SourceFilterModeGet(self):
        r"""


        """
        return _byteblower.IGMPv3MemberSession_SourceFilterModeGet(self)

    def SourceListGet(self):
        r"""


        """
        return _byteblower.IGMPv3MemberSession_SourceListGet(self)

# Register IGMPv3MemberSession in _byteblower:
_byteblower.IGMPv3MemberSession_swigregister(IGMPv3MemberSession)

class IGMPMemberSessionInfo(AbstractRefreshableResult):
    r"""

    InfoObject of the IGMPSession. Contains various stats of the IGMPSession

    Example

    .. code-block:: python
       :emphasize-lines: 1

    	sessionv1 = igmpProtocol.SessionV1Add()
    	igmpMemberSessionInfo = sessionv1.SessionInfoGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        r"""

        Returns the number of IGMP messages received by this session.

        :return: number of IGMP messages received by this session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RxGet(self)

    def RxQueriesGet(self):
        r"""

        Returns the number of received IGMP queries by this session.

        :return: Number of IGMP v1 queries received

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxQueriesGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RxQueriesGet(self)

    def RxVersion1ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v1 reports received

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxVersion1ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RxVersion1ReportsGet(self)

    def RxVersion2ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v2 reports received

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxVersion2ReportsGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RxVersion2ReportsGet(self)

    def TxGet(self):
        r"""

        Returns the number of IGMP messages transmitted by this session.

        :return: Number of IGMP messages transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxGet(self)

    def TxVersion1ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V1 reports by this session.

        :return: Number of IGMP v1 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion1ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion1ReportsGet(self)

    def TxVersion2ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v2 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion2ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion2ReportsGet(self)

    def TxVersion2LeavesGet(self):
        r"""

        Returns the number of transmitted IGMP V2 leaves by this session.

        :return: Number of IGMP v2 leaves transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion2LeavesGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion2LeavesGet(self)

    def TxVersion3ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V3 reports by this session.

        :return: Number of IGMP v3 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion3ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion3ReportsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :return: RefreshTimestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RefreshTimestampGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RefreshTimestampGet(self)

# Register IGMPMemberSessionInfo in _byteblower:
_byteblower.IGMPMemberSessionInfo_swigregister(IGMPMemberSessionInfo)

class MLDMulticastListenerSessionInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        r"""

        Returns the number of received MLD messages by this session.

        :return: Number of MLD messages received

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxGet(self)

    def RxListenerQueriesGet(self):
        r"""

        Returns the number of received MLD queries by this session.

        :return: Number of MLD v1 queries received

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxListenerQueriesGet(self)

    def RxVersion1ListenerReportsGet(self):
        r"""

        Returns the number of received MLD v1 Listener reports by this session.

        :return:  Number of MLD v1 Listener reports received

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxVersion1ListenerReportsGet(self)

    def TxGet(self):
        r"""

        Returns the number of transmitted MLD messages by this session.

        :return: Number of MLD messages Transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxGet(self)

    def TxVersion1ListenerReportsGet(self):
        r"""

        Returns the number of transmitted MLD V1 reports by this session.

        :return: Number of transmitted MLD v1 reports

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion1ListenerReportsGet(self)

    def TxVersion1ListenerDonesGet(self):
        r"""

        Returns the number of received MLD V1 Listeners done by this session.

        :return:  Number of transmitted MLD v1 Listener dones

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion1ListenerDonesGet(self)

    def TxVersion2ListenerReportsGet(self):
        r"""

        Returns the number of received MLD queries by this session.

        :return: Number of transmitted MLD v2 Listener reports

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion2ListenerReportsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Retuns the timestamp when the info was last refreshed.

        :return: RefreshTimestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RefreshTimestampGet(self)

# Register MLDMulticastListenerSessionInfo in _byteblower:
_byteblower.MLDMulticastListenerSessionInfo_swigregister(MLDMulticastListenerSessionInfo)

class MLDMulticastListenerSession(SchedulableObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def MulticastAddressGet(self):
        return _byteblower.MLDMulticastListenerSession_MulticastAddressGet(self)

    def VersionGet(self):
        return _byteblower.MLDMulticastListenerSession_VersionGet(self)

    def SessionInfoGet(self):
        return _byteblower.MLDMulticastListenerSession_SessionInfoGet(self)

    def SessionInfoDestroy(self, inMulticastListenerSessionInfo):
        return _byteblower.MLDMulticastListenerSession_SessionInfoDestroy(self, inMulticastListenerSessionInfo)

# Register MLDMulticastListenerSession in _byteblower:
_byteblower.MLDMulticastListenerSession_swigregister(MLDMulticastListenerSession)

class MLDProtocol(AbstractObject):
    r"""

    The Multicast Listener Discovery Protocol (MLD) Protocol for IPv6 manages
    multicast address listening for a given IPv6 host.

    This class support two MLD Protocol versions:

    MLDv1
        :rfc:2710

    MLDv2
        :rfc:3810. Version 2 of MLD adds support for 'source filtering', that is,
        the ability for a system to report interest in receiving packets *only*
        from specific source addresses, or from *all but* specific source
        addresses, sent to a particular multicast address. That information may be
        used by multicast routing protocols to avoid delivering multicast packets
        from specific sources to networks where there are no interested receivers.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolInfoGet(self):
        r"""

        :return: :class:`.MLDProtocolInfo`

        """
        return _byteblower.MLDProtocol_ProtocolInfoGet(self)

    def ProtocolInfoDestroy(self, inMLDProtocolInfo):
        return _byteblower.MLDProtocol_ProtocolInfoDestroy(self, inMLDProtocolInfo)

    def SessionV1Add(self, inMulticastAddress):
        r"""

        Create a MLDv1 session.

        :return: :class:`.MLDv1MulticastListenerSession`

        Example


        """
        return _byteblower.MLDProtocol_SessionV1Add(self, inMulticastAddress)

    def SessionV2Add(self, inMulticastAddress):
        r"""

        Create a MLDv2 session.

        :return: :class:`MLDv2MulticastListenerSession`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDProtocol_SessionV2Add(self, inMulticastAddress)

    def SessionDestroy(self, *args):
        return _byteblower.MLDProtocol_SessionDestroy(self, *args)

# Register MLDProtocol in _byteblower:
_byteblower.MLDProtocol_swigregister(MLDProtocol)

class MLDProtocolInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        return _byteblower.MLDProtocolInfo_RxGet(self)

    def RxListenerQueriesGet(self):
        return _byteblower.MLDProtocolInfo_RxListenerQueriesGet(self)

    def RxListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_RxListenerReportsGet(self)

    def RxVersion1ListenerQueriesGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerQueriesGet(self)

    def RxVersion1ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerReportsGet(self)

    def RxVersion1ListenerDonesGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerDonesGet(self)

    def RxVersion2ListenerQueriesGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion2ListenerQueriesGet(self)

    def RxVersion2ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion2ListenerReportsGet(self)

    def TxGet(self):
        return _byteblower.MLDProtocolInfo_TxGet(self)

    def TxListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxListenerReportsGet(self)

    def TxVersion1ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxVersion1ListenerReportsGet(self)

    def TxVersion1ListenerDonesGet(self):
        return _byteblower.MLDProtocolInfo_TxVersion1ListenerDonesGet(self)

    def TxVersion2ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxVersion2ListenerReportsGet(self)

    def RefreshTimestampGet(self):
        r"""



        """
        return _byteblower.MLDProtocolInfo_RefreshTimestampGet(self)

# Register MLDProtocolInfo in _byteblower:
_byteblower.MLDProtocolInfo_swigregister(MLDProtocolInfo)

class MLDv1MulticastListenerSession(MLDMulticastListenerSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ListeningStart(self):
        r"""



        """
        return _byteblower.MLDv1MulticastListenerSession_ListeningStart(self)

    def ListeningStop(self):
        r"""



        """
        return _byteblower.MLDv1MulticastListenerSession_ListeningStop(self)

# Register MLDv1MulticastListenerSession in _byteblower:
_byteblower.MLDv1MulticastListenerSession_swigregister(MLDv1MulticastListenerSession)

class MLDv1StartListening(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _byteblower.MLDv1StartListening_swiginit(self, _byteblower.new_MLDv1StartListening(arg2))
    __swig_destroy__ = _byteblower.delete_MLDv1StartListening

# Register MLDv1StartListening in _byteblower:
_byteblower.MLDv1StartListening_swigregister(MLDv1StartListening)

class MLDv1StopListening(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _byteblower.MLDv1StopListening_swiginit(self, _byteblower.new_MLDv1StopListening(arg2))
    __swig_destroy__ = _byteblower.delete_MLDv1StopListening

# Register MLDv1StopListening in _byteblower:
_byteblower.MLDv1StopListening_swigregister(MLDv1StopListening)

class MLDv2MulticastListenerSession(MLDMulticastListenerSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MulticastListen(self, inSourceFilter, inSourceList):
        r"""



        """
        return _byteblower.MLDv2MulticastListenerSession_MulticastListen(self, inSourceFilter, inSourceList)

    def SourceFilterModeGet(self):
        r"""



        """
        return _byteblower.MLDv2MulticastListenerSession_SourceFilterModeGet(self)

    def SourceListGet(self):
        r"""


        """
        return _byteblower.MLDv2MulticastListenerSession_SourceListGet(self)

# Register MLDv2MulticastListenerSession in _byteblower:
_byteblower.MLDv2MulticastListenerSession_swigregister(MLDv2MulticastListenerSession)

class MLDv2IPMulticastListen(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _byteblower.MLDv2IPMulticastListen_swiginit(self, _byteblower.new_MLDv2IPMulticastListen(arg2))

    def SourceFilterSet(self, filter):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_SourceFilterSet(self, filter)

    def SourceFilterGet(self):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_SourceFilterGet(self)

    def MulticastSourcesSet(self, sourceList):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_MulticastSourcesSet(self, sourceList)

    def MulticastSourcesGet(self):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_MulticastSourcesGet(self)
    __swig_destroy__ = _byteblower.delete_MLDv2IPMulticastListen

# Register MLDv2IPMulticastListen in _byteblower:
_byteblower.MLDv2IPMulticastListen_swigregister(MLDv2IPMulticastListen)

class TelnetClient(AbstractObject):
    r"""

    A Telnet client application that allows communication with an external Telnet
    server.

    The Telnet protocol allows for bidirectional interactive communication between
    a Telnet client (i.e. this application) on a ByteBlower port and an external
    Telnet server.

    The Telnet protocol can be used to log in on other machines using a virtual
    terminal. By sending Telnet commands using :meth:`Send`, waiting for a small
    amount of time and reading the response using :meth:`Receive`, a complete
    interactive session may be constructed.

    The protocol can also be used to debug other network protocols. For example,
    contacting an HTTP server (on port 80) using a Telnet client and sending a
    valid HTTP request towards it, should correctly return the HTTP response data.

    .. versionadded:: 2.2.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.TelnetClient_PortGet(self)

    def RemoteAddressSet(self, inAddress):
        r"""

        Sets the IP address of the Telnet server to which this client connects.

        Before this address is set, no connection can be opened or traffic can be sent.

        Both IPv4 and IPv6 addresses are supported, but the provided (remote) address
        must match be of the same type as the ByteBlower port of this client.

        .. note:: Currently, DNS is not supported, so providing a URL is not possible.

        :param address: The IP address of the Telnet server to which this client
                        connects. This should be either an valid IPv4 address or a
                        valid IPv6 address.
        :type address: str

        :raises: :exc:`.ConfigError` If an invalid IP address is entered, this error is
                 thrown.

        :raises: ByteBlower.Protocol.InvalidValue - If an IPv4 address is provided,
                 while this client is on an IPv6 ByteBlower port or vice versa, this
                 exception is thrown.

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use ::Close to close the session
                 before changing the Telnet server address.

        Example

        This snippet sets the IP address of the Telnet server to be contacted.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemoteAddressSet(self, inAddress)

    def RemoteAddressGet(self):
        r"""

        Returns the IP address of the Telnet server to which this client connects.

        Before this address is set, no connection can be opened or traffic can be sent.

        Both IPv4 and IPv6 addresses are supported, but the provided (remote) address
        must match use the same IP protocol as the ByteBlower port of this client.

        ..note:: Currently, DNS is not supported, so providing a URL is not possible.

        :return: The IP address of the Telnet server to which this client connects.
                 This should be either an valid IPv4 address or a valid IPv6 address.

        :raises: ByteBlower.Protocol.InvalidValue - If the remote IP address is not
                 configured yet

        Example

        This example returns the IP address of the Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemoteAddressGet(self)

    def RemotePortSet(self, inRemotePort):
        r"""

        Configures (remote) TCP port on the Telnet server to which this client
        connects.

        The client will communicate with the Telnet server on the configured port.

        If the TCP port isn't explicitly set (yet), the server will take the default
        Telnet server port (23).

        Default value 23

        :param port: The TCP port on the Telnet server to which this client connects.
                     This should be an integer value. Values larger the maximum port
                     value of 65536 overflow into a valid port number.

        :raises: InvalidValue.Integer - If the parameter value isn't an integer

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use :meth:`Close` to close the
                 session before changing the Telnet server     port.

        Example

        This snippet sets the port number of the Telnet server to be contacted.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemotePortSet(self, inRemotePort)

    def RemotePortGet(self):
        r"""

        Returns the (remote) TCP port on the Telnet server to which this client
        connects

        The client will communicate with the Telnet server on the configured port.

        If the TCP port isn't explicitly set (yet), this will return the default Telnet
        server port (23).

        Default value 23

        :return: The currently configured TCP port on the Telnet server to which this
                 client connects. This is an integer value.

        Example

        This example returns the port number of the Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemotePortGet(self)

    def LocalPortSet(self, inLocalPort):
        r"""

        Configures the (local) TCP port used by this client.

        The client will communicate with the server through a TCP network socket on
        this port and listen on it for incoming traffic.

        If the TCP port isn't explicitly set (yet), the server will use a valid and
        unique TCP port number for within the scope of the ByteBlower port
        (e.g. 32687).

        Default value Valid and unique client TCP port

        :param port: The TCP port to be used by this client. This should be an integer
                     value. Values larger the maximum port value of 65536 overflow into
                     a valid port number.

        :raises: InvalidValue.Integer - If the parameter value isn't an integer

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use ::Close to close the session
                 before changing the Telnet server port.

        Example

        This snippet sets the port number on which this client will connect to the
        Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_LocalPortSet(self, inLocalPort)

    def LocalPortGet(self):
        r"""

        Returns the (local) TCP port used by this client.

        The client will communicate with the server through a TCP network socket on
        this port and listen on it for incoming traffic.

        If the TCP port isn't explicitly set (yet), this will return a valid and unique
        TCP port number for within the scope of the ByteBlower port (e.g. 32687).

        Default value Valid unique client TCP port

        :return: int: The currently configured TCP port on this client.

        Example

        This example returns the port number on which this client connects to the
        Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_LocalPortGet(self)

    def Open(self):
        r"""

        Starts the Telnet client and opens the session with the Telnet server.

        It will create a new TCP connection. The TCP statistics will be reset. If a
        Telnet session is already open, nothing is done.

        After calling this method, data may be sent to the server :meth:`Send` will be
        queued for transmission after this handshake.

        Bug

        When contacting a non-existing or unreachable Telnet server, this application
        has unexpected behavior. The :meth:`Open` method returns immediately and TCP
        moves to the 'active' status. After the timeout expires, TCP moves to the
        'finished' status instead of the 'timeOut' status. All the while, data may be
        sent using :meth:`Send`. This data is queued during the handshake, but it will
        not be sent.

        :raises: ByteBlower.Protocol.Unavailable - If the Telnet server address has not
                 been configured, this exception is thrown. Use :meth:`RemoteAddressSet`
                 to configure the Telnet server address.

        Example

        This command opens the Telnet session, which initiates the handshake of the
        underlying TCP session. It returns immediately.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Open(self)

    def Send(self, inData):
        r"""

        Sends the provided to the Telnet server over the network..

        Data may be sent as soon as a connection is opened. Data sent during the TCP
        handshake will be queued to be sent immediately after it.

        Bug

        When contacting a non-existing or unreachable Telnet server, this method will
        not provide an error. When the TCP handshake fails (probably due to timeout),
        TCP will move (incorrectly) to finished after a while. None of the traffic sent
        at layer 5 will be received by the Telnet server.

        :param data: This string will be sent to the server for processing.

        :raises: ByteBlower.Protocol.InvalidAction - When no session is active, this
                 exception is thrown. Use :meth:`Open` to open the session.

        Example

        This command sends the provided data over the network towards the Telnet
        server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Send(self, inData)

    def Receive(self):
        r"""

        Reads data received over the Telnet session from the network and returns it.

        If this method is executed, all received data since the last time it was
        called is returned. If more data is still flowing in from the network, the rest
        of the data will be returned the next time the receive method is executed.

        Bug

        When contacting a non-existing or unreachable Telnet server, this method will
        not provide an error. When the TCP handshake fails (probably due to timeout),
        TCP will move (incorrectly) to finished after a while. None of the traffic sent
        at layer 5 will be received by the Telnet server.

        :return: The data received from the Telnet server.

        :raises: ByteBlower.Protocol.InvalidAction - When no session is active.
                 Use :meth:`Open` to open the session.

        Example

        This example shows the response received from the Telnet server after sending
        the 'uname -a' command.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Receive(self)

    def Close(self):
        r"""

        Closes the Telnet session with the server and stops the Telnet client.

        The TCP session will be closed and reset, so a new session can be opened.

        If no Telnet session is open, nothing is done.

        Example

        This command closes the Telnet session if one is active.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Close(self)

    def ConnectionStateGet(self):
        r"""

        Returns the current TCP connection state.

        :return: :class:`TCP ConnectionState`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_ConnectionStateGet(self)

# Register TelnetClient in _byteblower:
_byteblower.TelnetClient_swigregister(TelnetClient)

class PhysicalInterface(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetByteBlowerServer(self):
        return _byteblower.PhysicalInterface_GetByteBlowerServer(self)

    def IdGet(self):
        return _byteblower.PhysicalInterface_IdGet(self)

    def NameGet(self):
        return _byteblower.PhysicalInterface_NameGet(self)

    def TypeGet(self):
        return _byteblower.PhysicalInterface_TypeGet(self)

    def MacAddressGet(self):
        return _byteblower.PhysicalInterface_MacAddressGet(self)

    def ByteBlowerInterfaceGet(self):
        return _byteblower.PhysicalInterface_ByteBlowerInterfaceGet(self)

    def ByteBlowerInterfaceCountGet(self):
        return _byteblower.PhysicalInterface_ByteBlowerInterfaceCountGet(self)

    def LinkStatusGet(self):
        return _byteblower.PhysicalInterface_LinkStatusGet(self)

    def LinkTypeGet(self):
        return _byteblower.PhysicalInterface_LinkTypeGet(self)

    def VendorNameGet(self):
        return _byteblower.PhysicalInterface_VendorNameGet(self)

    def ProductNameGet(self):
        return _byteblower.PhysicalInterface_ProductNameGet(self)

# Register PhysicalInterface in _byteblower:
_byteblower.PhysicalInterface_swigregister(PhysicalInterface)

class Layer2Configuration(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.Layer2Configuration_PortGet(self)

    def AddressSet(self, inLayer2Address):
        return _byteblower.Layer2Configuration_AddressSet(self, inLayer2Address)

    def AddressGet(self):
        return _byteblower.Layer2Configuration_AddressGet(self)

# Register Layer2Configuration in _byteblower:
_byteblower.Layer2Configuration_swigregister(Layer2Configuration)

EthernetEncoding_SNAP = _byteblower.EthernetEncoding_SNAP
EthernetEncoding_DIX = _byteblower.EthernetEncoding_DIX

def ConvertEthernetEncodingToString(inEthernetEncoding):
    return _byteblower.ConvertEthernetEncodingToString(inEthernetEncoding)

def ParseEthernetEncoding(inEthernetEncoding):
    return _byteblower.ParseEthernetEncoding(inEthernetEncoding)
class EthernetConfiguration(Layer2Configuration):
    r"""

    EthernetII provides an interface for the Ethernet configuration on a
    ByteBlower port.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddressSet(self, inMacAddress):
        return _byteblower.EthernetConfiguration_AddressSet(self, inMacAddress)

    def AddressGet(self):
        return _byteblower.EthernetConfiguration_AddressGet(self)

    def TypeGet(self):
        r"""

        Returns the layer 2 encoding scheme.

        :return: The layer 2 encoding scheme.

        Example

        This example returns the layer 2 encoding scheme.

        .. code-block:: python
           :emphasize-lines: 1

        	print(ethernetConf.TypeGet())

        """
        return _byteblower.EthernetConfiguration_TypeGet(self)

    def TypeSet(self, inEthernetEncoding):
        r"""

        Sets the layer 2 encoding scheme.

        :param encoding: Currently supported encodings are SNAP and DIX.

        Example

        This example sets the layer 2 encoding scheme.

        .. code-block:: python
           :emphasize-lines: 1

        	print(ethernetConf.TypeSet())


        """
        return _byteblower.EthernetConfiguration_TypeSet(self, inEthernetEncoding)

    def MacSet(self, inMacAddress):
        return _byteblower.EthernetConfiguration_MacSet(self, inMacAddress)

    def MacGet(self):
        return _byteblower.EthernetConfiguration_MacGet(self)

    @staticmethod
    def IsValidMacAddress(inMacAddress):
        return _byteblower.EthernetConfiguration_IsValidMacAddress(inMacAddress)

# Register EthernetConfiguration in _byteblower:
_byteblower.EthernetConfiguration_swigregister(EthernetConfiguration)

def EthernetConfiguration_IsValidMacAddress(inMacAddress):
    return _byteblower.EthernetConfiguration_IsValidMacAddress(inMacAddress)

class VLANTag(Layer25Configuration):
    r"""

    Configure the VLAN tag on a ByteBlower Port.

    IEEE 802.1Q is the networking standard that supports Virtual LANs (VLANs) on an
    Ethernet network. The standard defines a system of VLAN tagging for Ethernet
    frames and the accompanying procedures to be used by bridges and switches in
    handling such frames

    802.1Q does not actually encapsulate the original frame. Instead, for Ethernet
    frames, it adds a 32-bit field between the source MAC address and the
    EtherType/Length fields of the original frame

    TPID
        Tag Protocol Identifier - 16bits

    TCI
        Tag Control Information - 16bits

    In the latter case the TCI consists of:

    PCP
        Priority Code Point - 3bits

    DEI
        Drop Eligible Indicator - 1bit

    VID
        VLAN Identifier - 12bits

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolIDGet(self):
        r"""

        Get the VLAN Protocol ID (TPID)

        A 16-bit field specifying the VLAN Protocol ID used in the frames.

        IEEE 802.1AD specifies the VLAN C-TAG (customer tag) and S-TAG (service-provider
        tag). The C-TAG (0x8100) is used on the innermost VLAN tag, while the S-TAG
        (0x88a8) is used on all other VLAN tags.

        I.e. When a single VLAN is used on the *ByteBlowerPort*, the TPID will be
        0x8100. When VLAN stacking is used, the innermost VLAN tag (closest to the
        Ethernet payload) will use the C-TAG (0x8100) while all other VLAN tags use the
        S-TAG (0x88a8).

        :return: Returns the used Protocol ID (`TPID`) for this VLAN tag.

        Example

        Getting the vlan TPID of a ByteBlower port tagged with a single VLAN
        (0x8100 == 33024)


        .. code-block:: python
           :emphasize-lines: 1

        	print(vlanTag.ProtocolIDGet())


        """
        return _byteblower.VLANTag_ProtocolIDGet(self)

    def IDSet(self, inId):
        r"""

        Configure the VLAN ID.

        A 12-bit field specifying the VLAN to which the frame belongs. The hexadecimal
        values of 0x000 and 0xFFF are reserved. All other values may be used as VLAN
        identifiers, allowing up to 4094 VLANs

        :param id: Your VLAN ID

        Example
        Creating a VLAN tag on the your ByteBlower port

        .. code-block:: python
           :emphasize-lines: 1

        	vlanTag.IDSet(2)

        """
        return _byteblower.VLANTag_IDSet(self, inId)

    def IDGet(self):
        r"""

        Get the VLANID.

        A 12-bit field specifying the VLAN to which the frame belongs. The hexadecimal
        values of 0x000 and 0xFFF are reserved. All other values may be used as VLAN
        identifiers, allowing up to 40094 VLANs.

        Default value: 0

        :return: the configured VLAN ID installed on this ByteBlower port.

        Example

        Getting the vlanID of a ByteBlower port tagged with VLAN Id 107

        .. code-block:: python
           :emphasize-lines: 3

        	print(vlanTag.IDGet())
        	#returns 107

        """
        return _byteblower.VLANTag_IDGet(self)

    def PrioritySet(self, inPriority):
        r"""

        Set the VLAN Priority.

        A 3-bit field which refers to the IEEE 802.1p priority. It indicates the frame
        priority level. Values are from 0 (best effort) to 7 (highest); 1 represents
        the lowest priority. These values can be used to prioritize different classes
        of traffic (voice, video, data, etc.).

        :param priority: The priority you want to configure: a number between 0 and 7.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	vlanTag.PrioritySet(0)


        """
        return _byteblower.VLANTag_PrioritySet(self, inPriority)

    def PriorityGet(self):
        r"""

        Get the VLAN Priority.

        A 3-bit field which refers to the IEEE 802.1p priority. It indicates the frame
        priority level. Values are from 0 (best effort) to 7 (highest); 1 represents
        the lowest priority. These values can be used to prioritize different classes of
        traffic (voice, video, data, etc.).

        Default value: 0

        :return:  Returns the configured priority of the VLAN protocol

        Example

        Getting the vlanID of a ByteBlower port tagged with VLAN Id 107

        .. code-block:: python
           :emphasize-lines: 3

        	print(vlanTag.PriorityGet())

        """
        return _byteblower.VLANTag_PriorityGet(self)

    def DropEligibleSet(self, value):
        r"""

        Enable/Disable the Drop Eligible Indicator.

        A 1-bit field. (formerly CFI) May be used separately or in conjunction with
        PCP to indicate frames eligible to be dropped in the presence of congestion.

        :param enable: bool -
                       True will enable the Drop Eligible Indicator
                       False will disable the Drop Eligible Indicator.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	vlanTag.DropEligibleSet(True)

        """
        return _byteblower.VLANTag_DropEligibleSet(self, value)

    def DropEligibleGet(self):
        r"""

        Returns the status of the Drop Eligible Indicator.

        A 1-bit field. (formerly CFI) May be used separately or in conjunction with PCP
        to indicate frames eligible to be dropped in the presence of congestion.

        Default value: Disabled

        :return: True if Drop Eligible Indicator is enabled, False if disabled.

        """
        return _byteblower.VLANTag_DropEligibleGet(self)

# Register VLANTag in _byteblower:
_byteblower.VLANTag_swigregister(VLANTag)

class PPPAuthProtocol(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_PPPAuthProtocol

# Register PPPAuthProtocol in _byteblower:
_byteblower.PPPAuthProtocol_swigregister(PPPAuthProtocol)

class PAPProtocol(PPPAuthProtocol):
    r"""

    Represents the Password Authentication Protocol  

    PPP defines an extensible Link Control Protocol, which allows negotiation of an
    Authentication Protocol for authenticating its peer before allowing Network 
    Layer protocols to transmit over the link.  

    This class provides the Password Authentication protocol as described per 
    :rfc:`1334`, section 2  

    The Password Authentication Protocol (PAP) provides a simple method for the
    peer to establish its identity using a 2-way handshake. This is done only upon
    initial link establishment.  

    After the Link Establishment phase is complete, an Id/Password pair is 
    repeatedly sent by the peer to the authenticator until authentication is
    acknowledged or the connection is terminated.  

    PAP is not a strong authentication method. Passwords are sent over the circuit 
    " *in the clear* ", and there is no protection from playback or repeated 
    trial and error attacks. The peer is in control of the frequency and timing of
    the attempts.  

    By default, authentication is not mandatory. If authentication of the link is 
    desired, an implementation MUST specify the Authentication-Protocol 
    Configuration Option during Link Establishment phase.  

    .. versionadded:: 2.5.0  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPPPProtocol(self, *args):
        return _byteblower.PAPProtocol_GetPPPProtocol(self, *args)

    def PeerIDGet(self):
        r"""

        Returns the configured Peer-ID.  

        :return:  peerID  

        Example

        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PeerIDGet(self)

    def PeerIDSet(self, inUserId):
        r"""

        Configures the Peer-ID on the Password authentication Protocol ( PAP )  

        :param peerID: The new Peer-ID  

        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PeerIDSet(self, inUserId)

    def PasswordGet(self):
        r"""

        Returns the configured password.  

        :return: password  
        :rtype: str


        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PasswordGet(self)

    def PasswordSet(self, inPassword):
        r"""

        Configures the password on the Password authentication Protocol ( PAP )

        The password will be transmitted *plaintext* over the wire.  

        :param password: The password for the given Peer-ID  
        :type password: str


        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PasswordSet(self, inPassword)

# Register PAPProtocol in _byteblower:
_byteblower.PAPProtocol_swigregister(PAPProtocol)

class CHAPProtocol(PPPAuthProtocol):
    r"""

    Represents the Challenge-Handshake Authentication Protocol  

    PPP defines an extensible Link Control Protocol, which allows negotiation of 
    an Authentication Protocol for authenticating its peer before allowing Network
    Layer protocols to transmit over the link.  

    This class provides the Password Authentication protocol as described per 
    :rfc:1334, section 3  

    The Challenge-Handshake Authentication Protocol (CHAP) is used to periodically
    verify the identity of the peer using a 3-way handshake. This is done upon 
    initial link establishment, and MAY be repeated anytime after the link has been
    established.  

    After the Link Establishment phase is complete, the authenticator sends a 
    "challenge" message to the peer. The peer responds with a value calculated
    using a "one-way hash" function. The authenticator checks the response 
    against its own calculation of the expected hash value. If the values match, 
    the authentication is acknowledged, otherwise the connection SHOULD be 
    terminated.  

    CHAP provides protection against playback attack through the use of an 
    incrementally changing identifier and a variable challenge value. The use of 
    repeated challenges is intended to limit the time of exposure to any single 
    attack. The authenticator is in control of the frequency and timing of the 
    challenges.  

    This authentication method depends upon a "*secret*" known only to the 
    authenticator and that peer. The secret is not sent over the link. This method
    is most likely used where the same secret is easily accessed from both ends of 
    the link.  

    By default, authentication is not mandatory. If authentication of the link is 
    desired, an implementation MUST specify the Authentication-Protocol 
    Configuration Option during Link Establishment phase.  

    .. versionadded:: 2.5.0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPPPProtocol(self, *args):
        return _byteblower.CHAPProtocol_GetPPPProtocol(self, *args)

    def SecretSet(self, secret):
        r"""

        Configures the Secret on the Challenge Handshake Authentication Protocol (CHAP)

        :param secret: The secret for authenticating to the PPP server.  

        .. code-block:: python

           # TODO

        """
        return _byteblower.CHAPProtocol_SecretSet(self, secret)

    def SecretGet(self):
        r"""

        Returns the configured Secret.  

        :return: Secret value  

        .. code-block:: python

           # TODO

        """
        return _byteblower.CHAPProtocol_SecretGet(self)

# Register CHAPProtocol in _byteblower:
_byteblower.CHAPProtocol_swigregister(CHAPProtocol)

class PPPNetworkControlProtocol(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_PPPNetworkControlProtocol

# Register PPPNetworkControlProtocol in _byteblower:
_byteblower.PPPNetworkControlProtocol_swigregister(PPPNetworkControlProtocol)

class IPv4CPProtocol(PPPNetworkControlProtocol):
    r"""

    Internet Protocol Control Protocol.  

    Internet Protocol Control Protocol (IPCP) is a network control protocol for 
    establishing and configuring Internet Protocol over a Point-to-Point Protocol
    link. IPCP is responsible for configuring, enabling, and disabling the IP 
    protocol modules on both ends of the point-to-point link. IPCP uses the same
    packet exchange mechanism as the Link Control Protocol.

    The implementation is conform :rfc:1332  

    .. note:: The RFC deprecated the `IP-Addresses` configuration option. 
              ByteBlower does not provide the (optional) backward compatibility for
              this option.  
    .. note:: IP compression is not supported.  

    .. versionadded:: 2.5.0  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpAddressGet(self):
        r"""

        Returns local the IPv4 address.  

        This method returns the IP address to be used at the local end of the link. 
        Before the IPCP protocol negotiated the IP address, this method will return the
        value configured with :meth:`IpAddressSet`. After IP address negotiation with
        the remote peer, the method will return the IP address negotiated with the 
        remote peer.  

        The latter will be either:

        - the same as the value configured with :meth:`IpAddressSet`

          - if the remote peer accepted that address.

        - the address imposed by the remote peer:
          - if we requested that the peer provides the address

          - when the remote peer did not accept the requested IP address.

        :return: The IP address to be used by the local peer.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressGet(self)

    def IpAddressSet(self, inIPAddress):
        r"""

        Configures the IPv4 address to be used at the local end of the link.  

        During IP address negotiation, the given address will be proposed to the remote
        end of the link.  

        :param ipAddress: The IPv4 address to be used during negotiation at the local 
                          peer.  

        .. note:: The IPv4 address '0.0.0.0' has a special meaning: 
                  This will request the remote peer to provide an IP address. 
                  See also :meth:`IpAddressPeerProvided` for a convenience method.  

        :raises: BadIPv4Address - When an incorrect IPv4 address string was provided.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressSet(self, inIPAddress)

    def IpAddressRemoteGet(self):
        r"""

        Returns the IP address of the remote peer.  

        This method will return the IP address which has been requested by the remote
        peer during (the last) address negotiation.  

        :return: IP address of the remote peer of the last address negotiation. 
                 '0.0.0.0' if no negotiation took place yet.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressRemoteGet(self)

    def IpAddressPeerProvided(self):
        r"""

        Request the peer to provide an IP address.  

        During IP address negotiation, we will request to peer to provide an IP 
        address.

        ..note:: This method call will have the same effect as calling 
                 :meth:`IpAddressSet` with *<ipAddress>* set to '0.0.0.0'.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressPeerProvided(self)

    def Open(self):
        r"""

        Perform an administrative open on the IPCP protocol.  

        This event indicates that the link is administratively available for traffic.

        In the opened state, the protocol will come up when the PPP session is 
        established. When the PPP/IPCP session was already established, the IPCP will 
        start negotiation.  

        See also :rfc:1661, section 4.3 for detailed information about the Open event.  

        """
        return _byteblower.IPv4CPProtocol_Open(self)

    def Close(self):
        r"""

        Perform an administrative close on the IPCP protocol.  

        This event indicates that the link is not available for traffic.  

        In the closed state, the protocol will not come up when the PPP session is 
        established. When the PPP/IPCP session was already established, the IPCP 
        session will properly terminate the network layer.   

        See also :rfc:1661, section 4.3 for detailed information about the Close event.

        """
        return _byteblower.IPv4CPProtocol_Close(self)

# Register IPv4CPProtocol in _byteblower:
_byteblower.IPv4CPProtocol_swigregister(IPv4CPProtocol)

class IPv6CPProtocol(PPPNetworkControlProtocol):
    r"""

    IP version 6 over PPPoE.  

    IPv6 Control Protocol (IPv6CP) is a network control protocol for establishing 
    and configuring the IPv6 (see also Layer3.IPv6) over PPP . It forms IPv6 
    link-local addresses on PPP links. The IPv6 Control Protocol (IPV6CP) is 
    responsible for configuring, enabling, and disabling the IPv6 protocol modules
    on both ends of the point-to-point link. IPV6CP uses the same packet exchange
    mechanism as the Link Control Protocol (LCP).  

    The implementation is conform :rfc:2472  

    .. versionadded:: 2.5.0  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterfaceIdentifierGet(self):
        r"""

        Returns the local IPv6 interface identifier.  

        This method returns the IPv6 interface identifier to be used at the local end 
        of the link. The initial value is based on the local MAC address (from 
        :meth:`.EthernetConfiguration.MacGet`).  

        After IPv6 interface identifier negotiation with the remote peer, the method 
        will return the IPv6 interface identifier negotiated with the remote peer.  

        The latter will be either:

        - the initial value if the remote peer accepted that address.
        - the address imposed by the remote peer when the remote peer did not accept 
          the requested address.

        :return: The IPv6 interface identifier to be used by the local peer.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv6CPProtocol_InterfaceIdentifierGet(self)

    def InterfaceIdentifierRemoteGet(self):
        r"""

        Returns the IPv6 interface identifier of the remote peer.  

        This method will return the IPv6 interface identifier which has been requested 
        by the remote peer during (the last) address negotiation.  

        :return: IPv6 interface identifier of the remote peer of the last address 
                 negotiation.  '00:00:00:00:00:00:00:00' if no negotiation took place 
                 yet.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv6CPProtocol_InterfaceIdentifierRemoteGet(self)

    def Open(self):
        r"""

        Perform an administrative open on the IPv6CP protocol.  

        This event indicates that the link is administratively available for traffic.  

        In the opened state, the protocol will come up when the PPP session is 
        established. When the PPP/IPv6CP session was already established, the IPv6CP 
        will start negotiation.  

        See also :rfc:1661, section 4.3 for detailed information about the Open event.

        """
        return _byteblower.IPv6CPProtocol_Open(self)

    def Close(self):
        r"""

        Perform an administrative close on the IPv6CP protocol.  

        This event indicates that the link is not available for traffic.  

        In the closed state, the protocol will not come up when the PPP session is 
        established. When the PPP/IPv6CP session was already established, the IPv6CP 
        session will properly terminate the network layer.  

        See also :rfc:1661, section 4.3 for detailed information about the Close event.  

        """
        return _byteblower.IPv6CPProtocol_Close(self)

# Register IPv6CPProtocol in _byteblower:
_byteblower.IPv6CPProtocol_swigregister(IPv6CPProtocol)

class PPPProtocol(AbstractObject):
    r"""

    The Point-to-Point Protocol (PPP) provides a standard method for transporting 
    multi-protocol datagrams over point-to-point links. PPP is comprised of three
    main components:  

    1.  A method for encapsulating multi-protocol datagrams.  
    2.  A Link Control Protocol (LCP) for establishing, configuring, and testing the data-link connection.   
    3.  A family of Network Control Protocols (NCPs) for establishing and configuring different network-layer protocols.  

    The implementation is conform :rfc:`1661`.  

    .. versionadded:: 2.5.0  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self, *args):
        return _byteblower.PPPProtocol_PortGet(self, *args)

    def AuthProtocolPapAdd(self):
        r"""

        This method will add the Password Authentication Protocol.  

        :return: :class:`.PAPProtocol`

        """
        return _byteblower.PPPProtocol_AuthProtocolPapAdd(self)

    def AuthProtocolPapGet(self):
        r"""

        This method will return the current configured Password Authentication Protocols.  

        :return: :class:`PAPProtocolList`

        """
        return _byteblower.PPPProtocol_AuthProtocolPapGet(self)

    def AuthProtocolChapAdd(self):
        r"""

        This method will add the Challenge-handshake Authentication Protocol.

        :return: :class:`.CHAPProtocol`

        """
        return _byteblower.PPPProtocol_AuthProtocolChapAdd(self)

    def AuthProtocolChapGet(self):
        r"""

        This method will return the current configured Challenge-Handshake Authentication Protocols.

        :return: :class:`CHAPProtocolList`

        """
        return _byteblower.PPPProtocol_AuthProtocolChapGet(self)

    def NcpIpcpAdd(self):
        r"""

        This method will add support for an IPv6 Control Protocol.  

        IPCP is the Internet Protocol Control Protocol.  

        :return: The IPCP NCP object is returned. The object types is 
                 Layer2.Ppp.NetworkControl.Ipcp.  

        Example

        .. code-block:: python
           :caption: Adding IPCP as Network Control Protocol  

           # TODO


        """
        return _byteblower.PPPProtocol_NcpIpcpAdd(self)

    def NcpIpcpGet(self):
        r"""

        This method will return the current configured Internet Protocol Control Protocols (IPCP).  

        :return: :class:`.IPv4CPProtocol`

        Example

        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPProtocol_NcpIpcpGet(self)

    def NcpIpv6cpAdd(self):
        r"""

        This method will add support for an IPv4 Control Protocol.  

        IPv6CP is the Internet Protocol Control Protocol for IPv6.  

        :return: :class:`.IPv6CPProtocol`

        Example

        .. code-block:: python
           :caption: Adding IPv6CP as Network Control Protocol  

           # TODO

        """
        return _byteblower.PPPProtocol_NcpIpv6cpAdd(self)

    def NcpIpv6cpGet(self):
        r"""

        This method will return the current configured IPv6 Control Protocols (IPv6CP).  

        :return: :class:`.IPv6CPProtocol`

        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPProtocol_NcpIpv6cpGet(self)

# Register PPPProtocol in _byteblower:
_byteblower.PPPProtocol_swigregister(PPPProtocol)

PPPoEStatus_Initial = _byteblower.PPPoEStatus_Initial
PPPoEStatus_Discovering = _byteblower.PPPoEStatus_Discovering
PPPoEStatus_Requesting = _byteblower.PPPoEStatus_Requesting
PPPoEStatus_SessionActive = _byteblower.PPPoEStatus_SessionActive
PPPoEStatus_Terminated = _byteblower.PPPoEStatus_Terminated

def ConvertPPPoEStatusToString(inPPPoEStatus):
    return _byteblower.ConvertPPPoEStatusToString(inPPPoEStatus)
class PPPoEClient(Layer25Configuration):
    r"""

    A PPPoE client which allows you to setup Layer3 connectivity.  

    PPP over Ethernet (PPPoE) provides the ability to connect a network of hosts 
    over a simple bridging access device to a remote Access Concentrator.  

    The client implements the PPPoE protocol as per :rfc:`2516`.  

    The associated PPP Protocol has support for multiple authentication protocols.
    Layer3 connectivity includes IPv4 and IPv6 .  

    .. versionadded:: 2.5.0  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PppGet(self):
        r"""

        Returns the associated PPP Protocol object.  

        Returns the PPP ( Point-to-Point ) Protocol which is transmitted over Ethernet 
        ( PPPoE ). Through this object, you can configure the AuthProtocol. 

        :return: :class:`.PPPProtocol`

        Example

        .. code-block:: python

           # TODO


        """
        return _byteblower.PPPoEClient_PppGet(self)

    def ServiceNameSet(self, inServiceName):
        r"""

        This method will set the Requested Service Name for the PPPoE client.  

        :param serviceName: PPPoE Service Name which the client requests.
        :type serviceName: str

        Example

        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPoEClient_ServiceNameSet(self, inServiceName)

    def ServiceNameGet(self):
        r"""

        This method will return the Requested Service Name for the PPPoE client.  

        :return: PPPoE Service Name which the client requests.  
        :rtype: str


        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPoEClient_ServiceNameGet(self)

    def SessionIdGet(self):
        r"""

        This method will return the PPPoE SessionID of the last started PPPoE Session. 

        :return: False if No session started yet, else the PPPoE SessionID of the last 
                 started session.  

        """
        return _byteblower.PPPoEClient_SessionIdGet(self)

    def Start(self):
        r"""

        This will Start the PPPoE client.  

        This method will start the PPPoE session, setup PPP, authenticate using the
        configured authentication protocol and setup the currently configured network
        control protocols.  

        :raises: SessionUnavailable - When something unexpectedly happened during PPPoE
                 session initiation.  

        :raises: LinkEstablishmentTimeout - When PPP network layer was not configured
                 within reasonable timeout.  

        :return: PPPoE Session ID  


        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPoEClient_Start(self)

    def StartAsync(self):
        r"""

        Starts the PPPoE client.  

        This call will initiate the start of the PPPoE client but will not wait for the
        result.

        """
        return _byteblower.PPPoEClient_StartAsync(self)

    def Terminate(self):
        r"""

        This will Terminate the PPPoE client.  

        Termination will properly terminate all PPPoE and PPP related protocols, from 
        higher-layers to lower-layers, starting from the network control protocol 
        (i.e. IPCP  or IPv6CP ).  

        """
        return _byteblower.PPPoEClient_Terminate(self)

    def StatusGet(self):
        r"""

        Returns the current status of the PPPoE connection.  

        Possible states are: 

        Initial
            PPPoE not yet started  

        Discovering
            PPPoE discovery message sent  

        Requesting
            PPPoE request sent  

        SessionActive
            PPPoE session is active  

        Terminated
            PPPoE session has been terminated  

        :return: Current PPPoE Status  

        Example

        .. code-block:: python

           # TODO


        """
        return _byteblower.PPPoEClient_StatusGet(self)

    def ServerGet(self):
        return _byteblower.PPPoEClient_ServerGet(self)

# Register PPPoEClient in _byteblower:
_byteblower.PPPoEClient_swigregister(PPPoEClient)

class PAPProtocolList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.PAPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.PAPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.PAPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.PAPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.PAPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.PAPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.PAPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.PAPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.PAPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.PAPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.PAPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.PAPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.PAPProtocolList_empty(self)

    def size(self):
        return _byteblower.PAPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.PAPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.PAPProtocolList_begin(self)

    def end(self):
        return _byteblower.PAPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.PAPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.PAPProtocolList_rend(self)

    def clear(self):
        return _byteblower.PAPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.PAPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.PAPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.PAPProtocolList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.PAPProtocolList_swiginit(self, _byteblower.new_PAPProtocolList(*args))

    def push_back(self, x):
        return _byteblower.PAPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.PAPProtocolList_front(self)

    def back(self):
        return _byteblower.PAPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.PAPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.PAPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.PAPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.PAPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.PAPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_PAPProtocolList

# Register PAPProtocolList in _byteblower:
_byteblower.PAPProtocolList_swigregister(PAPProtocolList)

class CHAPProtocolList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CHAPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CHAPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CHAPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.CHAPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CHAPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CHAPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CHAPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CHAPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CHAPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CHAPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CHAPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.CHAPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.CHAPProtocolList_empty(self)

    def size(self):
        return _byteblower.CHAPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.CHAPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.CHAPProtocolList_begin(self)

    def end(self):
        return _byteblower.CHAPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.CHAPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.CHAPProtocolList_rend(self)

    def clear(self):
        return _byteblower.CHAPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.CHAPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CHAPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CHAPProtocolList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.CHAPProtocolList_swiginit(self, _byteblower.new_CHAPProtocolList(*args))

    def push_back(self, x):
        return _byteblower.CHAPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.CHAPProtocolList_front(self)

    def back(self):
        return _byteblower.CHAPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.CHAPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CHAPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CHAPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CHAPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.CHAPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CHAPProtocolList

# Register CHAPProtocolList in _byteblower:
_byteblower.CHAPProtocolList_swigregister(CHAPProtocolList)

class IPCPProtocolList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IPCPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IPCPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IPCPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.IPCPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IPCPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IPCPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IPCPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IPCPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IPCPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IPCPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.IPCPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.IPCPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.IPCPProtocolList_empty(self)

    def size(self):
        return _byteblower.IPCPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.IPCPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.IPCPProtocolList_begin(self)

    def end(self):
        return _byteblower.IPCPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.IPCPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.IPCPProtocolList_rend(self)

    def clear(self):
        return _byteblower.IPCPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.IPCPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.IPCPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.IPCPProtocolList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.IPCPProtocolList_swiginit(self, _byteblower.new_IPCPProtocolList(*args))

    def push_back(self, x):
        return _byteblower.IPCPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.IPCPProtocolList_front(self)

    def back(self):
        return _byteblower.IPCPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.IPCPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.IPCPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.IPCPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.IPCPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.IPCPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_IPCPProtocolList

# Register IPCPProtocolList in _byteblower:
_byteblower.IPCPProtocolList_swigregister(IPCPProtocolList)

class IPv6CPProtocolList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IPv6CPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IPv6CPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IPv6CPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.IPv6CPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IPv6CPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IPv6CPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IPv6CPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.IPv6CPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.IPv6CPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.IPv6CPProtocolList_empty(self)

    def size(self):
        return _byteblower.IPv6CPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.IPv6CPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.IPv6CPProtocolList_begin(self)

    def end(self):
        return _byteblower.IPv6CPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.IPv6CPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.IPv6CPProtocolList_rend(self)

    def clear(self):
        return _byteblower.IPv6CPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.IPv6CPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.IPv6CPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.IPv6CPProtocolList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.IPv6CPProtocolList_swiginit(self, _byteblower.new_IPv6CPProtocolList(*args))

    def push_back(self, x):
        return _byteblower.IPv6CPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.IPv6CPProtocolList_front(self)

    def back(self):
        return _byteblower.IPv6CPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.IPv6CPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.IPv6CPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.IPv6CPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.IPv6CPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.IPv6CPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_IPv6CPProtocolList

# Register IPv6CPProtocolList in _byteblower:
_byteblower.IPv6CPProtocolList_swigregister(IPv6CPProtocolList)

class Layer3Configuration(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.Layer3Configuration_PortGet(self)

    @staticmethod
    def IsValidLayer3Address(inAddress):
        return _byteblower.Layer3Configuration_IsValidLayer3Address(inAddress)

# Register Layer3Configuration in _byteblower:
_byteblower.Layer3Configuration_swigregister(Layer3Configuration)

def Layer3Configuration_IsValidLayer3Address(inAddress):
    return _byteblower.Layer3Configuration_IsValidLayer3Address(inAddress)

class IPv4Configuration(Layer3Configuration):
    r"""

    Provides an interface for the IPv4 configuration on a ByteBlower port.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.IPv4Configuration_ServerGet(self)

    def GetByteBlowerPort(self):
        return _byteblower.IPv4Configuration_GetByteBlowerPort(self)

    def IpSet(self, inIPv4Address):
        r"""

        Sets the IP address of the ByteBlower port.

        :param ipAddress: IP address string. You can use "slash notation"
                          (e.g. 10.1.1.2/24) to simulateously specify the address and
                          netmask.

        Example

        This example sets the IP address on a ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_IpSet(self, inIPv4Address)

    def IpGet(self):
        r"""

        Retrieves the Ip address of the ByteBlower port.

        :return: The IP address of the ByteBlower port.

        Example

        This example returns the IP address on a ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_IpGet(self)

    def GatewaySet(self, inGateway):
        r"""

        Sets the default gateway of the ByteBlower port.

        :param gateway: Gateway address string

        Example

        This example sets the gateway of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_GatewaySet(self, inGateway)

    def GatewayGet(self):
        r"""

        Returns the default gateway of the ByteBlower port.

        :return:  Default gateway of the ByteBlower port.

        Example

        This example gets the gateway of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_GatewayGet(self)

    def NetmaskSet(self, inNetMask):
        r"""

        Sets the netmask of the ByteBlower port.

        :param netmask: Netmask address string

        Example

        This example sets the netmask of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_NetmaskSet(self, inNetMask)

    def NetmaskGet(self):
        r"""

        Gets the netmask of the ByteBlower port.

        :return:  Netmask of the ByteBlower port.

        Example

        This example gets the netmask of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_NetmaskGet(self)

    def ProtocolArp(self, inIPAddress):
        r"""

        Performs MAC address resolution for a given IP address.

        Sends an ARP request for the specified IP address, and returns the answer if an
        answer is  received.

        .. note:: This call does not make use of the an ARP cache. If you are only
                  interested in resolving an IP then please use :meth:`Resolve` which
                  also makes use of the ARP cache.

        :param ipAddress: IPv4 address to resolve

        :return: Resolved MAC address

        :raises: InvalidDestination - When an unusable IP address was given.

        :raises: ARPTimeout - When the address could not be resolved.

        Example

        This example gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolArp(self, inIPAddress)

    def ProtocolArpAsync(self, inIPAddress):
        r"""

        Starts MAC address resolution for a given IP address.

        .. versionadded:: 2.2.0

        Sends an ARP request for the specified IP address, and returns immediately. To
        obtain the results of the ARP resolution, you can use :meth:`ProtocolArp`.

        .. note:: This call does not make use of the an ARP cache. If you are only
                  interested in resolving an IP then please use :meth:`ResolveAsync`
                  which also makes use of the ARP cache.

        :param ipAddress: IPv4 address to resolve

        :raises: InvalidDestination - When an unusable IP address was given.

        Example

        This example triggers ARP resolution gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolArpAsync(self, inIPAddress)

    def ProtocolGratuitousArpRequest(self):
        r"""

        Sends a Gratuitous ARP (GARP) request.

        .. versionadded:: 2.5.0

        The GARP Request can be used for host presence announcement. This way, other
        devices on the network can learn the Layer2 and Layer3 information of the host.
        This GARP Request is preferred over the GARP Reply

        Example

        This example sends a Gratuitous ARP request

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolGratuitousArpRequest(self)

    def ProtocolGratuitousArpReply(self):
        r"""

        Sends a Gratuitous ARP (GARP) request.

        .. versionadded:: 2.5.0

        The GARP Request can be used for host presence announcement. This way, other
        devices on the network can learn the Layer2 and Layer3 information of the host

        Example

        This example sends a Gratuitous ARP request

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolGratuitousArpReply(self)

    def Resolve(self, inIPAddress):
        r"""

        Resolve the MAC address for a given IP address.

        The ByteBlower server stores an ARP cache per ByteBlower port. Resolving the IP
        for a port will search the ARP cache first. If no entry was found then an
        actual ARP request is performed. An entry in the ARP cache remains valid for
        120 seconds.

        :param ipAddress: IPv4 address to resolve

        :return: Resolved MAC address

        :raises: InvalidDestination - When an unusable IP address was given.

        :raises: ARPTimeout - When the address could not be resolved.

        Example

        This example gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_Resolve(self, inIPAddress)

    def ResolveAsync(self, inIPAddress):
        r"""

        Start MAC address resolution for a given destination IP address.

        .. versionadded:: 2.2.0

        The ByteBlower server stores an ARP cache per ByteBlower port. Resolving the IP
        for a port will search the ARP cache first. If no entry was found then an
        actual ARP request is performed. An entry in the ARP cache remains valid for
        120 seconds.

        This methods initiates the MAC address resolution. To obtain the actual results
        of the address resolution, please use :meth:`Resolve`.

        :param ipaddress: IPv4 address to resolve

        :raises: InvalidDestination - When an unusable IP address was given.

        Example

        This example triggers address resolution gets the MAC address for the given IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ResolveAsync(self, inIPAddress)

    def ProtocolIcmpGet(self):
        return _byteblower.IPv4Configuration_ProtocolIcmpGet(self)

    def ProtocolDhcpGet(self):
        r"""

        Returns the DHCP protocol.

        :return: :class:`DHCPv4Protocol`

        Example

        This example gets the DHCP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolDhcpGet(self)

    def ProtocolIgmpGet(self):
        r"""

        Returns the IGMP protocol.

        :return: Object of type Layer4.Igmp.

        Example

        This example gets the IGMP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolIgmpGet(self)

    @staticmethod
    def IsValidLayer3Address(inAddress):
        return _byteblower.IPv4Configuration_IsValidLayer3Address(inAddress)

# Register IPv4Configuration in _byteblower:
_byteblower.IPv4Configuration_swigregister(IPv4Configuration)

def IPv4Configuration_IsValidLayer3Address(inAddress):
    return _byteblower.IPv4Configuration_IsValidLayer3Address(inAddress)

class IPv6Configuration(Layer3Configuration):
    r"""

    A class representing the IPv6 protocol that allows managing IPv6 settings,
    running IPv6 commands and accessing attached protocols.

    Each ByteBlowerPort must be configured with a layer 3 protocol through the
    method :meth:`ByteBlowerPort.Layer3IPv6Set`. If the IPv6 protocol is selected,
    this object is returned.
    Through it, the IPv6 protocol instance on that port can be configured.

    It provides the following functionality:

    - Configure and read various IPv6 settings and values such as the IP address.
    - Execute IPv6 commands such as resolving IPv6 addresses (through NDP).
    - Access protocols attached to the IPv6 protocol such as DHCPv6 and ICMPv6 on
      which other settings can be configured and other commands can be executed.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpManualAdd(self, inIPv6Address):
        r"""

        Adds a manual IPv6 address to the port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method adds such a manual IP address to the port. Note this method also
        adds the prefix derived from the specified address to the list of on-link
        prefixes.

        If the IPv6 protocol is not yet initialized, calling this method the first time
        will do so. This initialization causes the host's link-local address to be
        generated and looks for router advertisements to set the default gateway. If no
        router advertisement occurs, the gateway is set to the null address (::).

        :param address: The IPv6 address you want to add. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... A custom prefix length can be provided by
                        appending this argument with `/<prefix length>`, where
                        *<prefix length>* can be a number between 0 and 128.
                        If no such prefix length is appended, the default length of 64
                        is taken.

        Example

        This examples adds a global address address using default prefix length 64.

        .. code-block:: python
           :emphasize-lines: 2

        	bbPort1_l3 = port1.Layer3IPv6Set()
            bbPort1_l3.IpManualAdd('3000:3128::24/64')


        """
        return _byteblower.IPv6Configuration_IpManualAdd(self, inIPv6Address)

    def IpManualRemove(self, inIPv6Address):
        r"""

        Removes a specified manually added IP address from this port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method removes the specified IPv6 address from the port if it was added
        manually before. If the address was not added manually, nothing is done.

        :param address: The IPv6 address you want to add. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... No prefix length suffix (e.g. '/64')
                        may be included!

        Example

        This example removes the specified address from the port if it was previously
        added.

        .. code-block:: python
           :emphasize-lines: 1

        	port_layer3_config.IpManualRemove('3000:3128::23/64')



        """
        return _byteblower.IPv6Configuration_IpManualRemove(self, inIPv6Address)

    def IpManualClear(self):
        r"""

        Removes all manually added IP addresses from this port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method removes all addresses in the first category.

        Example

        This example removes all manually added addresses from the port.

        .. code-block:: python
           :emphasize-lines: 2

        	port_layer3_config = self.port.Layer3IPv6Get()
        	port_layer3_config.IpManualClear()


        """
        return _byteblower.IPv6Configuration_IpManualClear(self)

    def IpManualGet(self):
        r"""

        Returns all IPv6 addresses that where manually added by the user.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all manual IPv6 addresses on the port.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        :return: A list of manually added IPv6 addresses is returned. These addresses
                 are returned using the full (i.e. uncompressed) representation and
                 appended with their prefix lengths (see example). An empty list
                 (i.e. empty string) is returned if no addresses were added yet.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: Prints a list of manual IPv6 addresses

        	port_layer3_config = self.port.Layer3IPv6Get()
        	list = port_layer3_config.IpManualGet()
        	for ip in list:
        		print(ip)


        """
        return _byteblower.IPv6Configuration_IpManualGet(self)

    def IpStatelessGet(self):
        r"""

        Returns all IPv6 addresses that where obtained by stateless autoconfiguration.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all SLAAC IPv6 addresses on the port. They are configured
        by calling the :meth:`StatelessAutoconfiguration` function.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        :return: A list of IPv6 addresses obtained during stateless autoconfiguration
                 (SLAAC) is returned. These addresses are returned using the full (i.e.
                 uncompressed) representation and appended with their prefix lengths
                 (see example). An empty list (i.e. empty string) is returned if no
                 autoconfiguration was performed yet or if it did not provided any IP
                 addresses.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints the list of SLAAC-obtained IPv6 addresses

        	bbPort1_l3.StatelessAutoconfiguration()
            statelessList = bbPort1_l3.IpStatelessGet()
            for ips in statelessList:
                print(ips)


        """
        return _byteblower.IPv6Configuration_IpStatelessGet(self)

    def IpDhcpGet(self):
        r"""

        Returns all IPv6 addresses that where obtained by the DHCPv6 protocol.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all DHCP IPv6 addresses on the port. They are configured by
        retrieving the DHCP protocol using :meth:`ProtocolDhcpGet` and executing
        :meth:`.DHCPv6Protocol.Perform`.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        :return: A list of IPv6 addresses obtained during DHCP is returned. These
                 addresses are returned using the full (i.e. uncompressed)
                 representation and appended with their prefix lengths (see example).
                 An empty list (i.e. empty string) is returned if no DHCP was performed
                 yet or if it did not provided any IP addresses.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints a list of DHCP-obtained IPv6 addresses.

        	dhcpList = bbPort1_l3.IpDhcpGet()
            for ip_dhcp in dhcpList:
                print(ip_dhcp)


        """
        return _byteblower.IPv6Configuration_IpDhcpGet(self)

    def GatewaySet(self, inGateway):
        return _byteblower.IPv6Configuration_GatewaySet(self, inGateway)

    def GatewayGet(self):
        return _byteblower.IPv6Configuration_GatewayGet(self)

    def GatewayAdvertisedGet(self):
        r"""

        Returns the current (preferred) gateway of this IPv6 protocol, set either
        manually or by performing DHCP or SLAAC.

        .. versionadded:: 2.1.0

        The first time an IP address is added (either manually or by performing DHCP or
        SLAAC) the preferred gateway is also automatically detected. From that moment
        on, it can be retrieved by this method.

        When no gateway is found when the IP is set (manually, through DHCP or SLAAC)
        the gateway is set to the null address (::). Every time this getter is called,
        IPv6 will look for router advertisements. If one is found, it will be updated
        automatically.

        Once the preferred gateway is set using :meth:`GatewayManualSet`, this value
        remains the preferred gateway until it is explicitly replaced. Performing DHCP
        or SLAAC again will not replace the manually set value. This may change in the
        future.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        This example retrieves the current gateway.

        .. code-block:: python
           :emphasize-lines: 3

        	port_layer3_config = self.port.Layer3IPv6Get()
        	for link in port_layer3_config.GatewayAdvertisedGet():
        		print(link)


        """
        return _byteblower.IPv6Configuration_GatewayAdvertisedGet(self)

    def IpLinkLocalGet(self):
        r"""

        Returns the linklocal address which is based on the MAC address of the port.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns the link-local IPv6 address on the port. It uses the
        dedicated fe80::/64 prefix as the first half of the address and the modified
        EUI-64 number (based on the Ethernet MAC address) as the last half of the
        address.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        irst time when calling this method, the gateway property will be set updated
        automatically.

        :return: The linklocal IPv6 address is returned. This address does always
                 exist, even if no IPv6 gateway is present. The address is returned
                 using the full (i.e. uncompressed) representation. The prefix length
                 suffix ('/64') is omitted!

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        This example returns the link-local address of a port.

        .. code-block:: python
           :emphasize-lines: 3

        	bbPort1_l3 = port1.Layer3IPv6Set()
        	print(bbPort1_l3.IpLinkLocalGet())


        """
        return _byteblower.IPv6Configuration_IpLinkLocalGet(self)

    def StatelessAutoconfiguration(self):
        r"""

        Performs stateless address autoconfiguration (SLAAC) to configure IPv6 with,
        among others, a global IPv6 address.

        The stateless address autoconfiguration (SLAAC) is done in an asynchronous
        manner. It works through the IPv6 Neighbor Discovery Protocol (NDP). It creates
        an IP address based on the prefix information from incoming router
        advertisements (first 64 bits) and the hosts MAC address (last 64 bits).

        .. note:: SLAAC and the NDP is also used to create the link-local IP address.
                  This address has a fixed prefix (fe80::/64) and the same host part.
                  This address is immediately generated when the IPv6 protocol is
                  initialized and is not part of this call.

        If the IPv6 protocol is not yet initialized, calling this method the first time
        will do so. This initialization sets the link-local address described above and
        listens for router advertisements to set the default gateway. If no router
        advertisement occurs, the gateway is set to the null address (::).

        When no routing advertisement is found, no address is added.

        Example

        This example performs stateless address autoconfiguration on this host.

        .. code-block:: python
           :emphasize-lines: 3

        	bbPort1_l3 = port1.Layer3IPv6Set()
            bbPort1_l3.StatelessAutoconfiguration()


        """
        return _byteblower.IPv6Configuration_StatelessAutoconfiguration(self)

    def StatelessAutoconfigurationAsync(self):
        r"""

        Performs stateless address autoconfiguration (SLAAC) to configure IPv6 with,
        among others, a global IPv6 address.

        .. versionadded:: 2.3.0

        This is a asynchronous call so it will return immediately. If you want to wait
        until it has finished then call the :meth:`StatelessAutoconfiguration` method
        after having called this method. This will also rethrow any exceptions that may
        have occured on the server side.

        Returns immediately.

        :return: This method will return nothing and return immediately.

        Example

        This example performs stateless address autoconfiguration on this host.

        .. code-block:: python
           :emphasize-lines: 1

        	port_layer3_config.StatelessAutoconfigurationAsync()

        """
        return _byteblower.IPv6Configuration_StatelessAutoconfigurationAsync(self)

    def NeighborDiscovery(self, inIPv6Address):
        r"""

        Resolves a destination IPv6 address by explicitly performing Neighbor Discovery.

        To use the neighbor cache first when resolving an IPv6 address, execute the
        :meth:`Resolve` method. This may return significantly faster then this method.

        :param address: The IPv6 address that must be resolved. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, ...
                        No pre	fix length suffix (e.g. '/64') may be included!

        :return: The layer 2 MAC address found for the provided IPv6 address.

        :raises: ByteBlower.Protocol.Arp.NoReply - When nobody replies to the
                 Neighbour Discovery request (i.e. neither the host itself or a
                 forwarding router), this exception is thrown.

        Example

        This simple example resolves a link-local IPv6 address. This example clearly
        shows that the host part of a link-local address is based on its layer 2
        MAC address.

        .. code-block:: python
           :emphasize-lines: 1

        	port_layer3_config.NeighborDiscovery('fe80:0000:0000:0000:02ff:25ff:fe00:0001')


        """
        return _byteblower.IPv6Configuration_NeighborDiscovery(self, inIPv6Address)

    def Resolve(self, inIPv6Address):
        r"""

        Resolves a destination IPv6 address by looking in the neighbour cache or
        performing Neighbor Discovery.

        To force this host to perform the Neighbor Discovery algorithm and thus bypass
        the cache, execute the :meth:`ProtocolNeighborDiscovery` method.

        :param address: The IPv6 address that must be resolved. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... No prefix length suffix (e.g. '/64') may
                        be included!

        :return: The layer 2 MAC address found for the provided IPv6 address.

        :raises: ByteBlower.Protocol.Arp.NoReply - When the item is not present in the
                 neighbor cache and nobody replies to the Neighbour Discovery request
                 (i.e. neither the host itself or a forwarding router), this exception
                 is thrown.

        Example

        This simple example resolves a link-local IPv6 address. This example clearly
        shows that the host part of a link-local address is based on its layer 2 MAC
        address.

        .. code-block:: python
           :emphasize-lines: 4

        	dhcpv6 = port_l3.ProtocolDhcpGet()
        	dhcpv6.Perform()
        	port = port_l3.IpDhcpGet()
        	dst_mac = self.port_1.Layer3IPv6Get().Resolve(port)


        """
        return _byteblower.IPv6Configuration_Resolve(self, inIPv6Address)

    def ProtocolIcmpGet(self):
        return _byteblower.IPv6Configuration_ProtocolIcmpGet(self)

    def ProtocolDhcpGet(self):
        r"""

        Returns the DHCPv6 protocol attached to this protocol through which DHCP can
        be performed.

        See :class:`.DHCPv6Protocol` for more configuration options.
        To actually perform DHCP, execute the :meth:`.DHCPv6Protocol.Perform` method on
        the returned object.

        If the IPv6 protocol is not yet initialized, performing DHCP the first time
        will do so. This initialization causes the host's link-local address to be
        generated and looks for router advertisements to set the default gateway. If no
        router advertisement occurs, the gateway is set to the null address (::) and no
        address is set.

        :return: :class:`.DHCPv6Protocol`

        Example

        This example returns the DHCP object.

        .. code-block:: python
           :emphasize-lines: 3

        	port_layer3_config = self.port.Layer3IPv6Get()
        	protocolDhcp = port_layer3_config.ProtocolDhcpGet()


        """
        return _byteblower.IPv6Configuration_ProtocolDhcpGet(self)

    def ProtocolMldGet(self):
        return _byteblower.IPv6Configuration_ProtocolMldGet(self)

    @staticmethod
    def IsValidLayer3Address(inAddress):
        return _byteblower.IPv6Configuration_IsValidLayer3Address(inAddress)

# Register IPv6Configuration in _byteblower:
_byteblower.IPv6Configuration_swigregister(IPv6Configuration)

def IPv6Configuration_IsValidLayer3Address(inAddress):
    return _byteblower.IPv6Configuration_IsValidLayer3Address(inAddress)

ModifierType_GrowingSize = _byteblower.ModifierType_GrowingSize
ModifierType_RandomSize = _byteblower.ModifierType_RandomSize
ModifierType_MultiBurst = _byteblower.ModifierType_MultiBurst
ModifierType_NormalDistributionTiming = _byteblower.ModifierType_NormalDistributionTiming
class AbstractModifier(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetByteBlowerStream(self):
        return _byteblower.AbstractModifier_GetByteBlowerStream(self)

    def GetModifierType(self):
        return _byteblower.AbstractModifier_GetModifierType(self)

# Register AbstractModifier in _byteblower:
_byteblower.AbstractModifier_swigregister(AbstractModifier)

class StreamGrowingSizeModifier(object):
    r"""

    A frame size modifier which will increase the size of the frame between a minimum and maximum value.

    .. deprecated 2.3.0
       This functionality is replaced by the :class:`.FrameSizeModifierGrowing`,
       see :meth:`.Frame.ModifierSizeGrowingSet` for more information.

    ByteBlower allows different modifiers on a flow.
    Some modifiers work on the timing parameters of a frame, others on the size
    or content. The :class:`StreamGrowingSizeModifier` is a modifier which modifies
    the size of the frames added to the :class:`.Stream` on which this Modifier is
    added.

    A :class:`.StreamGrowingSizeModifier` will increment the frame size with a
    configured amount of bytes. The following parameters can be configured:

    Minimum size
        the minimum frame size. This size will be used when the Stream is started.

    Maximum size
        the maximum frame size. It this limit isreached, the modifier will return
        to the minimum size again.

    Step size
        the amount of bytes the size will increase. By default, a frame will grow
        with one byte but this parameter allows larger step sizes.

    Iteration
        this paramter defines the number of times the same frame size is iterated
        before increasing to the next frame size.

    So, a stream with a StreamModifierGrowingSize installed, will start sending
    frames with a *<Minimum size>* size, will send this size *<Iteration>* times,
    increase the size with *<Step size>* bytes until the *<Maximum size>* is
    reached.

    If the maximum size is reached, the next size is calculated as follows:

        *<next size>* = *<Minimum size>*
                      + ( *<current size>* + *<Step size>* - *<Maximum size>* )

    All sizes define a frame size, excluding the 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. It the original frame size is longer, the size will truncated to
    the requested frame size. If automatic checksum calculations have been enabled
    on the Frame, they will be recalculated. This depends on the configuration of
    the Frame. See the Frame documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    If multiple frames are added to a TxStream which is configured with a
    StreamModifierGrowingSize, the frames are sent alternately, while the modifier
    is applied on all of them. E.g.

        {Frame A , size X},
        {Frame B, size X},
        {Frame A, size X+1},
        {Frame B, size X+1}, ...

    ..note:: It is possible that the maximum size is never reached. Depending on
             both the *<Step size>* and the TxStream configuration
             (NumberOfFrames), the maximum size will never be used.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.MaximumGet())



        """
        return _byteblower.StreamGrowingSizeModifier_MaximumGet(self)

    def MaximumSet(self, inMaxSize):
        r"""

        Sets the maximum size of a Frame of a growing size flow. This defines the
        maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame.
                        This value must be at least 61 bytes, and maximum 8192. The
                        value must also be bigger than the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error - Maximum too big or too small.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	growingSizeModifier.MaximumSet(128)



        """
        return _byteblower.StreamGrowingSizeModifier_MaximumSet(self, inMaxSize)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum frame size.

        :return: The minimum frame size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.MinimumGet())



        """
        return _byteblower.StreamGrowingSizeModifier_MinimumGet(self)

    def MinimumSet(self, inMinSize):
        r"""

        Sets the Minimum size of a Frame of a growing size flow.

        This defines the minimal frame size of the stream. This frame size will be used
        when a Tx.Stream is started.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.    Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.MinimumSet(128))



        """
        return _byteblower.StreamGrowingSizeModifier_MinimumSet(self, inMinSize)

    def StepGet(self):
        r"""

        Method to get the current configured step size.

        :return: The step size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current step size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.StepGet())



        """
        return _byteblower.StreamGrowingSizeModifier_StepGet(self)

    def StepSet(self, inStep):
        r"""

        Sets the number of bytes a frame will grow in one step.

        Each time the modifier needs to adapt the size of the frame, the size will be
        incremented with *<Step size>* bytes.

        :param step: This parameter defines the amount of bytes the frame will grow.
                     Default: `1`

        :raises: python_error - An error is returned when the value is less than 1.

        Example

        This example demonstrates a step size of 10 bytes:

        .. code-block:: python
           :emphasize-lines: 1

        	growingSizeModifier.StepSet(10)



        """
        return _byteblower.StreamGrowingSizeModifier_StepSet(self, inStep)

    def IterationGet(self):
        r"""

        Method to get the current configured iteration.

        :return: The iteration which will be used for a growing size flow.

        Example

        This example show how to retrieve the current iteration.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.IterationGet())



        """
        return _byteblower.StreamGrowingSizeModifier_IterationGet(self)

    def IterationSet(self, inIteration):
        r"""

        Sets the number of times the same frame size will be used.

        A Frame can be sent with the same frame size multiple times before the size is
        increased to the next value. This parameter defines the iteration count.

        :param iteration: Number of times the same frame size will be used before the
                          frame size is increased to the next value.   Default: `1`

        Example

        This example demonstrates an iteration of 10, before going to the next frame
        size.

        .. code-block:: python
           :emphasize-lines: 1

        	growingSizeModifier.IterationSet(10)


        """
        return _byteblower.StreamGrowingSizeModifier_IterationSet(self, inIteration)

    def ReCommitValues(self, inFrame):
        return _byteblower.StreamGrowingSizeModifier_ReCommitValues(self, inFrame)

# Register StreamGrowingSizeModifier in _byteblower:
_byteblower.StreamGrowingSizeModifier_swigregister(StreamGrowingSizeModifier)

class MultipleBurstModifier(AbstractModifier):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterBurstGapGet(self):
        r"""

        Returns the time (ns) between the end of start of the next burst.

        Example

        Get the gap between 2 bursts

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_InterBurstGapGet(self)

    def InterBurstGapSet(self, inInterBurstGap):
        r"""

        Sets the time (ns) between the end of one burst and the start of the next burst.

        :param interburstgap: The gap between 2 burst in ns

        Example

        Set the gap at 1ms

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        Set the gap at 10ms

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_InterBurstGapSet(self, inInterBurstGap)

    def BurstSizeGet(self):
        r"""

        Retrieves the number of frames in one burst.

        :return: Returns the number of frames in one burst

        Example

        retrieve the burstsize

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_BurstSizeGet(self)

    def BurstSizeSet(self, inBurstSize):
        r"""

        Sets the number of frames to send in one burst.

        :param burstsize: the size of the burst

        Example

        Set the burstsize to 100

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_BurstSizeSet(self, inBurstSize)

# Register MultipleBurstModifier in _byteblower:
_byteblower.MultipleBurstModifier_swigregister(MultipleBurstModifier)

class NormalDistributionTimingModifier(AbstractModifier):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VarianceSet(self, inVariance):
        r"""

        Sets the variance of the normal distribution

        """
        return _byteblower.NormalDistributionTimingModifier_VarianceSet(self, inVariance)

    def VarianceGet(self):
        r"""

        Retrieves the variance of the normal distribution

        :return:  Returns the number of frames in one burst

        """
        return _byteblower.NormalDistributionTimingModifier_VarianceGet(self)

# Register NormalDistributionTimingModifier in _byteblower:
_byteblower.NormalDistributionTimingModifier_swigregister(NormalDistributionTimingModifier)

class StreamRandomSizeModifier(object):
    r"""

    A frame size modifier which will change the size of the frame randomly between
    a minimum and maximum value.

    .. deprecated:: 2.3.0
       This functionality is replaced by the :class:`.FrameSizeModifierRandom`, see
       :meth:`.Frame.ModifierSizeRandomSet` for more information.

    ByteBlower allows different modifiers on a flow. Some modifiers work on the
    timing parameters of a frame, others on the size or content. The
    StreamModifierRandomSize is a modifier which modifies the size of the frames
    added to the Stream on which this Modifier is added.

    A StreamModifierRandomSize will change the frame size randomly. The following
    parameters can be configured:

    Minimum size
        the minimum frame size.

    Maximum size
        the maximum frame size.

    So, a stream with a StreamModifierRandomSize installed, will start sending
    frames with a size randomly chosen between *<Minimum size>* size and
    *<Maximum size>* size. Each time a frame is sent, a new size is selected.

    All sizes are without the additional 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. If the original frame size is bigger, the size will truncated to the
    requested frame size. If automatic checksum calculations have been enabled on
    the Frame, they will be recalculated. This depends on the configuration of the
    Frame. See the :class:`Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    If multiple frames are added to a TxStream which is configured with a
    StreamModifierRandomSize, the frames are sent alternately, while the modifier
    is applied on all of them.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MinimumSet(self, inMinimum):
        r"""

        Sets the Minimum size of a Frame of a flow with StreamModifierRandomSize.

        This defines the minimal frame size of the stream.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.    Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	RandomSizeModifier.MinimumSet(128)



        """
        return _byteblower.StreamRandomSizeModifier_MinimumSet(self, inMinimum)

    def MinimumGet(self):
        r"""

        Method to get the currently configured minimum frame size.

        :return:  The minimum frame size which will be used for a random size flow.

        Example

        This example show how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(RandomSizeModifier.MinimumGet())



        """
        return _byteblower.StreamRandomSizeModifier_MinimumGet(self)

    def MaximumSet(self, inMaximum):
        r"""

        Sets the Maximum size of a Frame of a flow with StreamModifierRandomSize.

        This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.   Default: `1514`

        :raises: python_error: Maximum too small or too big.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	RandomSizeModifier.MaximumSet(128)



        """
        return _byteblower.StreamRandomSizeModifier_MaximumSet(self, inMaximum)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a random size flow.

        Example

        This example show how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 3

           	print(RandomSizeModifier.MaximumGet())



        """
        return _byteblower.StreamRandomSizeModifier_MaximumGet(self)

    def ReCommitValues(self, inFrame):
        return _byteblower.StreamRandomSizeModifier_ReCommitValues(self, inFrame)

# Register StreamRandomSizeModifier in _byteblower:
_byteblower.StreamRandomSizeModifier_swigregister(StreamRandomSizeModifier)

class FrameFieldModifier(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FrameGet(self):
        return _byteblower.FrameFieldModifier_FrameGet(self)

    def OffsetGet(self):
        return _byteblower.FrameFieldModifier_OffsetGet(self)

    def OffsetSet(self, inOffset):
        return _byteblower.FrameFieldModifier_OffsetSet(self, inOffset)

    def LengthGet(self):
        return _byteblower.FrameFieldModifier_LengthGet(self)

    def LengthSet(self, inLength):
        return _byteblower.FrameFieldModifier_LengthSet(self, inLength)

# Register FrameFieldModifier in _byteblower:
_byteblower.FrameFieldModifier_swigregister(FrameFieldModifier)

class FrameFieldModifierIncremental(FrameFieldModifier):
    r"""

    A frame field modifier which will increase the value of the frame field between a minimum and maximum value.

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The :class:`.FrameFieldModifierIncremental`
    is a modifier which modifies a certain field in the frame content.

    A frame field is a number of subsequent bytes in the frame content. The value
    is defined as host-ordering signed integer and will be written to the frame
    content as network-ordering signed integer.

    A FrameFieldModifierIncremental will increment the value in a frame field with
    a configured amount. The following parameters can be configured:

    1. Parameters related to the location of the field in the frame:

       Field offset
           Offset of the field counted in bytes from the start of the frame.

       Field length
           Length of the field counted in bytes. Minimum: 1Byte. Maximum: 8Bytes (
           depends on server version).

       The field cannot overwrite the 4 bytes Ethernet checksum. The allowed range
       for offset is 0 ... *<ByteBlowerPort MDL>*.


       - When the field offset is greater or equal than the actual frame size,
         nothing will be written to the frame.

       - When the field offset is smaller than the actual frame size, but the
         field offset + field length exceeds the frame size.
         Then the LSB part of the field will be written to the frame.

       Please note that in both cases the field value
       will still move on to the next value.

    2. Parameters related to the value written to the field:

       Minimum value
           The minimum field value.

       Maximum value
           The maximum field value.

       Value step
           The amount the value will increase. By default, the value will grow with
           one but this parameter allows larger value steps. The step can be
           positive or negative but cannot be zero.

       Initial value
           This field value will bewritten to the frame contents when the
           :class:`.Stream` is started.

       The field value range is defined by the minimum and maximum value (both
       valuesinclusive).

       - Positive value step
         A frame with a FrameFieldModifierIncremental installed, will start
         sending frames with field value *<Initial value>*, increase the value
         with *<Value step>* until the *<Maximum value>* is reached.

         When maximum value is reached, the modifier will return to the minimum
         value again. So if the *<Maximum value>* is reached, the next value will
         be the *<Minimum value>*.

       - Negative value step
         A frame with a FrameFieldModifierIncremental installed, will start sending
         frames with field value *<Initial value>*, increase the value with (the
         *negative*) *<Value step>* (thus *decrease* the value) until the
         *<Minimum value>* is reached.

         When the minimum value is reached, the modifier will return to the maximum
         value again. So if the *<Minimum value>* is reached, the next value will
         be the *<Maximum value>*.

    .. note:: When the *<Initial value>* is smaller than the *<Minimum value>*
              when the stream is started, then the minimum value will be used as
              initial value. When the *<Initial value>* is greater than the
              *<Maximum value>* when the stream is started, then the maximum value
              will be used as initial value.

    .. note:: If automatic checksum and/or length calculations have been enabled
              on the Frame and the frame field overlaps one or more of those. Then
              the automatic fields will overrule the field modifier value. This
              depends on the configuration of the Frame. See the Frame
              documentation on how this can be done.

    .. note:: It is possible that the maximum value is never reached. Depending on
              the *<Value step>* and the Stream configuration (*<NumberOfFrames>*),
              the maximum value will never be reached.

    .. versionadded:: 2.3.0

    .. code-block:: python
       :emphasize-lines: 2

        frameModifierIncr = frame.ModifierFieldIncrementalAdd()
        frameModifierIncr.MinimumSet(500)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def OffsetGet(self):
        r"""

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this incremental value field
                 modifier.

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierIncr.OffsetGet())

        """
        return _byteblower.FrameFieldModifierIncremental_OffsetGet(self)

    def OffsetSet(self, inOffset):
        r"""

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`

        :raises: :exc:`.ConfigError` When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.OffsetSet(88)

        """
        return _byteblower.FrameFieldModifierIncremental_OffsetSet(self, inOffset)

    def LengthGet(self):
        r"""

        Method to get the current configured field length.

        :return: The field length which will be used for this incremental value field
                 modifier.

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.LengthGet())

        """
        return _byteblower.FrameFieldModifierIncremental_LengthGet(self)

    def LengthSet(self, inLength):
        r"""

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`

        :raises: :exc:`.ConfigError`  When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierIncr.LengthSet(4)

        """
        return _byteblower.FrameFieldModifierIncremental_LengthSet(self, inLength)

    def InitialValueGet(self):
        r"""

        Method to get the current configured initial field value.

        :return: The initial field value which will be used for this incremental value
                 field modifier.

        Example

        This example shows how to retrieve the current initial field value.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.InitialValueGet())

        """
        return _byteblower.FrameFieldModifierIncremental_InitialValueGet(self)

    def InitialValueSet(self, inInitialValue):
        r"""

        Sets the initial value of the frame field.

        This value will be used when a Tx.Stream is started.

        :param initial: Initial value of the frame field. When the initial value is
                        smaller than the *<Minimum value>* when the stream is started,
                        then the minimum value will be used as initial value. When the
                        initial value is greater than the *<Maximum value>* when the
                        stream is started, then the maximum value will be used as
                        initial value.
                        Default: `0`

        Example

        This example will set the initial value to 1024.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.InitialValueSet(1024)


        """
        return _byteblower.FrameFieldModifierIncremental_InitialValueSet(self, inInitialValue)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum field value.

        :return: The minimum field value which will be used for this incremental value
                 field modifier.

        Example

        This example shows how to retrieve the current minimum field value.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.MinimumGet())

        """
        return _byteblower.FrameFieldModifierIncremental_MinimumGet(self)

    def MinimumSet(self, inMinValue):
        r"""

        Sets the Minimum value of the frame field for an incremental value field modifier.

        :param minimum: Minimum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be less than
                        the *<Maximum value>* configured.
                        Default: `0`

        :raises: :exc:`.ConfigError` Minimum too small or too big.

        Example

        This example will set the minimum value to 512.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.MinimumSet(512)

        """
        return _byteblower.FrameFieldModifierIncremental_MinimumSet(self, inMinValue)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum field value.

        :return: The maximum field value which will be used for this incremental value
                 field modifier.

        Example

        This example shows how to retrieve the current maximum field value.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierIncr.MaximumGet())

        """
        return _byteblower.FrameFieldModifierIncremental_MaximumGet(self)

    def MaximumSet(self, inMaxValue):
        r"""

        Sets the maximum value of the frame field for an incremental value field modifier.

        :param maximum: Maximum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be greater
                        than the *<Minimum value>* configured.
                        Default: `65535`

        :raises: :exc:`.ConfigError` Maximum too big or too small.

        Example

        This example will set the maximum value to 16383 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.MaximumSet(16383)

        """
        return _byteblower.FrameFieldModifierIncremental_MaximumSet(self, inMaxValue)

    def StepGet(self):
        r"""

        Method to get the current configured value step.

        :return: The value step which will be used for an incremental value field
                 modifier.

        Example

        This example shows how to retrieve the current value step.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierIncr.StepGet())

        """
        return _byteblower.FrameFieldModifierIncremental_StepGet(self)

    def StepSet(self, inStep):
        r"""

        Sets the value a field value will grow in one step.

        Each time the modifier needs to adapt the value of the frame field, it will be
        incremented with *<Value step>*.

        :param step: This parameter defines the amount the field value will grow. This
                     value can be positive or negative.
                     Default: `1`

        :raises: :exc:`.ConfigError`  An error is returned when the value is zero.

        Example

        This example demonstrates a value step of 10:

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.StepSet(10)

        This example demonstrates a negative value step of 2:

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.StepSet(-2)


        """
        return _byteblower.FrameFieldModifierIncremental_StepSet(self, inStep)

# Register FrameFieldModifierIncremental in _byteblower:
_byteblower.FrameFieldModifierIncremental_swigregister(FrameFieldModifierIncremental)

class FrameFieldModifierRandom(FrameFieldModifier):
    r"""

    A frame field modifier which will change the field value of the frame randomly
    between a minimum and maximum value.

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The FrameFieldModifierRandom is a modifier
    which modifies a certain field in the frame content.

    A frame field is a number of subsequent bytes in the frame content. The value
    is defined as host-ordering signed integer and will be written to the frame
    content as network-ordering signed integer.

    A FrameFieldModifierRandom will change the value in the frame field randomly.
    The following parameters can be configured:

    1. Parameters related to the location of the field in the frame:

       Field offset
           Offset of the field counted in bytes from the start of the frame.

       Field length
           Length of the field counted in  bytes. Minimum: 1Byte. Maximum: 8Bytes
           (depends on server version).

       The field cannot overwrite the 4 bytes Ethernet checksum. The allowed range
       for offset is 0 ... *<ByteBlowerPort MDL>*.

       - When the field offset is greater or equal than the actual frame size,
         nothing will be written to the frame.

       - When the field offset is smaller than the actual frame size, but the
         field offset + field length exceeds the frame size.

         Then the LSB part of the field will be written to the frame.

       Please note that in both cases the field value will still move on to the next value.

    2. Parameters related to the value written to the field:

       Minimum value
           The minimum field value.

       Maximum value
           The maximum field value.

       The field value range is defined by the minimum and maximum value (both
       values inclusive).

       So, a frame with a FrameFieldModifierRandom installed, will start sending
       frames with field values randomly chosen between *<Minimum value>* and
       *<Maximum value>*. Each time a frame is sent, a new value is selected.

    .. note:: If automatic checksum and/or length calculations have been enabled on
              the Frame and the frame field overlaps one or more of those. Then the
              automatic fields will overrule the field modifier value. This depends
              on the configuration of the Frame. See the :class:`.Frame`
              documentation on how this can be done.

    .. versionadded:: 2.3.0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def OffsetGet(self):
        r"""

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.OffsetGet())

        """
        return _byteblower.FrameFieldModifierRandom_OffsetGet(self)

    def OffsetSet(self, inOffset):
        r"""

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`

        :raises: :exc:`.ConfigError` When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.OffsetSet(88)

        """
        return _byteblower.FrameFieldModifierRandom_OffsetSet(self, inOffset)

    def LengthGet(self):
        r"""

        Method to get the current configured field length.

        :return: The field length which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.LengthGet())

        """
        return _byteblower.FrameFieldModifierRandom_LengthGet(self)

    def LengthSet(self, inLength):
        r"""

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`

        :raises: :exc:`.ConfigError` When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.LengthSet(4)

        """
        return _byteblower.FrameFieldModifierRandom_LengthSet(self, inLength)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum field value.

        :return: The minimum field value which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current minimum field value.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.MinimumGet())

        """
        return _byteblower.FrameFieldModifierRandom_MinimumGet(self)

    def MinimumSet(self, inMinValue):
        r"""

        Sets the Minimum value of the frame field for a random value field modifier.

        :param minimum: Minimum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be less than
                        the *<Maximum value>* configured.
                        Default: `0`

        :raises: :exc:`.ConfigError` Minimum too small or too big.

        Example

        This example will set the minimum value to 512.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.MinimumSet(512)

        """
        return _byteblower.FrameFieldModifierRandom_MinimumSet(self, inMinValue)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum field value.

        :return: The maximum field value which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current maximum field value.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.MaximumGet())

        """
        return _byteblower.FrameFieldModifierRandom_MaximumGet(self)

    def MaximumSet(self, inMaxValue):
        r"""

        Sets the maximum value of the frame field for a random value field modifier.

        :param maximum: Maximum value for the frame field. This value is limited to
                        64-bit signed integer range. Thevalue must always be greater
                        than the *<Minimum value>* configured.
                        Default: `65535`

        :raises: :exc:`.ConfigError` Maximum too big or too small.

        Example

        This example will set the maximum value to 16383 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.MaximumSet(16383)

        """
        return _byteblower.FrameFieldModifierRandom_MaximumSet(self, inMaxValue)

# Register FrameFieldModifierRandom in _byteblower:
_byteblower.FrameFieldModifierRandom_swigregister(FrameFieldModifierRandom)

class FrameSizeModifierResultSnapshot(AbstractRefreshableResult):
    r"""

    A collection of statistics containing the results of a frame size modifier.

    There are currently 2 frame size modifiers available:

    - The :class:`FrameSizeModifierGrowing`, which is the Growing Size modifier
    - The :class:`FrameSizeModifier.Random`, which is the Random Size modifier.

    Example

    This example shows how to retrieve the number of packets handled by a
    FrameSizeModifierGrowing

    .. code-block:: python

    	resultSnapshot = sizeModifierRandom.ResultGet()
    	print(resultSnapshot.PacketCountGet())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampFirstGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""


        Gets the timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampLastGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampLastGet(self)

    def ByteCountGet(self):
        r"""

        Returns the number of transmitted bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.ByteCountGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Returns the size of the biggest transmitted frame.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        .. code-block:: 1
           :emphasize-lines: 2

            print(snapshot.FramesizeMaximumGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Returns the size of the smallest transmitted frame.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.FramesizeMinimumGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountGet(self, *args):
        r"""

        Returns the number of transmitted packets.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountGet())

        Returns the number of transmitted packets.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountGet(self, *args)

    def PacketCountBelowMinimumGet(self):
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountAboveMaximumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.IntervalDurationGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.RefreshTimestampGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_RefreshTimestampGet(self)

# Register FrameSizeModifierResultSnapshot in _byteblower:
_byteblower.FrameSizeModifierResultSnapshot_swigregister(FrameSizeModifierResultSnapshot)

class FrameSizeModifier(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_MIN_SIZE = _byteblower.FrameSizeModifier_DEFAULT_MIN_SIZE
    DEFAULT_MAX_SIZE = _byteblower.FrameSizeModifier_DEFAULT_MAX_SIZE

    def ResultGet(self):
        return _byteblower.FrameSizeModifier_ResultGet(self)

    def FrameGet(self):
        return _byteblower.FrameSizeModifier_FrameGet(self)

# Register FrameSizeModifier in _byteblower:
_byteblower.FrameSizeModifier_swigregister(FrameSizeModifier)

class FrameSizeModifierGrowing(FrameSizeModifier):
    r"""

    A frame size modifier which will increase the size of the frame between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The :class:`FrameSizeModifierGrowingSize` is a
    modifier which modifies the size of the frame.

    A FrameSizeModifierGrowingSize will increment the frame size with a configured
    amount of bytes. The following parameters can be configured:

    Minimum size
        the minimum frame size. This size will be used when the Stream is started.

    Maximum size
        the maximum frame size. It this limit is reached, the modifier will return
        to the minimum size again.

    Step size
        the amount of bytes the size will increase. By default, a frame will grow
        with one byte but this parameter allows larger step sizes.

    Iteration
        this parameter defines the number of times the same frame size is iterated
        before increasing to the next frame size.

    So, a frame with a FrameSizeModifierGrowingSize installed, will start sending
    frames with a *<Minimum size>* size, will send this size *<Iteration>* times,
    increase the size with *<Step size>* bytes until the *<Maximum size>* is
    reached.

    If the maximum size is reached, the next size is calculated as follows:

        *<next size>* = *<Minimum size>* + ( *<current size>* + *<Step size>* - *<Maximum size>* )

    All sizes define a frame size, excluding the 4 bytes Ethernet checksum.

    The frame size modifier will change the size of the Frame. If the original
    frame size is longer, the size will truncated to the requested frame size. If
    automatic checksum calculations have been enabled on the Frame, they will be
    recalculated. This depends on the configuration of the Frame. See the
    :class:`.Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    .. note:: It is possible that the maximum size is never reached. Depending on
              both the  *<Step size>* and the Stream configuration
              (NumberOfFrames), the maximum size will never be used.
    Example

    This example will set the minimum frame size to 128 bytes.

    .. code-block:: python
       :emphasize-lines: 2

    	sizeModifierGrowing = frame.ModifierSizeGrowingSet()
        sizeModifierGrowing.MinimumSet(128)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_ITERATION = _byteblower.FrameSizeModifierGrowing_DEFAULT_ITERATION
    DEFAULT_STEP_SIZE = _byteblower.FrameSizeModifierGrowing_DEFAULT_STEP_SIZE

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.MaximumGet())

        """
        return _byteblower.FrameSizeModifierGrowing_MaximumGet(self)

    def MaximumSet(self, inMaxSize):
        r"""

        Sets the maximum size of a Frame of a growing size flow. This defines the
        maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error Maximum too big or too small.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.MaximumSet(128)

        """
        return _byteblower.FrameSizeModifierGrowing_MaximumSet(self, inMaxSize)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum frame size.

        :return: The minimum frame size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.MinimumGet())

        """
        return _byteblower.FrameSizeModifierGrowing_MinimumGet(self)

    def MinimumSet(self, inMinSize):
        r"""

        Sets the Minimum size of a Frame of a growing size flow.

        This defines the minimal frame size of the stream. This frame size will be used
        when a Stream is started.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.
                        Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.MinimumSet(128)

        """
        return _byteblower.FrameSizeModifierGrowing_MinimumSet(self, inMinSize)

    def StepGet(self):
        r"""

        Method to get the current configured step size.

        :return: The step size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current step size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.StepGet())

        """
        return _byteblower.FrameSizeModifierGrowing_StepGet(self)

    def StepSet(self, inStep):
        r"""

        Sets the number of bytes a frame will grow in one step.

        Each time the modifier needs to adapt the size of the frame, the size will be
        incremented with *<Step size>* bytes.

        :param step: This parameter defines the amount of bytes the frame will grow. Default: `1`

        :raises: python_error: An error is returned when the value is less than 1.

        Example

        This example demonstrates a step size of 10 bytes:

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.StepSet(2)

        """
        return _byteblower.FrameSizeModifierGrowing_StepSet(self, inStep)

    def IterationGet(self):
        r"""

        Method to get the current configured iteration.

        :return:  The iteration which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current iteration.

        .. code-block:: python
           :emphasize-lines: 1

            iteration = sizeModifierGrowing.IterationGet()

        """
        return _byteblower.FrameSizeModifierGrowing_IterationGet(self)

    def IterationSet(self, inIteration):
        r"""

        Sets the number of times the same frame size will be used.

        A Frame can be sent with the same frame size multiple times before the size is
        increased to the next value. This parameter defines the iteration count.

        :param iteration: Number of times the same frame size will be used before the
                          frame size is increased to the next value. Default: `1`

        Example

        This example demonstrates an iteration of 10, before going to the next frame
        size.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.IterationSet(10)

        """
        return _byteblower.FrameSizeModifierGrowing_IterationSet(self, inIteration)

# Register FrameSizeModifierGrowing in _byteblower:
_byteblower.FrameSizeModifierGrowing_swigregister(FrameSizeModifierGrowing)

class FrameSizeModifierRandom(FrameSizeModifier):
    r"""

    A frame size modifier which will change the size of the frame randomly between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The FrameModifierRandomSize is a modifier
    which modifies the size of the frame.

    A FrameModifierRandomSize will change the frame size randomly. The following
    parameters can be configured:

    Minimum size
        the minimum frame size.

    Maximum size
        the maximum frame size.

    So, a stream with a FrameModifierRandomSize installed, will start sending
    frames with a size randomly chosen between *<Minimum size>* size and
    *<Maximum size>* size. Each time a frame is sent, a new size is selected.

    All sizes are without the additional 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. If the original frame size is bigger, the size will truncated to the
    requested frame size. If automatic checksum calculations have been enabled on
    the Frame, they will be recalculated. This depends on the configuration of the
    Frame. See the :class:`.Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    This example will set the maximum frame size to 128 bytes.

    .. code-block:: python

        sizeModifierRandom = frame.ModifierSizeRandomSet()
        sizeModifierRandom.MaximumSet(128)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StreamGet(self):
        return _byteblower.FrameSizeModifierRandom_StreamGet(self)

    def MinimumSet(self, inMinimum):
        r"""

        Sets the Minimum size of a Frame of a flow with FrameModifierRandomSize.

        This defines the minimal frame size of the stream.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.
                        Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierRandom.MinimumSet(128)

        """
        return _byteblower.FrameSizeModifierRandom_MinimumSet(self, inMinimum)

    def MinimumGet(self):
        r"""

        Method to get the currently configured minimum frame size.

        :return: The minimum frame size which will be used for a random size flow.

        Example

        This example shows how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierRandom.MinimumGet())

        """
        return _byteblower.FrameSizeModifierRandom_MinimumGet(self)

    def MaximumSet(self, inMaximum):
        r"""

        Sets the Maximum size of a Frame of a flow with FrameModifierRandomSize.

        This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error: Maximum too small or too big.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierRandom.MaximumSet(128)

        """
        return _byteblower.FrameSizeModifierRandom_MaximumSet(self, inMaximum)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a random size flow.

        Example

        This example shows how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierRandom.MaximumGet())

        """
        return _byteblower.FrameSizeModifierRandom_MaximumGet(self)

# Register FrameSizeModifierRandom in _byteblower:
_byteblower.FrameSizeModifierRandom_swigregister(FrameSizeModifierRandom)

class FrameResultData(AbstractObject):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampGet())

        """
        return _byteblower.FrameResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets  the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampFirstGet())

        """
        return _byteblower.FrameResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampLastGet())

        """
        return _byteblower.FrameResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.PacketCountGet())

        """
        return _byteblower.FrameResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.ByteCountGet())

        """
        return _byteblower.FrameResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame transmitted in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the largest framesize transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.FramesizeMaximumGet())

        """
        return _byteblower.FrameResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        return _byteblower.FrameResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameData.IntervalDurationGet())

        """
        return _byteblower.FrameResultData_IntervalDurationGet(self)

# Register FrameResultData in _byteblower:
_byteblower.FrameResultData_swigregister(FrameResultData)

class FrameResultSnapshot(AbstractRefreshableResult):
    r"""

    TODO

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampGet())

        """
        return _byteblower.FrameResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampFirstGet())

        """
        return _byteblower.FrameResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampLastGet())

        """
        return _byteblower.FrameResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.PacketCountGet())

        """
        return _byteblower.FrameResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.ByteCountGet())

        """
        return _byteblower.FrameResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame transmitted in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        .. versionadded:: 2.5.0

        Example

        This example gets the largest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.FramesizeMaximumGet())

        """
        return _byteblower.FrameResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame transmitted in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        .. versionadded:: 2.5.0

        Example

        This example gets the smallest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.FramesizeMinimumGet())

        """
        return _byteblower.FrameResultSnapshot_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.IntervalDurationGet())

        """
        return _byteblower.FrameResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameSnapshot.RefreshTimestampGet()

        """
        return _byteblower.FrameResultSnapshot_RefreshTimestampGet(self)

# Register FrameResultSnapshot in _byteblower:
_byteblower.FrameResultSnapshot_swigregister(FrameResultSnapshot)

class FrameResultSnapshotList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameResultSnapshotList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameResultSnapshotList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameResultSnapshotList___bool__(self)

    def __len__(self):
        return _byteblower.FrameResultSnapshotList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameResultSnapshotList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameResultSnapshotList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameResultSnapshotList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameResultSnapshotList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameResultSnapshotList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameResultSnapshotList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameResultSnapshotList_pop(self)

    def append(self, x):
        return _byteblower.FrameResultSnapshotList_append(self, x)

    def empty(self):
        return _byteblower.FrameResultSnapshotList_empty(self)

    def size(self):
        return _byteblower.FrameResultSnapshotList_size(self)

    def swap(self, v):
        return _byteblower.FrameResultSnapshotList_swap(self, v)

    def begin(self):
        return _byteblower.FrameResultSnapshotList_begin(self)

    def end(self):
        return _byteblower.FrameResultSnapshotList_end(self)

    def rbegin(self):
        return _byteblower.FrameResultSnapshotList_rbegin(self)

    def rend(self):
        return _byteblower.FrameResultSnapshotList_rend(self)

    def clear(self):
        return _byteblower.FrameResultSnapshotList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameResultSnapshotList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameResultSnapshotList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameResultSnapshotList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.FrameResultSnapshotList_swiginit(self, _byteblower.new_FrameResultSnapshotList(*args))

    def push_back(self, x):
        return _byteblower.FrameResultSnapshotList_push_back(self, x)

    def front(self):
        return _byteblower.FrameResultSnapshotList_front(self)

    def back(self):
        return _byteblower.FrameResultSnapshotList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameResultSnapshotList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameResultSnapshotList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameResultSnapshotList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameResultSnapshotList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameResultSnapshotList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameResultSnapshotList

# Register FrameResultSnapshotList in _byteblower:
_byteblower.FrameResultSnapshotList_swigregister(FrameResultSnapshotList)

class FrameResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.FrameResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameResultDataList_pop(self)

    def append(self, x):
        return _byteblower.FrameResultDataList_append(self, x)

    def empty(self):
        return _byteblower.FrameResultDataList_empty(self)

    def size(self):
        return _byteblower.FrameResultDataList_size(self)

    def swap(self, v):
        return _byteblower.FrameResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.FrameResultDataList_begin(self)

    def end(self):
        return _byteblower.FrameResultDataList_end(self)

    def rbegin(self):
        return _byteblower.FrameResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.FrameResultDataList_rend(self)

    def clear(self):
        return _byteblower.FrameResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.FrameResultDataList_swiginit(self, _byteblower.new_FrameResultDataList(*args))

    def push_back(self, x):
        return _byteblower.FrameResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.FrameResultDataList_front(self)

    def back(self):
        return _byteblower.FrameResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameResultDataList

# Register FrameResultDataList in _byteblower:
_byteblower.FrameResultDataList_swigregister(FrameResultDataList)

class FrameResultHistory(AbstractRefreshableResult):
    r"""

    Sender-side frame transmission result history.

    The history contains the sender information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :meth:`Refresh` is called

    A Frame history result object can be created via

    - Frame, using :meth:`.Frame.ResultHistoryGet`

    - FrameMobile, using :meth:`.FrameMobile.ResultHistoryGet`

    .. note:: See History result for more information

    .. versionadded:: 2.1.0

    Example

    Get the counters per *sampling interval* for the frame result history.

    .. code-block:: python
       :emphasize-lines: 1

        print(frameData.FrameResultHistory())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Removes the locally stored history snapshots.

        This can be used to save memory in long tests where the results are requested
        at regular intervals.

        .. warning:: Any interval or cumulative result object returned from this
                     history object before calling Clear will be destoyed and thus
                     become unusable.

        """
        return _byteblower.FrameResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Returns the duration of the interval used for the history snapshots.

        The returned duration is in nanoseconds

        :return: interval in nanoseconds used by the server

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.SamplingIntervalDurationGet())

        """
        return _byteblower.FrameResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. warning:: The previously collected historywill be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameHistory.SamplingIntervalDurationSet(1000)

        """
        return _byteblower.FrameResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Returns the number of the snapshots to keep in the history.

        :return: number of snapshots to keep in the history

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.SamplingBufferLengthGet())

        """
        return _byteblower.FrameResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inCount):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameHistory.SamplingBufferLengthSet(100)

        """
        return _byteblower.FrameResultHistory_SamplingBufferLengthSet(self, inCount)

    def CumulativeGet(self):
        r"""

        Returns a list of available accumulated results.

        :return: :class:`FrameResultDataList`

        Example

        This example gets the available accumulated results

        .. code-block:: python
           :emphasize-lines: 1

            historyList = frameHistory.CumulativeGet()

        """
        return _byteblower.FrameResultHistory_CumulativeGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: :class:`FrameResultDataList`

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGet().DescriptionGet())

        """
        return _byteblower.FrameResultHistory_IntervalGet(self)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameHistory.CumulativeLengthGet())

        """
        return _byteblower.FrameResultHistory_CumulativeLengthGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 2

            print(frameHistory.IntervalLengthGet())

        """
        return _byteblower.FrameResultHistory_IntervalLengthGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a list of available cumulative counters.

        :return: :class:`FrameResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 2

            print(frameHistory.CumulativeGetByIndex(0))

        """
        return _byteblower.FrameResultHistory_CumulativeGetByIndex(self, index)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a list of available interval counters.

        :return: :class:`FrameResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGetByIndex(0).DescriptionGet())



        """
        return _byteblower.FrameResultHistory_IntervalGetByIndex(self, index)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        :return: :class:`FrameResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(CumulativeGetByTime(timestamp))

        """
        return _byteblower.FrameResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :return: :class:`.FrameResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGetByTime(timestamp))

        """
        return _byteblower.FrameResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :return: :class:`FrameResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1


            print(frameHistory.CumulativeLatestGet())

        """
        return _byteblower.FrameResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :return: :class:`.FrameResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalLatestGet().DescriptionGet())

        """
        return _byteblower.FrameResultHistory_IntervalLatestGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the latest timestamp when the history was refreshed.

        :return:  Timestamp in nanoseconds (since epoch)

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.RefreshTimestampGet())

        """
        return _byteblower.FrameResultHistory_RefreshTimestampGet(self)

# Register FrameResultHistory in _byteblower:
_byteblower.FrameResultHistory_swigregister(FrameResultHistory)

class Frame(AbstractObject):
    r"""

    Class: Frame

    A ByteBlower Frame is an object representing a Frame which can be used in a
    :class:`Stream` for transmission by a ByteBlower Port.

    A Frame is used in stateless traffic testing. It will be sent by a
    ByteBlowerPort. For each Frame, different options can be enabled:

    1. Tagging

       - Sequence: Defines if a sequence number must be set. This is used for
         out-of-sequence detection.

       - Timestamping: Defines if the timestamp of transmission must be set in the
         frame. This is used for latency measurements.

    2. Checksumming

       - L3: IPv4/IPv6 automatic header checksumming.

       - L4: UDP/TCP automatic checksumming.

    3. Length field correction

       - L3: Automatic correction of the IPv4 length field. This is usefull when
         using a FrameSizeModifier.

       - L7: Automatic correction of the UDP/TCP length field. This is usefull
         when using a FrameSizeModifier.

    Also the frame can be modified during the test
    using modifiers:

    1. Field

       - Incremental: A field in the frame will be incremented every time the frame
         is sent out. The field's position and size is configurable.

       - Random: A field in the frame will be a random value every time the frame
         is sent out. The field's position and size is configurable.

    2. Size

       - GrowingSize: The frame will grow between a minimum and a maximum value.
         When the maximum value is reached, the frame resizes to the given minimum.

       - RandomSize: The frame will have a different size every time it is sent
         out. The sizes will be random between a given minimum and maximum size.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BytesSet(self, frameString):
        r"""

        A method which sets the content of a Frame in a hexadecimal format.

        This method will change the content of a Frame. A ByteBlower Frame is an
        Ethernet Frame excluding the four CRC bytes. The value can be in different
        formats, e.g.

        1. 0x01 0x02 0x03 0x04 0x05 ...

        2. 0001020304050607

        3. 00 01 02 03 04 05 ...

        .. note:: You can call this method even during transmission of a flow, the
                  value will be updated in real-time.

        :raises: ByteBlower.Exception.ConfigError - when the value does contain
                 non-hexadecimal characters or when the length is not even.

        :param bytes: Bytes can be of any of the formats mentioned above.
                      The length must be at least 60 bytes

        :raises: :exc:`.ConfigError` when the frame is too small (<60 bytes) or when
                 the frame is too big (>8192)

        Example

        .. code-block:: python
           :caption: Set the content for a frame

           # Layer2 (without CRC) size.
           frame_size = 1000  # bytes

           # Add a frame
           frame = stream.FrameAdd()

           # create some payload, we need scapy for that

           # frame_size is ethernet length, we substract the length of the
           # ethernet, IP and UDP header
           payload = 'a' * (frame_size - 42)

           from scapy.layers.inet import Raw
           scapy_udp_payload = Raw(payload.encode('ascii', 'strict'))

           payload_array = bytearray(bytes(scapy_udp_payload))

           # The API expects a 'str', so we need to make a string of the payload
           payload_str = ''.join((format(b, '02x') for b in payload_array)

           frame.BytesSet(payload_str)


        """
        return _byteblower.Frame_BytesSet(self, frameString)

    def BytesGet(self):
        r"""

        A method which returns the current content of a Frame in a hexadecimal format.

        This method will return the current content of a Frame. A ByteBlower Frame is an
        Ethernet Frame, excluding the frame check sequence ( aka CRC ).

        .. note:: The real content of a Frame can differ if Modifiers such as the
                  FrameSizeModifier are applied on the Flow containing this Frame.

        :return: This method returns the content in a hexadecimal string. All bytes are
                 concatenated into one string.

        Example

        The current content of a frame can be requested like this:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.BytesGet())

        """
        return _byteblower.Frame_BytesGet(self)

    def FrameTagTimeGet(self):
        r"""

        Returns the FrameTagTx object related to the timestamp injection for this frame.

        Each frame can be enabled to have a timestamp inserted into the frame.

        The :class:`FrameTagTx` object which is returned by this method represents the
        current configuration of the TimeTag injection. This object can be used to
        configure the TimeTag injection.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        .. versionadded:: 1.8.18

        :return: :class:`.FrameTagTx` object for TimeTag injection of this frame.

        Example

        In this example, we will retrieve the FrameTagTx object for the TimeTag:

        .. code-block:: python
           :emphasize-lines: 3

           print(frame.FrameTagTimeGet().DescriptionGet())

        """
        return _byteblower.Frame_FrameTagTimeGet(self)

    def FrameTagSequenceGet(self):
        r"""

        Returns the FrameTag.Tx object related to the sequence number injection for this frame.

        Each frame can be enabled to have a sequence number inserted into the frame.

        The :class:`.FrameTagTx` object which is returned by this method represents
        the current configuration of the SequenceTag injection. This object can be
        used to configure the SequenceTag injection.

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        .. versionadded:: 1.8.18

        :return: :class:`.FrameTagTx`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.FrameTagSequenceGet().DescriptionGet())


        """
        return _byteblower.Frame_FrameTagSequenceGet(self)

    def L3AutoChecksumEnable(self, value):
        r"""

        Enable or disable the automatic checksum calculation of the Layer3 header of this frame.

        This method provides the possibility to automatically recalculate the Layer3
        checksum. Currently, only IPv4 is supported ( IPv6 has no header checksum ).
        This calculation will be done at the server side, just before transmitting the
        frame.

        By default, the Layer3 checksum will not be calculated automatically.

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier or with a FrameTag. In such a
                  situation, the length or content of the Frame will change each time
                  the frame has been sent, so the checksum must be calculated at the
                  server side.

        Default value: Disabled

        :raises: ByteBlower.Exception.InvalidValue - when the value is not True or False

        :param enable: bool: True will enable the automatic Layer3 checksum
                       calculation. False will disable the automatic Layer3 checksum
                       calculation.

        Example

        This example will enable the automatic Layer3 checksum calculation:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L3AutoChecksumEnable(True)

        """
        return _byteblower.Frame_L3AutoChecksumEnable(self, value)

    def L3AutoChecksumGet(self):
        r"""

        Method returning the current configuration of the automatic checksum calculation option.

        This method returns the current configuration of the automatic Layer3 checksum
        calculation.

        See :meth:`.Frame.L3AutoChecksumEnable` on how to enable this feature.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the Layer3 automatic checksum calculation
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.L3AutoChecksumGet())

        """
        return _byteblower.Frame_L3AutoChecksumGet(self)

    def L3AutoLengthEnable(self, value):
        r"""

        Enable or disable the automatic Layer3 header length field calculation of this frame.

        This method provides the possibility to automatically recalculate the Layer3
        length field. This calculation will be done at the server side, just before
        transmitting the frame.

        Default value: Disabled

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the :class:`.FrameSizeModifier`. In such a situation,
                  the length of the Frame can change each time the frame has been sent,
                  so the length field must be adapted at the server side.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        :param enable: bool: True will enable the automatic Layer3 length field
                       adaption. False will disable the automatic Layer3 length field
                       adaption.

        Example

        This example will enable the automatic Layer3 length field adaption: This
        example will disable the automatic Layer3 length field adaption:

        .. code-block:: python
           :emphasize-lines: 1

        	frame.L3AutoLengthEnable(True)

        """
        return _byteblower.Frame_L3AutoLengthEnable(self, value)

    def L3AutoLengthGet(self):
        r"""

        Method returning the current configuration of the automatic Layer3 length field adaption option.

        This method returns the current configuration of the automatic Layer3 length
        field adaption.

        See :meth:`.Frame.L3AutoLengthEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer3 length field
        adaption option is enabled:

        .. code-block:: python
        	:emphasize-lines: 1

        	print(frame.L3AutoLengthGet())


        """
        return _byteblower.Frame_L3AutoLengthGet(self)

    def L4AutoChecksumEnable(self, value):
        r"""

        Enable or disable the automatic Layer4 checksum calculation of this frame.

        This method provides the possibility to automatically recalculate the Layer4
        (UDP or TCP) checksum. This calculation will be done at the server side, just
        before transmitting the frame.

        Default value: Disabled

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier or FrameTag. In such a situation,
                  the length or content of the Frame can change each time the frame has
                  been sent, so the checksum must be recalculated at the server side.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or false

        :param enable: bool: True will enable the automatic Layer4 checksum
                       calculation. False will enable the automatic Layer4 checksum
                       calculation.

        Example

        This example will enable the automatic Layer4 checksum calculation:  This
        example will disable the automatic Layer3 checksum calculation:

        .. code-block:: python
           :emphasize-lines: 1

        	frame.L4AutoChecksumEnable(True)


        """
        return _byteblower.Frame_L4AutoChecksumEnable(self, value)

    def L4AutoChecksumGet(self):
        r"""

        Method returning the current configuration of the automatic Layer4 checksum recalculation option.

        This method returns the current configuration of the automatic Layer4 checksum
        recalculation.

        See :meth:`.Frame.L4AutoChecksumEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer4 checksum recalculation
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.L4AutoChecksumGet()

        """
        return _byteblower.Frame_L4AutoChecksumGet(self)

    def L4AutoLengthEnable(self, value):
        r"""

        Enable or disable the automatic Layer4 header length field calculation of this frame.

        This method provides the possibility to automatically recalculate the Layer4
        (UDP or TCP) length field. This calculation will be done at the server side,
        just before transmitting the frame.

        Default value: Disabled

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier. In such a situation, the length
                  of the Frame can change each time the frame has been sent, so the
                  length field must be adapted at the server side.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        :param enable: bool: True will enable the automatic Layer4 length field
                       adaption.  False will enable the automatic Layer4 length field
                       adaption.

        Example

        This example will enable the automatic Layer4 length field adaption:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L4AutoLengthEnable(True)

        """
        return _byteblower.Frame_L4AutoLengthEnable(self, value)

    def L4AutoLengthGet(self):
        r"""

        Method returning the current configuration of the automatic Layer4 length field adaption option.

        This method returns the current configuration of the automatic Layer4 length
        field adaption.

        See :meth:`L4AutoLengthEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer4 length field adaption
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.L4AutoLengthGet())

        """
        return _byteblower.Frame_L4AutoLengthGet(self)

    def StreamGet(self):
        return _byteblower.Frame_StreamGet(self)

    def SetL3AutoChecksum(self, b):
        return _byteblower.Frame_SetL3AutoChecksum(self, b)

    def SetL3AutoLength(self, set):
        return _byteblower.Frame_SetL3AutoLength(self, set)

    def SetL4AutoChecksum(self, set):
        return _byteblower.Frame_SetL4AutoChecksum(self, set)

    def SetL4AutoLength(self, set):
        return _byteblower.Frame_SetL4AutoLength(self, set)

    def IsL3AutoChecksumEnabled(self):
        return _byteblower.Frame_IsL3AutoChecksumEnabled(self)

    def IsL3AutoLengthEnabled(self):
        return _byteblower.Frame_IsL3AutoLengthEnabled(self)

    def IsL4AutoChecksumEnabled(self):
        return _byteblower.Frame_IsL4AutoChecksumEnabled(self)

    def IsL4AutoLengthEnabled(self):
        return _byteblower.Frame_IsL4AutoLengthEnabled(self)

    def ModifierFieldIncrementalAdd(self):
        r"""

        Adds an incremental frame field modifier.

        .. versionadded:: 2.5.0

        :return:  :class:`FrameFieldModifierIncremental`

        Example

        This example adds an incremental value frame field modifier.

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierFieldIncrementalAdd()

        """
        return _byteblower.Frame_ModifierFieldIncrementalAdd(self)

    def ModifierFieldIncrementalGet(self):
        r"""

        Returns the active incremental frame field modifier(s).

        .. versionadded:: 2.5.0

        :return: :class:`FrameFieldModifierIncremental`

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.ModifierFieldIncrementalGet()[0].DescriptionGet())

        """
        return _byteblower.Frame_ModifierFieldIncrementalGet(self)

    def ModifierFieldIncrementalDestroy(self, inModifier):
        return _byteblower.Frame_ModifierFieldIncrementalDestroy(self, inModifier)

    def ModifierFieldRandomAdd(self):
        r"""

        Adds a random frame field modifier.

        .. versionadded:: 2.5.0

        :return: :class:`.FrameFieldModifierRandom`

        Example

        This example adds a random value frame field modifier.

        .. code-block:: python
           :emphasize-lines: 1

        	frameFieldModifierRandom = frame.ModifierFieldRandomAdd()

        """
        return _byteblower.Frame_ModifierFieldRandomAdd(self)

    def ModifierFieldRandomGet(self):
        r"""

        Returns the active random frame field modifier(s).

        .. versionadded:: 2.5.0

        :return: :class:`FrameFieldModifierRandom`

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierFieldRandomGet()[0].DescriptionGet())

        """
        return _byteblower.Frame_ModifierFieldRandomGet(self)

    def ModifierFieldRandomDestroy(self, inModifier):
        return _byteblower.Frame_ModifierFieldRandomDestroy(self, inModifier)

    def ModifierSizeGet(self):
        return _byteblower.Frame_ModifierSizeGet(self)

    def ModifierSizeGrowingSet(self):
        r"""

        Sets a growing frame size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`FrameSizeModifierGrowing`

        Example

        This example sets a growing size frame modifier.

        .. code-block:: python
           :emphasize-lines: 1

           growSizeMod = frame.ModifierSizeGrowingSet()


        """
        return _byteblower.Frame_ModifierSizeGrowingSet(self)

    def ModifierSizeRandomSet(self):
        r"""

        Sets a random frame size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`.FrameSizeModifierRandom`

        Example

        This example sets a random size frame modifier.

        .. code-block:: python
           :emphasize-lines: 1

        	frame.ModifierSizeRandomSet()

        """
        return _byteblower.Frame_ModifierSizeRandomSet(self)

    def ModifierSizeGrowingGet(self):
        r"""

        Returns the active frame growing size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`FrameSizeModifierGrowing`.

        Example

        This example gets the current applied growing size modifier

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.ModifierSizeGrowingGet().DescriptionGet())

        """
        return _byteblower.Frame_ModifierSizeGrowingGet(self)

    def ModifierSizeRandomGet(self):
        r"""

        Returns the active frame random size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`.FrameSizeModifierRandom`

        Example

        This example gets the current applied size modifier. E.g. the random

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierSizeRandomGet().DescriptionGet())

        """
        return _byteblower.Frame_ModifierSizeRandomGet(self)

    def ModifierSizeGrowingDestroy(self, arg2):
        return _byteblower.Frame_ModifierSizeGrowingDestroy(self, arg2)

    def ModifierSizeRandomDestroy(self, arg2):
        return _byteblower.Frame_ModifierSizeRandomDestroy(self, arg2)

    def ResultClear(self):
        r"""

        Resets the current transmit counters to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           frame.resultClear()

        """
        return _byteblower.Frame_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current transmit counters.

        :return: :class:`.FrameResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.ResultGet().DescriptionGet())

        """
        return _byteblower.Frame_ResultGet(self)

    def ResultHistoryGet(self):
        r"""



        """
        return _byteblower.Frame_ResultHistoryGet(self)

# Register Frame in _byteblower:
_byteblower.Frame_swigregister(Frame)

class FrameMobile(AbstractObject):
    r"""

    A FrameMobile is an object that configures the payload of a frame belonging to a StreamMobile object.

    A FrameMobile object is used for frame blasting. It is configured by a
    :class:`.StreamMobile` object and will be transmitted by the WirelessEndpoint.

    .. versionadded:: 2.6.0

    Example

    This example will show how to add a frame to a stream and configure the payload.

    .. code-block:: python
       :emphasize-lines: 3

    	frame = stream.FrameAdd()
    	frame_tag = frame.FrameTagTimeGet()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FrameTagTimeGet(self):
        r"""

        Returns the FrameTagTx object related to the timestamp injection for this frame.

        Each frame can be enabled to have a timestamp inserted into the frame.

        The :class:`.FrameTagTx` object which is returned by this method represents the
        current configuration of the TimeTag injection. This object can be used to
        configure the TimeTag injection.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: this requires extra resources, so this option must be used with
                     care.

        .. versionadded:: 2.6.0

        :return: :class:`.FrameTagTx`.

        Example

        In this example, we will retrieve the FrameTagTx object for the TimeTag:

        .. code-block:: python
           :emphasize-lines: 1

        	frame_tag = frame.FrameTagTimeGet()

        """
        return _byteblower.FrameMobile_FrameTagTimeGet(self)

    def PayloadSet(self, payloadString):
        r"""

        A method which sets the payload of a frame.

        This method will change the payload of the frame. The value can be in different
        formats, e.g.

        1.  0x01 0x02 0x03 0x04 0x05 ...

        2.  0001020304050607

        3.  00 01 02 03 04 05 ...

        :param bytes: Bytes can be of any of the above formats

        Example

        The content of a frame can be set like this:

        .. code-block:: python
           :emphasize-lines: 1

        	frame.PayloadSet('0001020304050607')

        """
        return _byteblower.FrameMobile_PayloadSet(self, payloadString)

    def PayloadGet(self):
        r"""

        A method which returns the payload of a frame.

        This method will return the UDP payload of the frame in a hexadecimal format.

        :return: This method returns the content in a hexadecimal string. All bytes are
                 concatenated into one string.

        Example

        The current content of a frame can be requested like this:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.PayloadGet())

        """
        return _byteblower.FrameMobile_PayloadGet(self)

    def StreamGet(self):
        return _byteblower.FrameMobile_StreamGet(self)

    def ResultClear(self):
        r"""

        Clears the transmit counters.

        This method will clear the transmit counters for this frame.

        .. code-block:: python
           :emphasize-lines: 1

        	frame.ResultClear()

        """
        return _byteblower.FrameMobile_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the transmit counters.

        :return: :class:`FrameResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ResultGet().DescriptionGet())

        """
        return _byteblower.FrameMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current transmit history counters.
        :return: an object representing the frame result history
        :rtype: :class:`.FrameResultHistory`

        """
        return _byteblower.FrameMobile_ResultHistoryGet(self)

# Register FrameMobile in _byteblower:
_byteblower.FrameMobile_swigregister(FrameMobile)

class FrameTag(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.FrameTag_TypeGet(self)

    def FormatGet(self):
        return _byteblower.FrameTag_FormatGet(self)

    def FormatStringGet(self):
        return _byteblower.FrameTag_FormatStringGet(self)

    def MetricsGet(self):
        return _byteblower.FrameTag_MetricsGet(self)

    def PositionGet(self):
        return _byteblower.FrameTag_PositionGet(self)

    def PositionSet(self, newPosition):
        return _byteblower.FrameTag_PositionSet(self, newPosition)

    def FormatDestroy(self):
        return _byteblower.FrameTag_FormatDestroy(self)

    def MetricsDestroy(self):
        return _byteblower.FrameTag_MetricsDestroy(self)

# Register FrameTag in _byteblower:
_byteblower.FrameTag_swigregister(FrameTag)

class FrameTagTx(FrameTag):
    r"""

    The FrameTagTx class describes the transmit configuration of a Tag in a Frame.

    ByteBlower supports optional tagging of frames. Such a tag can have different
    formats, locations, ...
    These parameters can be set and retrieved using this class.

    Currently, two different types of FrameTags are supported:

    SequenceTag
        is used for out of sequence detection and contains a frame counter value.
        The server automatically increments it for each frame sent in the stream.

    TimeTag
        is used for latency measurements and contains a timestamp value. The server
        automatically determines it by looking at its clock for each frame sent in
        the stream.

    Adding tags is a very powerful and flexible feature of ByteBlower. Please have
    a look at ByteBlower API Knowledgebase: Background: Adding FrameTags to your
    ByteBlower frame - structure and behaviour for a very detailed explanation.

    To perform latency measurements or out of sequence detection, configuration
    needs to be done both at TX and RX side:

    - At the TX side

      we need to add the FrameTag(s) to the Frame object.

    - At the RX side

      we need to create the appropriate receiver(s) on the incoming packets. This
      causes the server to read a tag from the received frames and interpret them
      (e.g. by calculating latency based on the timestamps).

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PositionGet(self):
        r"""

        The current configured location of the tag within the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            |                                                 |      Position
            |                                                 | <---------------------|
            +-------------------------------------------------+-----+-----------------+
            |                                                 | TAG |                 |
            +-------------------------------------------------+-----+-----------------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.

        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single
          frame!

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.

        Example

        This example will return the position of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            print(frameTagtx.PositionGet())

        """
        return _byteblower.FrameTagTx_PositionGet(self)

    def PositionSet(self, newPosition):
        r"""

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:
            |                                                 |        Position
            |                                                 | <---------------------|
            +-------------------------------------------------+-----------------------+
            |                                                 | TAG |                 |
            +-------------------------------------------------+-----------------------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            frameTagtx.PositionSet(9)

        """
        return _byteblower.FrameTagTx_PositionSet(self, newPosition)

    def Enable(self, set):
        r"""

        Method to enable the tag on the Frame.

        This will activate the tag on the Frame, and apply its configuration. As long
        as this method is not called, the tag will not be active.

        .. note:: the configuration of other enabled frames may change when this frame is
                  disabled.

        Default value: Disabled

        Example

        To enable the sequence tag on frame, one can do:

        .. code-block:: python
           :emphasize-lines: 1

            print(frameTagtx.Enable())

        """
        return _byteblower.FrameTagTx_Enable(self, set)

    def IsEnabled(self):
        r"""

        Method which will return whether a tag is activated or not.

        This method is used to retrieve the current state of the tag. If this tag is
        activated/enabled, true is returned. Otherwise, this method will return false.

        Default value: Disabled

        :return:  True if enabled, false if disabled.

        Example

        To see if a timestamp tag is enabled on a frame, this code can be used:

        .. code-block:: python
           :emphasize-lines: 2

        	frameTagtx = frame.FrameTagSequenceGet()
            print(frameTagtx.IsEnabled())

        """
        return _byteblower.FrameTagTx_IsEnabled(self)

    def PositionAutomaticSet(self):
        r"""

        This method will use the automatic position for
        the tag.

        ByteBlower is very flexible in positioning the tag, and the combination of
        different tags. If the position of the tag is not important, the automatic
        positioning of tags is the easiest way for the user.

        .. note:: The automatic position is used by default. This method is only useful
                  when you want to reset positions that were previously set by the user.

        Automatic placement of FrameTags has multiple advantages:

        1. it shields the API user from the complexity described above

        2. it makes sure the requirements are respected:

           the position will always be larger than the tag length and multiple tags
           will never overlap

        3. it places the tags as close towards the end as possible to allow tagging
           small frames without overwriting frame headers

        Tags are automatically placed at the end of the frame. If both Tags are enabled
        and have an automatic position, the SequenceTag is placed in front of the
        TimeTag.

        If a tag has an explicit position, this is always respected. The automatic
        position will adapt to it as follows:

        1. If there is enough place after the fixed tag to fit the automatic tag, the
           automatic tag is placed behind it (at the end of the frame).

        2. If there is not enough place after the fixed tag to fit the automatic tag,
           the automatic tag is placed right in front of the fixed tag.

        Default value: Enabled

        Example

        In this example, we will reset the position of the sequence tag to automatic.

        .. code-block:: python
           :emphasize-lines: 1

            frameTagtx.PositionAutomaticSet()

        """
        return _byteblower.FrameTagTx_PositionAutomaticSet(self)

# Register FrameTagTx in _byteblower:
_byteblower.FrameTagTx_swigregister(FrameTagTx)

class FrameTagFormat(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.FrameTagFormat_TypeGet(self)

    def TimeStampFormatGet(self):
        return _byteblower.FrameTagFormat_TimeStampFormatGet(self)

    def SequenceNumberFormatGet(self):
        return _byteblower.FrameTagFormat_SequenceNumberFormatGet(self)

    def FormatStringGet(self):
        return _byteblower.FrameTagFormat_FormatStringGet(self)

# Register FrameTagFormat in _byteblower:
_byteblower.FrameTagFormat_swigregister(FrameTagFormat)

class FrameTagMetrics(AbstractObject):
    r"""

    Class which represents the metrics of a FrameTag.

    The metrics of a tag are parameters describing the length and byte alignment of
    a frame.

    The metrics can only be read, because they are determined by the tag format and
    the server type.

    .. code-block:: python
       :emphasize-lines: 2

    	metric = frameTagtx.MetricsGet()
        print(metric.AlignmentGet())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LengthGet(self):
        r"""

        Returns the length of the tag.

        The number of bytes in a Frame that will be overwritten by this tag.

        .. note:: This byte range does not need to be contiguous! More specifically,
                  if the tag alignment is larger than one, a single byte containing
                  the offset to the aligned tag may be stored separately.

        :return: The length of the tag in bytes.

        Example

        This example shows the how to retrieve the length of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            print(metric.LengthGet())

        """
        return _byteblower.FrameTagMetrics_LengthGet(self)

    def AlignmentGet(self):
        r"""

        Returns the alignment value for this tag.

        Some frame tags must be aligned with the start of a frame. This means the tag
        must start at a multiple of *<x>* bytes within a frame, where *<x>* is the
        alignment value. The default value is one.

        Frame alignment requirements are caused by hardware limitations as a new tag
        must be included in every frame that is sent.

        :return: The alignment value of this tag.

        Example

        This example illustrates how the alingment value of a timestamp tag can be retrieved;

        .. code-block:: python
           :emphasize-lines: 1

            print(metric.AlignmentGet())

        """
        return _byteblower.FrameTagMetrics_AlignmentGet(self)

    def FrameTagGet(self):
        return _byteblower.FrameTagMetrics_FrameTagGet(self)

# Register FrameTagMetrics in _byteblower:
_byteblower.FrameTagMetrics_swigregister(FrameTagMetrics)

class FrameTagRx(FrameTag):
    r"""

    The FrameTagRx class describes the receive configuration of a Tag in a Frame.

    ByteBlower supports optional tagging of frames. Such a tag can have different
    formats, locations, ... These parameters can be set and retrieved using this
    class.

    Currently, two different types of FrameTags are supported:

    - Sequence Number: A tag which contains the sequence number within the stream.
    - Timestamp: A tag containing the timestamp this frame has left the transmit
      interface.

    Adding tags is a very powerful and flexible feature of ByteBlower. Please have
    a look at ByteBlower API Knowledgebase:
    Background: Adding FrameTags to your ByteBlower frame - structure and behaviour
    for a detailed explanation.

    This class is represents the :class:`.FrameTag` configuration at the receiving
    side of the flow.

    In typical situations this configuration must not be changed.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PositionGet(self):
        r"""

        Returns the current configured location of the tag within the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked
        for (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            |                                                               Position
            |                                                | <---------------------|
            +------------------------------------------------+----------------+------+
            |                                                | TAG            |      |
            +------------------------------------------------+----------------+------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.
        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single frame!

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.

        Example

        This example will return the position of a
        sequence tag:

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_PositionGet(self)

    def PositionSet(self, newPosition):
        r"""

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            |                                                               Position
            |                                                | <---------------------|
            +------------------------------------------------+---------------+-------+
            |                                                | TAG           |       |
            +------------------------------------------------+---------------+-------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        TODO


        """
        return _byteblower.FrameTagRx_PositionSet(self, newPosition)

    def FormatSet(self, fromFrameTagFormat):
        return _byteblower.FrameTagRx_FormatSet(self, fromFrameTagFormat)

    def FormatSetFromString(self, formatString):
        r"""

        Method to set the format by name.

        This method allows to set the format by name.

        See also: :meth:`.FrameTagRx.FormatStringGet` for details on the tag formats.

        :param format: This defines the format of the tag, the following format strings
                       are currently  supported:

                       TimeStamp-Microseconds_CRC Timestamp in microseconds followed by a
                       CRC. Not supported since 2.9.0
                       TimeStamp-10Nanoseconds Timestamp in nanoseconds.
                       SequenceNumber-0_CRC Sequence number followed by a CRC.

        Example

        In this example, we set the format of the timestamp to 10 nanoseconds.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_FormatSetFromString(self, formatString)

    def FormatDefaultSet(self):
        r"""

        Sets the format to the native, default format.

        This method sets the format to the default value.
        The default value depends on server type:

        For sequence tags, the default value is the same for all systems
        *<SequenceNumber-0_CRC>*.

        For time tags, the default value is *<TimeStamp-10Nanoseconds>*. However, on
        1000 series servers with a software version before 1.10.18, the
        *<TimeStamp-Microseconds_CRC>* format is used instead.

        :raises: ByteBlower.Rx.Counter.Unsupported -  The format string is a valid
                 value, but is not supported by the server.
        :raises: <python_error> - The format string is not a valid value.

        Example
        In this example, we restore the format of a sequence tag to the default format:

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_FormatDefaultSet(self)

    def MetricsSet(self, fromFrameTagMetrics):
        r"""

        Sets the metric of the tag.

        This method allows to copy the metrics of a FrameTagTx to the receive side of a flow.

        Note that it is often better to copy the complete TX tag configuration to the
        receive side of a flow. See :meth:`LatencyBasic.FrameTagSet` for an example.

        :param metrics: This parameter is an object of type :class:`.FrameTagMetrics` .

        Example

        This example demonstrates how you can set the metrics of a frame on the
        receiving object. The configuration is simply copied from the TX side.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_MetricsSet(self, fromFrameTagMetrics)

    def MetricsDefaultSet(self):
        r"""

        Sets the metrics to the default values.

        This method restores the metrics to the default value.

        Currently, both the sequence tag and time tag have metrics with an alignment of
        1 bytes and a size of 8 bytes on all servers types and versions.

        Example

        This example restores the default metrics of a sequence tag.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_MetricsDefaultSet(self)

    def PositionDefaultSet(self):
        r"""

        This restores the position to the default value.

        This method restores the default value for the position. By default, the tag is
        put at the end of the frame. This will restore the position of the receiving
        object to its default.

        Example

        This example restores the position of the sequence tag to the default value.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_PositionDefaultSet(self)

# Register FrameTagRx in _byteblower:
_byteblower.FrameTagRx_swigregister(FrameTagRx)

class Trigger(Rx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register Trigger in _byteblower:
_byteblower.Trigger_swigregister(Trigger)

class TriggerBasicResultSnapshot(AbstractRefreshableResult):
    r"""

    Receive-side trigger result set.  

    The result set contains the trigger information of since the object is created
     or refreshed.  

    .. note:: The information is not updated until :meth:`Refresh` is called  

    .. note:: See What's new in API v2 for more information.  

    A basic trigger result snapshot object can be created via a 
    :class:`.TriggerBasic`, using :meth:`.TriggerBasic.ResultGet`  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.  

    .. code-block:: python

    	result = trigger.ResultGet()
    	print(result.PacketCountGet())



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].  

        :return: Timestamp of snapshot in nanoseconds  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampGet())



        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :return: Timestamp of the first received packet in nanoseconds  

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampFirstGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the timestamp [NS] of the last packet in this snapshot.  

        Example

        This example gets the timestamp [NS] of the last received packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampLastGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.  

        :return:  received packets  

        Example

        This example gets the received packet counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.PacketCountGet())



        """
        return _byteblower.TriggerBasicResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.  

        :return:  received bytes  

        Example

        This example gets the received bytes counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.ByteCountGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.  

        :return: Largest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the largest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.FramesizeMaximumGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.  

        :return: Smallest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the smallest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.FramesizeMinimumGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.IntervalDurationGet())



        """
        return _byteblower.TriggerBasicResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        return _byteblower.TriggerBasicResultSnapshot_RefreshTimestampGet(self)

# Register TriggerBasicResultSnapshot in _byteblower:
_byteblower.TriggerBasicResultSnapshot_swigregister(TriggerBasicResultSnapshot)

class TriggerBasicResultData(AbstractObject):
    r"""

    Receive-side trigger result set.  

    The result set contains the trigger information of since the object is created
     or refreshed.

    .. note:: See What's new in API v2 for more information.  

    A basic trigger result data snapshot object can be created via a 
    :class:`.TriggerBasicResultHistory`, using 
    :meth:`.TriggerBasic.ResultHistoryGet`

    .. note:: The information is not updated until 
              :meth:`.TriggerBasicResultHistory.Refresh` is called  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or 
    destination port 67.  

    .. code-block:: python
       :emphasize-lines: 3

    	port = bbServer.PortCreate('trunk-1-2')
    	trigger = port.RxTriggerBasicAdd()
    	bpf_filter = 'udp port 67'
    	  trigger.FilterSet(bpf_filter)
    	historyResult = trigger.ResultHistoryGet()
    	resultData = historyResult.CumulativeLatestGet()



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.TimestampGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        Example

        This example gets the timestamp [NS] of the first received packet in this 
        snapshot 


        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult_Get.TimestampFirstGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        Example

        This example gets the timestamp [NS] of the last received packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           	print(dataResult_Get.TimestampLastGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.  

        Example

        This example gets the received packet counter  

        .. code-block:: python
           :emphasize-lines: 1

           	print(dataResult_Get.PacketCountGet())


        """
        return _byteblower.TriggerBasicResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.  

        Example

        This example gets the received bytes counter  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.ByteCountGet())


        """
        return _byteblower.TriggerBasicResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.  

        :return: Largest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the largest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.FramesizeMaximumGet())



        """
        return _byteblower.TriggerBasicResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.  

        :return: Smallest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the smallest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.FramesizeMinimumGet())


        """
        return _byteblower.TriggerBasicResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS] 

        .. code-block:: python
           :emphasize-lines: 1

           	print(dataResult_Get.IntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultData_IntervalDurationGet(self)

    def TypeGet(self):
        return _byteblower.TriggerBasicResultData_TypeGet(self)

# Register TriggerBasicResultData in _byteblower:
_byteblower.TriggerBasicResultData_swigregister(TriggerBasicResultData)

class TriggerBasicResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerBasicResultDataList_pop(self)

    def append(self, x):
        return _byteblower.TriggerBasicResultDataList_append(self, x)

    def empty(self):
        return _byteblower.TriggerBasicResultDataList_empty(self)

    def size(self):
        return _byteblower.TriggerBasicResultDataList_size(self)

    def swap(self, v):
        return _byteblower.TriggerBasicResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerBasicResultDataList_begin(self)

    def end(self):
        return _byteblower.TriggerBasicResultDataList_end(self)

    def rbegin(self):
        return _byteblower.TriggerBasicResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerBasicResultDataList_rend(self)

    def clear(self):
        return _byteblower.TriggerBasicResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerBasicResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerBasicResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerBasicResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TriggerBasicResultDataList_swiginit(self, _byteblower.new_TriggerBasicResultDataList(*args))

    def push_back(self, x):
        return _byteblower.TriggerBasicResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerBasicResultDataList_front(self)

    def back(self):
        return _byteblower.TriggerBasicResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerBasicResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerBasicResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerBasicResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerBasicResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerBasicResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerBasicResultDataList

# Register TriggerBasicResultDataList in _byteblower:
_byteblower.TriggerBasicResultDataList_swigregister(TriggerBasicResultDataList)

class TriggerBasicResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side trigger result history.  

    The history contains the trigger information in time since the object is 
    created or refreshed.  

    .. note:: The information is not updated until :meth:`Refresh` is called  

    .. note:: See History result for more information  

    A basic trigger history result object can be created via a 
    :class:`.TriggerBasic`, using :meth:`.TriggerBasic.ResultHistoryGet` 

    .. versionadded:: 2.1.0  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or 
    destination port 67.  

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.  

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can
        execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.  

        .. code-block:: python
           :emphasize-lines: 1

        	historyResult.Clear()


        """
        return _byteblower.TriggerBasicResultHistory_Clear(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`

        :return: :class:`.TriggerBasicResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGet()[0].DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.  

        :param index: index

        :return: :class:`.TriggerBasicResultData` cumulative counter object at the 
                 specified index 

        Example

        This example gets the available cumulative counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.  

        :return: The length of the cumulative list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.CumulativeLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeLengthGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.SamplingBufferLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.  

        :return: Duration in nanoseconds  

        Example

        .. code-block:: python
           :emphasize-lines: 1


        	print(historyResult.SamplingIntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.SamplingIntervalDurationSet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.   

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	historyResult.SamplingBufferLengthSet(10)


        """
        return _byteblower.TriggerBasicResultHistory_SamplingBufferLengthSet(self, inLength)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.  

        Each result object contains interval counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`    

        :return: :class:`.TriggerBasicResultDataList` containing the Interval counters 

        Example

        This example gets the available interval results  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.  

        :param index: index

        :return: :class:`.TriggerBasicResultData` interval counter object at the 
                 specified index

        Example

        This example gets the available interval counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.  

        :return: The length of the interval list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        return _byteblower.TriggerBasicResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.  

        :param timestamp: timestamp in nanoseconds  

        :return: :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.CumulativeGetByTime(1432805398000000000).DescriptionGet())



        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.  

        :param timestamp: timestamp in nanoseconds  

        :return: :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

        	interval = historyResult.IntervalGetByTime(1432805398000000000)


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.  

        :return:  :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Cumulative counter object  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.  

        :return: :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Interval counter object  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalLatestGet(self)

# Register TriggerBasicResultHistory in _byteblower:
_byteblower.TriggerBasicResultHistory_swigregister(TriggerBasicResultHistory)

class TriggerBasic(Trigger):
    r"""

    Receive-side packet processor which counts the incoming frames, matching a filter.

    This trigger is always active and starts counting frames as soon as it is
    created. Counting continues until the trigger is destructed.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              `meth``FilterSet` for filtering information.

    A basic trigger object can be created via a :class:`.ByteBlowerPort`, using
    :meth:`.ByteBlowerPort.RxTriggerBasicAdd`

    This trigger processes frames received on the ByteBlower interface where its
    parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python

    	port = bbServer.PortCreate('trunk-1-2')
    	trigger = port.RxTriggerBasicAdd()
    	bpf_filter = 'udp port 67'
    	trigger.FilterSet(bpf_filter)



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the current result counters.

        This method will return an object of :class:`.TriggerBasicResultSnapshot`.
        It will contain all the current Cumulative counters. To update the counters,
        call Refresh on :class:`.TriggerBasicResultSnapsho(`

        :return: The OID of the :class:`.TriggerBasicResultSnapshot` object.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 2

        	trigger = port.RxTriggerBasicAdd()
        	print(trigger.ResultGet().DescriptionGet())



        """
        return _byteblower.TriggerBasic_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        This method returns a :class:`.TriggerBasicResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time. Use this to create
        results over time.

        .. versionadded:: 2.1.0

        :return: :class:`.TriggerBasicResultHistory` object.

        Example

        .. code-block:: python
           :emphasize-lines: 2

        	trigger = port.RxTriggerBasicAdd()
        	print(trigger.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.TriggerBasic_ResultHistoryGet(self)

    def FilterSet(self, filter):
        r"""

        Sets a BPF filter on a RX object.

        ..note:: Configuring a new filter string does reset the counter values which
                 were triggered by a previous filter string. Also the earlier collected
                 history is invalidated.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation
                          for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.
        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.
        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:
        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 3

        	trigger = port.RxTriggerBasicAdd()
        	bpf_filter = 'ip dst 1.1.1.2 and udp port 4096'
        	trigger.FilterSet(bpf_filter)


        """
        return _byteblower.TriggerBasic_FilterSet(self, filter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `$ipv4_1` and `$ipv4_2` are :class:`IPv4Configuration` and
        `$frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 4

        	trigger = port.RxTriggerBasicAdd()
        	bpf_filter = 'ip dst 1.1.1.2 and udp port 4096'
        	trigger.FilterSet(bpf_filter)	
        	print(trigger.FilterGet())


        """
        return _byteblower.TriggerBasic_FilterGet(self)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 2

        	trigger = port.RxTriggerBasicAdd()
        	trigger.ResultClear()


        """
        return _byteblower.TriggerBasic_ResultClear(self)

# Register TriggerBasic in _byteblower:
_byteblower.TriggerBasic_swigregister(TriggerBasic)

class TriggerBasicMobile(Trigger):
    r"""

    Receive-side packet processor on a WirelessEndpoint that counts all incoming
    frames that match a filter.

    All triggers are started after calling :meth:`.WirelessEndpoint.Start` on the
    parent WirelessEndpoint object.

    A basic trigger object can be created by calling
    :meth:`.WirelessEndpoint:RxTriggerBasicAdd`

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the current result counters.

        This method will return an object of TriggerBasicResultSnapshot. It will
        contain all the current Cumulative counters. To update the counters, call
        :meth:`Refresh` on :class:`.TriggerBasicResultSnapshot`

        :return: :class:`.TriggerBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.ResultGet())



        """
        return _byteblower.TriggerBasicMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        This method returns a TriggerBasicResultHistory Object. This will contain the
        Cumulative and the Interval counters over time. Use this to create results over
        time.

        :return: :class:`.TriggerBasicResultHistory` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(triggerMobile.ResultHistoryGet())


        """
        return _byteblower.TriggerBasicMobile_ResultHistoryGet(self)

    def FilterSourceAddressGet(self):
        r"""

        Returns the source (source) address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.FilterSourceAddressGet())



        """
        return _byteblower.TriggerBasicMobile_FilterSourceAddressGet(self)

    def FilterSourceAddressSet(self, inAddress):
        r"""

        Sets the source (source) address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	ResultHistoryGet.FilterSourceAddressSet('1.1.1.1')


        """
        return _byteblower.TriggerBasicMobile_FilterSourceAddressSet(self, inAddress)

    def FilterUdpSourcePortGet(self):
        r"""

        Returns the source (source) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.FilterUdpSourcePortGet())



        """
        return _byteblower.TriggerBasicMobile_FilterUdpSourcePortGet(self)

    def FilterUdpSourcePortSet(self, inPort):
        r"""

        Sets the source (source) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1
        1
           triggerMobile.FilterUdpSourcePortSet(4096)



        """
        return _byteblower.TriggerBasicMobile_FilterUdpSourcePortSet(self, inPort)

    def FilterUdpDestinationPortGet(self):
        r"""

        Returns the destination (destination) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.FilterUdpDestinationPortGet())



        """
        return _byteblower.TriggerBasicMobile_FilterUdpDestinationPortGet(self)

    def FilterUdpDestinationPortSet(self, inPort):
        r"""

        Sets the destination (destination) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           triggerMobile.FilterUdpDestinationPortSet(4096)


        """
        return _byteblower.TriggerBasicMobile_FilterUdpDestinationPortSet(self, inPort)

    def DurationGet(self):
        r"""

        Returns the duration for which the trigger will be active.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.DurationGet())


        """
        return _byteblower.TriggerBasicMobile_DurationGet(self)

    def DurationSet(self, inDuration):
        r"""

        Sets the duration for which the trigger will be active.

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	triggerMobile.DurationSet(10000)



        """
        return _byteblower.TriggerBasicMobile_DurationSet(self, inDuration)

    def FilterGet(self):
        return _byteblower.TriggerBasicMobile_FilterGet(self)

    def FilterSet(self, arg2):
        return _byteblower.TriggerBasicMobile_FilterSet(self, arg2)

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	ResultHistoryGet.ResultClear()


        """
        return _byteblower.TriggerBasicMobile_ResultClear(self)

# Register TriggerBasicMobile in _byteblower:
_byteblower.TriggerBasicMobile_swigregister(TriggerBasicMobile)

class TriggerSizeDistributionResultSnapshot(AbstractRefreshableResult):
    r"""

    Contains the results for the size distribution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.TimestampGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first received packet.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.TimestampFirstGet())

        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last received packet.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.TimestampLastGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampLastGet(self)

    def ByteCountGet(self):
        r"""

        Gets the number of received bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.ByteCountGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        :return: Largest received frame size in bytes of this snapshot

        .. versionadded:: 2.5.0

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.FramesizeMaximumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        :return: Smallest received frame size in bytes of this snapshot

        .. versionadded:: 2.5.0

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.FramesizeMinimumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountGet(self, *args):
        r"""

        Gets the number received packets. Or if provided with a size, the number of
        packets received of that size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.PacketCountGet())


        Gets the number received packets. Or if provided with a size, the number of
        packets received of that size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.PacketCountGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountGet(self, *args)

    def PacketCountBelowMinimumGet(self):
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        r"""

        Gets number of received packets in this snapshot that are too big.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.PacketCountAboveMaximumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountAboveMaximumGet(self)

    def RefreshTimestampGet(self):
        r"""



        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_RefreshTimestampGet(self)

# Register TriggerSizeDistributionResultSnapshot in _byteblower:
_byteblower.TriggerSizeDistributionResultSnapshot_swigregister(TriggerSizeDistributionResultSnapshot)

class TriggerSizeDistribution(Trigger):
    r"""

    Receive-side packet processor which counts the incoming frames, frame rate and
    frames per size, matching a filter.

    The size distribution trigger extends the basic trigger. It provides additional
    information like total number of bytes and frame rate. See :meth:`ResultGet`
    for more information.

    This trigger is always active and starts counting frames as soon as it is
    created. Counting continues until the trigger is destructed.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for filtering information.

    A size distribution trigger object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxTriggerSizeDistributionAdd`

    This trigger processes frames received on the ByteBlower interface where its
    parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 49576.

    .. code-block:: python

    	trig = port.RxTriggerSizeDistributionAdd()
    	trig.FilterSet('ip && dst port 49576')
    	...
    	print(trig.ResultGet().DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the :class:`.TriggerSizeDistributionResultSnapshot` for this trigger
        containing the current result counters.

        The snapshot contains byte counters and time values.

        :return: :class:`.TriggerSizeDistributionResultSnapshot`

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trig.ResultGet().DescriptionGet())


        """
        return _byteblower.TriggerSizeDistribution_ResultGet(self)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trig.ResultClear()


        """
        return _byteblower.TriggerSizeDistribution_ResultClear(self)

    def FilterSet(self, inFilter):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does not reset the counter values
                  which were triggered by a previous filter string.

        :param bpfstring: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        .. code-block:: python
        	:emphasize-lines: 3

        	trig = port.RxTriggerSizeDistributionAdd()
        	# lets assume traffic is sent to UDP port 9000
        	trig.FilterSet('ip && dst port 9000')

        This will filter only UDP traffic.  Set the filter on packets that match:
        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)


        """
        return _byteblower.TriggerSizeDistribution_FilterSet(self, inFilter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 2

           trig.FilterSet('ip && dst port 9000')
           print(trig.FilterGet())


        """
        return _byteblower.TriggerSizeDistribution_FilterGet(self)

# Register TriggerSizeDistribution in _byteblower:
_byteblower.TriggerSizeDistribution_swigregister(TriggerSizeDistribution)

class OutOfSequenceResultSnapshot(AbstractRefreshableResult):
    r"""

    Refreshable object containing the out-of-sequence results.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceResult.TimestampGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.TimestampFirstGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.TimestampLastGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.ByteCountGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

         	print(outOfSequenceResult.FramesizeMaximumGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.FramesizeMinimumGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountOutOfSequenceGet(self):
        r"""

        Gets the received packet count which were out of sequence.

        Example

        This example gets the received out of sequence packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountOutOfSequenceGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountOutOfSequenceGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count for packets which were not corrupted.

        Example

        This example gets the valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountValidGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count for the invalid/corrupted packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountInvalidGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountInvalidGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

         	print(outOfSequenceResult.IntervalDurationGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceResult.RefreshTimestampGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_RefreshTimestampGet(self)

# Register OutOfSequenceResultSnapshot in _byteblower:
_byteblower.OutOfSequenceResultSnapshot_swigregister(OutOfSequenceResultSnapshot)

class OutOfSequenceResultData(AbstractObject):
    r"""

    Non-refreshable object containing the out-of-sequence results.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.TimestampGet())



        """
        return _byteblower.OutOfSequenceResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.TimestampFirstGet())



        """
        return _byteblower.OutOfSequenceResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountGet())


        """
        return _byteblower.OutOfSequenceResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           	print(outOfSequenceresultData.PacketCountGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.ByteCountGet())



        """
        return _byteblower.OutOfSequenceResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.FramesizeMaximumGet())



        """
        return _byteblower.OutOfSequenceResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        :return:

        .. versionadded:: 2.6.4

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.FramesizeMinimumGet())



        """
        return _byteblower.OutOfSequenceResultData_FramesizeMinimumGet(self)

    def PacketCountOutOfSequenceGet(self):
        r"""

        Gets the received packet count which were out of sequence.

        Example

        This example gets the received out of sequence packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountOutOfSequenceGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountOutOfSequenceGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count which for packets which were not corrupted.

        Example

        This example gets the valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountValidGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count for the invalid/corrupted packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountInvalidGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountInvalidGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceresultData.IntervalDurationGet())



        """
        return _byteblower.OutOfSequenceResultData_IntervalDurationGet(self)

# Register OutOfSequenceResultData in _byteblower:
_byteblower.OutOfSequenceResultData_swigregister(OutOfSequenceResultData)

class OutOfSequenceResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.OutOfSequenceResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.OutOfSequenceResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.OutOfSequenceResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.OutOfSequenceResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.OutOfSequenceResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.OutOfSequenceResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.OutOfSequenceResultDataList_pop(self)

    def append(self, x):
        return _byteblower.OutOfSequenceResultDataList_append(self, x)

    def empty(self):
        return _byteblower.OutOfSequenceResultDataList_empty(self)

    def size(self):
        return _byteblower.OutOfSequenceResultDataList_size(self)

    def swap(self, v):
        return _byteblower.OutOfSequenceResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.OutOfSequenceResultDataList_begin(self)

    def end(self):
        return _byteblower.OutOfSequenceResultDataList_end(self)

    def rbegin(self):
        return _byteblower.OutOfSequenceResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.OutOfSequenceResultDataList_rend(self)

    def clear(self):
        return _byteblower.OutOfSequenceResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.OutOfSequenceResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.OutOfSequenceResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.OutOfSequenceResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.OutOfSequenceResultDataList_swiginit(self, _byteblower.new_OutOfSequenceResultDataList(*args))

    def push_back(self, x):
        return _byteblower.OutOfSequenceResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.OutOfSequenceResultDataList_front(self)

    def back(self):
        return _byteblower.OutOfSequenceResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.OutOfSequenceResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.OutOfSequenceResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.OutOfSequenceResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.OutOfSequenceResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.OutOfSequenceResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_OutOfSequenceResultDataList

# Register OutOfSequenceResultDataList in _byteblower:
_byteblower.OutOfSequenceResultDataList_swigregister(OutOfSequenceResultDataList)

class OutOfSequenceResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side out-of-sequence result history.

    ..note:: The information is not updated until :meth:`Refresh` is called

    ..note:: See History result for more information

    A OutOfSequence history result object can be created via a
    :class:`OutOfSequence`, using :meth:`.OutOfSequence.ResultHistoryGet`

    .. versionadded:: 2.1.0

    Example

    Receive all frames and check sequence on "trunk-1-2" of some server, matching
    UDP source or destination port 67.

    .. code-block:: python
       :emphasize-lines: 3

       outOfSequence_trigger = port.RxOutOfSequenceBasicAdd()
       outOfSequence_trigger.FilterSet('udp port 4096')
       #...
       outOfSequenceHistoryResult= outOfSequence_trigger.ResultHistoryGet()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.

        With each :meth:`Refresh` interval and cumulative counters are transferred
        from Server to the Client. To remove all counter-objects in this history, you
        can execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

        	outOfSequenceHistoryResult.Clear()


        """
        return _byteblower.OutOfSequenceResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.SamplingIntervalDurationGet())



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.SamplingBufferLengthGet())



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. warning:: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.SamplingIntervalDurationSet(1000000000))



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	outOfSequenceHistoryResult.SamplingBufferLengthGet(6)



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingBufferLengthSet(self, inLength)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.OutOfSequenceResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.CumulativeGet()[0].DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: :class:`.OutOfSequenceResultData`

        Example
        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.CumulativeGetByIndex(0).DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return: The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.CumulativeLengthGet())



        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.OutOfSquenceResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1ouo

        	print(outOfSequenceHistoryResult.IntervalGet()[0].DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index

        :return: :class:`.OutOfSequenceResultData` interval counter object at the
                 specified index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.IntervalGetByIndex(0).DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.IntervalLengthGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.

        This is the timestamp on the server when the last :meth:`Refresh` was called.

        :return: Timestamp in nanoseconds since epoch

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.RefreshTimestampGet())



        """
        return _byteblower.OutOfSequenceResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.

        :param timestamp: timestamp in nanoseconds

        :return: :class:`.OutOfSequenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeGetByTime(1432805398000000000).DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.

        :param timestamp: timestamp in nanoseconds

        :return: :class:`.OutOfSequenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

        	interval = outOfSequenceHistoryResult.IntervalGetByTime(1432805398000000000)



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :return: :class:`OutOfSequenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :return: :class:`.OutOfSquenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceHistoryResult.IntervalLatestGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalLatestGet(self)

# Register OutOfSequenceResultHistory in _byteblower:
_byteblower.OutOfSequenceResultHistory_swigregister(OutOfSequenceResultHistory)

class OutOfSequence(TaggedRx):
    r"""

    Receive-side packet processor which checks out-of-sequence on the incoming frames, matching a filter.

    This out-of-sequence detection is always active and starts processing frames as
    soon as it is created. Processing continues until the packet processor is
    destructed.

    The sequence number of a packet is obtained from an out-of-sequence tag in the
    frame. This tag is configured on the :class:`FrameTagTx`, which can be obtained
    via :meth:`.Frame.FrameTagSequenceGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for filtering information.

    A basic out-of-sequence object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxOutOfSequenceBasicAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-33" of some server, matching UDP source or
    destination port 123.

    .. code-block:: python
       :emphasize-lines: 3

       outOfSequence_trigger = port.RxOutOfSequenceBasicAdd()
       outOfSequence_trigger.FilterSet('udp port 4096')


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory = outOfSequence_trigger.ResultClear()



        """
        return _byteblower.OutOfSequence_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current accumulated trigger results.

        :return: :class:`OutOfSequenceBasicResultSnapshot` - The resultSnapshot is
                 returned containing the accumulated trigger counters.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           	print(outOfSequence_trigger.ResultGet().DescriptionGet())



        """
        return _byteblower.OutOfSequence_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the history of the results.

        :return: The :class:`OutOfSequenceResultHistory` is returned containing the
                 accumulated and interval trigger counters of the last 5 seconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory = outOfSequence_trigger.ResultHistoryGet()



        """
        return _byteblower.OutOfSequence_ResultHistoryGet(self)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequence_trigger.FilterGet())


        """
        return _byteblower.OutOfSequence_FilterGet(self)

    def FilterSet(self, arg2):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier
                  collected history is invalidated.

        :param bpfstring: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more
                          information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

        	outOfSequence_trigger.FilterSet('ip dst 1.1.1.1 and udp port 4096')



        """
        return _byteblower.OutOfSequence_FilterSet(self, arg2)

# Register OutOfSequence in _byteblower:
_byteblower.OutOfSequence_swigregister(OutOfSequence)

class Latency(TaggedRx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register Latency in _byteblower:
_byteblower.Latency_swigregister(Latency)

class LatencyBasicResultSnapshot(AbstractRefreshableResult):
    r"""

    Receive-side latency result set.

    The result set contains the latency information of since the object is created
    or refreshed.

    ..note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See What's new in API v2 for more information.

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultGet`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or destination
    port 67.

    .. code-block:: python

    	latencyTrigger = port.RxLatencyBasicAdd()
    	latency_result = latencyTrigger.ResultGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.TimestampGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.TimestampFirstGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.TimestampLastGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.PacketCountGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.ByteCountGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.FramesizeMaximumGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.FramesizeMaximumGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 3

           	print(latency_result.PacketCountValidGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.PacketCountInvalidGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.LatencyMinimumGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.LatencyMaximumGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.LatencyAverageGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        The jitter is defined as the standard deviation of the measured latency.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.JitterGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_JitterGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.IntervalDurationGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        Example

        .. code-block:: python
           :emphasize-lines: 3

           	print(latency_result.RefreshTimestampGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_RefreshTimestampGet(self)

# Register LatencyBasicResultSnapshot in _byteblower:
_byteblower.LatencyBasicResultSnapshot_swigregister(LatencyBasicResultSnapshot)

class LatencyBasicResultData(AbstractObject):
    r"""

    Receive-side latency result set.

    The result set contains the latency information of since the object is created
    or refreshed.

    .. note:: See What's new in API v2 for more information.

    A basic trigger result data snapshot object can be created via a
    :class:`.LatencyBasicResultHistory`, using
    :meth:`.LatencyBasic.ResultHistoryGet`

    .. note:: The information is not updated until
              :meth:`.LatencyBasicResultHistory.Refresh` is called.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       latencyTrigger = port.RxLatencyBasicAdd()
       latencyTrigger.FilterSet('udp port 67')
       #...
       latencyResultData = latencyTrigger.ResultHistoryGet().CumulativeLatestGet()



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(latencyResultData.TimestampGet())



        """
        return _byteblower.LatencyBasicResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable: When no frames are received, this counter is
                                     unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.TimestampFirstGet())



        """
        return _byteblower.LatencyBasicResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable: When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.TimestampLastGet())



        """
        return _byteblower.LatencyBasicResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.PacketCountGet())



        """
        return _byteblower.LatencyBasicResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.ByteCountGet())



        """
        return _byteblower.LatencyBasicResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.FramesizeMaximumGet())



        """
        return _byteblower.LatencyBasicResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.FramesizeMinimumGet())



        """
        return _byteblower.LatencyBasicResultData_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.PacketCountValidGet())



        """
        return _byteblower.LatencyBasicResultData_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.PacketCountInvalidGet())



        """
        return _byteblower.LatencyBasicResultData_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.LatencyMinimumGet())


        """
        return _byteblower.LatencyBasicResultData_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.LatencyMaximumGet())



        """
        return _byteblower.LatencyBasicResultData_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.LatencyAverageGet())



        """
        return _byteblower.LatencyBasicResultData_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.JitterGet())



        """
        return _byteblower.LatencyBasicResultData_JitterGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyResultData.IntervalDurationGet())



        """
        return _byteblower.LatencyBasicResultData_IntervalDurationGet(self)

# Register LatencyBasicResultData in _byteblower:
_byteblower.LatencyBasicResultData_swigregister(LatencyBasicResultData)

class LatencyBasicResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicResultDataList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicResultDataList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicResultDataList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicResultDataList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicResultDataList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicResultDataList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicResultDataList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyBasicResultDataList_swiginit(self, _byteblower.new_LatencyBasicResultDataList(*args))

    def push_back(self, x):
        return _byteblower.LatencyBasicResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicResultDataList_front(self)

    def back(self):
        return _byteblower.LatencyBasicResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicResultDataList

# Register LatencyBasicResultDataList in _byteblower:
_byteblower.LatencyBasicResultDataList_swigregister(LatencyBasicResultDataList)

class LatencyBasicResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side latency result history.

    The history contains the latency information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See History result for more information

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultHistoryGet`

    .. versionadded:: 2.1.0

    Example

    Receive all frames on "trunk-1-2" of some server

    .. code-block:: python

    	latencyTrigger = port.RxLatencyBasicAdd()
    	latency_historyResult.latencyTrigger.ResultHistoryGet()



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can
        execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

        	latency_historyResult.Clear()



        """
        return _byteblower.LatencyBasicResultHistory_Clear(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.LatencyBasicResultDataList`

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

        	counterList = latency_historyResult.CumulativeGet()



        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index

        :return: :class:`.LatencyBasicResultData` cumulative counter object at the
                 specified index

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.CumulativeGetByIndex(0)


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.CumulativeLengthGet())


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeLengthGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.SamplingIntervalDurationGet())



        """
        return _byteblower.LatencyBasicResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.SamplingBufferLengthGet())



        """
        return _byteblower.LatencyBasicResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. warning :: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latency_historyResult.SamplingIntervalDurationSet(1000000000)



        """
        return _byteblower.LatencyBasicResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultData = latency_historyResult.SamplingBufferLengthSet(6)


        """
        return _byteblower.LatencyBasicResultHistory_SamplingBufferLengthSet(self, inLength)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.LatencyBasicResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 3

        	listInterval = latency_historyResult.IntervalGet()


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index

        :return: :class:`.LatencyBasicResultData` interval counter object at the
                 specified index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	latencyData = latency_historyResult.IntervalGetByIndex(0)


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.IntervalLengthGet())



        """
        return _byteblower.LatencyBasicResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.

        This is the timestamp on the server when the last :meth:`Refresh` was called.

        :return: Timestamp in nanoseconds since epoch

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.RefreshTimestampGet())



        """
        return _byteblower.LatencyBasicResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.

        :param timestamp: timestamp  in nanoseconds

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 3

           result_data = latency_historyResult.CumulativeGetByTime(timestamp)


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.

        :param timestamp: timestamp in nanoseconds

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

        	interval = latency_historyResult.IntervalGetByTime(timestamp)



        """
        return _byteblower.LatencyBasicResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 3

        	resultData = latency_historyResult.CumulativeLatestGet()


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 1

        	Interval = latency_historyResult.IntervalLatestGet()


        """
        return _byteblower.LatencyBasicResultHistory_IntervalLatestGet(self)

# Register LatencyBasicResultHistory in _byteblower:
_byteblower.LatencyBasicResultHistory_swigregister(LatencyBasicResultHistory)

class LatencyBasic(Latency):
    r"""

    Receive-side packet processor which calculates latency on the incoming frames,
    matching a filter.

    The basic latency processor extends the basic trigger. It provides additional
    information like latency and jitter. See :meth:`ResultGet` for more
    information.

    This latency calculation is always active and starts processing frames as soon
    as it is created. Processing continues until the packet processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the :class:`.FrameTagTx`, which can be obtained via
    :meth:`.Frame.FrameTagTimeGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for     filtering information.

    A basic latency object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxLatencyBasicAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 3

    	latencyTrigger = port.RxLatencyBasicAdd()
    	latencyTrigger.FilterSet('ip dst 1.1.1.2 and udp port 4096')


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyTrigger.ResultClear()


        """
        return _byteblower.LatencyBasic_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: :class:`.LatencyBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result = latencyTrigger.ResultGet()



        """
        return _byteblower.LatencyBasic_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current trigger history counters.

        :return: :class:`.LatencyBasicResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory = latencyTrigger.ResultHistoryGet()


        """
        return _byteblower.LatencyBasic_ResultHistoryGet(self)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyTrigger.FilterGet())



        """
        return _byteblower.LatencyBasic_FilterGet(self)

    def FilterSet(self, arg2):
        r"""

        Sets a BPF filter on a RX object.

        ..note:: Configuring a new filter string does reset the counter values which
                 were triggered by a previous filter string. Also the earlier collected
                 history is invalidated.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 3

        	latencyTrigger.FilterSet('ip dst 1.1.1.2 and udp port 4096')



        """
        return _byteblower.LatencyBasic_FilterSet(self, arg2)

# Register LatencyBasic in _byteblower:
_byteblower.LatencyBasic_swigregister(LatencyBasic)

class LatencyBasicMobile(Latency):
    r"""

    Receive-side packet processor which calculates latency on the incoming frames,
    matching a filter.

    .. versionadded:: 2.6.0

    The basic latency processor extends the basic trigger. It provides additional
    information like latency and jitter. See :meth:`ResultGet` for more
    information.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the :class:`FrameTagTx`, which can be obtained via
    :meth:`.Frame.FrameTagTimeGet`.

    A basic latency object can be created via a WirelessEndpoint, using
    :meth:`.WirelessEndpoint.RxLatencyBasicAdd`

    Example

    .. code-block:: python
       :emphasize-lines: 1

    	latencyTrigger = wirelessEndpoint.RxLatencyBasicAdd()
    	latencyTrigger.FilterUdpSourcePortSet(4096)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.ResultClear()

        """
        return _byteblower.LatencyBasicMobile_ResultClear(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        This method returns a :class:`.LatencyBasicResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time. Use this to create
        results over time.

        :return: :class:`.LatencyBasicResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory = latencyMobileTrigger.ResultHistoryGet()

        """
        return _byteblower.LatencyBasicMobile_ResultHistoryGet(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        This method will return an object of :class:`LatencyBasicResultSnapshot`.
        It will contain all the current Cumulative counters. To update the counters,
        call :meth:`LatencyBasicResultSnapthost.Refresh` on
        :class:`LatencyBasicResultSnapshot`

        :return: :class:`LatencyBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	latencyMobileTrigger.ResultGet()


        """
        return _byteblower.LatencyBasicMobile_ResultGet(self)

    def FilterSourceAddressGet(self):
        r"""

        Returns the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterSourceAddressGet())


        """
        return _byteblower.LatencyBasicMobile_FilterSourceAddressGet(self)

    def FilterSourceAddressSet(self, inAddress):
        r"""

        Sets the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterSourceAddressSet('10.8.1.2')


        """
        return _byteblower.LatencyBasicMobile_FilterSourceAddressSet(self, inAddress)

    def FilterUdpSourcePortGet(self):
        r"""

        Returns the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterUdpSourcePortGet())



        """
        return _byteblower.LatencyBasicMobile_FilterUdpSourcePortGet(self)

    def FilterUdpSourcePortSet(self, inPort):
        r"""

        Sets the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterUdpSourcePortSet(4096)


        """
        return _byteblower.LatencyBasicMobile_FilterUdpSourcePortSet(self, inPort)

    def FilterUdpDestinationPortGet(self):
        r"""

        Returns the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterUdpDestinationPortGet())

        """
        return _byteblower.LatencyBasicMobile_FilterUdpDestinationPortGet(self)

    def FilterUdpDestinationPortSet(self, inPort):
        r"""

        Sets the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterUdpDestinationPortSet(4096)



        """
        return _byteblower.LatencyBasicMobile_FilterUdpDestinationPortSet(self, inPort)

    def DurationGet(self):
        r"""

        Returns the duration for which the trigger will be active.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.DurationGet())

        """
        return _byteblower.LatencyBasicMobile_DurationGet(self)

    def DurationSet(self, inDuration):
        r"""

        Sets the duration for which the trigger will be active.

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.DurationSet(10*1000000000)

        """
        return _byteblower.LatencyBasicMobile_DurationSet(self, inDuration)

    def FilterGet(self):
        return _byteblower.LatencyBasicMobile_FilterGet(self)

    def FilterSet(self, arg2):
        return _byteblower.LatencyBasicMobile_FilterSet(self, arg2)

# Register LatencyBasicMobile in _byteblower:
_byteblower.LatencyBasicMobile_swigregister(LatencyBasicMobile)

class LatencyDistributionResultSnapshot(AbstractRefreshableResult):
    r"""

    The latency distribution result.

    .. note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See What's new in API v2 for more information.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.TimestampGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in
        this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.TimestampFirstGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.TimestampLastGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.ByteCountGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size received in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.FramesizeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""


        Function: FramesizeMinimumGet

        Gets the smallest frame size received in this
        snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyDistributionSnapshot.FramesizeMinimumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountValidGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyDistributionSnapshot.PacketCountInvalidGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.LatencyMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.LatencyMaximumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.LatencyAverageGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.JitterGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_JitterGet(self)

    def RangeMinimumGet(self):
        r"""

        Returns the inclusive minimum of the range configured.

        :return: The lower bound of the configured range on the
                 :class:`.LatencyDistribution` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RangeMinimumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        r"""

        Returns the exclusive maximum of the range configured.

        :return: The lower bound of the configured range on the
                 :class:`.LatencyDistribution` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.RangeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_RangeMaximumGet(self)

    def BucketWidthGet(self):
        r"""

        Returns the width in nanoseconds of a bucket.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyDistributionSnapshot.BucketWidthGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_BucketWidthGet(self)

    def BucketCountGet(self):
        r"""

        Returns the number of buckets in which the range is divided.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.BucketCountGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_BucketCountGet(self)

    def PacketCountBelowMinimumGet(self):
        r"""

        Returns the number of packets arrived with a latency below the given range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountBelowMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        r"""

        Returns the number of packets arrived with a latency above the given range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountAboveMaximumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountAboveMaximumGet(self)

    def PacketCountBucketsGet(self):
        r"""

        Returns the number of packets received per bucket.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountBucketsGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountBucketsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        ..note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.RefreshTimestampGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_RefreshTimestampGet(self)

# Register LatencyDistributionResultSnapshot in _byteblower:
_byteblower.LatencyDistributionResultSnapshot_swigregister(LatencyDistributionResultSnapshot)

class LatencyDistribution(Latency):
    r"""

    Receive-side packet processor which calculates distribution of latency on the
    incoming frames, matching a filter.

    This latency distribution calculation is always active and starts processing
    frames as soon as it is created. Processing continues until the packet
    processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the FrameTag.Tx, which can be obtained via
    :meth:.Frame.FrameTagTimeGet`.

    ..note:: The initial (empty) filter string accepts all incoming frames.
    See :meth:`FilterSet` for filtering information.

    A latency distribution object can be created via a :class:`.ByteBlowerPort`,
    using :meth:`.ByteBlowerPort.RxLatencyDistributionAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: :class:`.LatencyDistributionResultSnapshot` result object

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyDistributionSnapshot = distributionTrigger.ResultGet()



        """
        return _byteblower.LatencyDistribution_ResultGet(self)

    def BucketCountGet(self):
        return _byteblower.LatencyDistribution_BucketCountGet(self)

    def BucketWidthGet(self):
        return _byteblower.LatencyDistribution_BucketWidthGet(self)

    def RangeGet(self):
        r"""

        Returns the current configured range for the latency distribution.

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

        	print(distributionTrigger.RangeGet())


        """
        return _byteblower.LatencyDistribution_RangeGet(self)

    def RangeMinimumGet(self):
        return _byteblower.LatencyDistribution_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        return _byteblower.LatencyDistribution_RangeMaximumGet(self)

    def RangeSet(self, rangeStartNs, rangeEndNs):
        r"""

        Configures the range for which the Latency Distribution will measure the latency and create a distribution.

        Default value: [0, 1s[

        .. note:: Nanosecond resolution is supported for versions 1.8.24 and beyond
                  (older versions only supported up to microsecond resolution).

        Bug

        An incorrect exception is thrown when an invalid
        range is given.

        :raises: <tcl_error> - 'LAT001': When trying to configure an invalid range.

        Example

        This will set the range from 0 to 5seconds.

        .. code-block:: python
           :emphasize-lines: 1

        	distributionTrigger.RangeSet(0, 100)


        """
        return _byteblower.LatencyDistribution_RangeSet(self, rangeStartNs, rangeEndNs)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	distributionTrigger.ResultClear()


        """
        return _byteblower.LatencyDistribution_ResultClear(self)

    def FilterSet(self, inFilter):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does not reset the counter values
                  which were triggered by a previous filter string.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation
                          for more  information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.
        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.
        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example
        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address

        - UDP traffic with given destination and source UDP port

        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

        	bpf_filter = 'ip dst {} and udp port {}'.format(dst_ip, udp_dest)
        	distributionTrigger.FilterSet(bpf_filter)


        """
        return _byteblower.LatencyDistribution_FilterSet(self, inFilter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(distributionTrigger.FilterGet())


        """
        return _byteblower.LatencyDistribution_FilterGet(self)

    def FrameTagSet(self, fromFrameTagTx):
        r"""

        Configure the FrameTagRx to match the given FrameTagTx.

        This method takes a FrameTag.Tx and applies its metrics and format
        configuration on this trigger's :class:`.FrameTagRx`.

        .. note:: The transmitted frame tag type (sequence number, time stamp, ...)
                  must match the receiver frame tag type that is used for this trigger.

        The transmitted frame tag (sequence number, timestamp) can be obtained from the
        Frame (:meth:`.Frame.FrameTagSequenceGet`, resp. :meth:`.Frame.FrameTagTimeGet`)

        :param transmittedFrameTag: The :class:`.FrameTagTx` to obtain the metrics and
                                    format configuration from.

        .. versionadded:: 1.8.18

        :raises: ByteBlower.Server.NotSupported - Unsupported Server Capability:
                 'Manage TX/RX Frame Tag placement': When a transmitted frame tag with
                 unsupported metrics and/or format is given.

        :raises: <tcl_error> - 'FrameTag is of incorrect Type':
                 When a transmitted frame tag of invalid type is given (sequence vs.
                 time)

        Example

        This example applies the transmitted time tag configuration on the receiver's
        time tag:

        .. code-block:: python
           :emphasize-lines: 3

        	frameTag = frame.FrameTagTimeGet()
            frameTag.Enable(True)
        	distributionTrigger.FrameTagSet(frameTag)


        """
        return _byteblower.LatencyDistribution_FrameTagSet(self, fromFrameTagTx)

# Register LatencyDistribution in _byteblower:
_byteblower.LatencyDistribution_swigregister(LatencyDistribution)

class ServiceInfo(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.ServiceInfo_TypeGet(self)

    def SeriesGet(self):
        return _byteblower.ServiceInfo_SeriesGet(self)

    def VersionGet(self):
        return _byteblower.ServiceInfo_VersionGet(self)

    def MachineIDGet(self):
        return _byteblower.ServiceInfo_MachineIDGet(self)

    def ServiceIDGet(self):
        return _byteblower.ServiceInfo_ServiceIDGet(self)

# Register ServiceInfo in _byteblower:
_byteblower.ServiceInfo_swigregister(ServiceInfo)

class PacketDump(AbstractObject):
    r"""

    Utility for dumping ByteBlower network traffic to a pcap file.

    A PacketDump object is created for a ByteBlower interface and can be configured
    with a BPF filter and a maximum snapshot length.

    .. versionAdded: 2.9.0

    Example

    .. code-block:: python

    	packetDump = interface.PacketDumpCreate()
        packetDump.Start('packetDump.pcap')
        while (packetDump.FileSizeGet()) < 1000000000:
            time.sleep(10)
        packetDump.Stop()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.PacketDump_ServerGet(self)

    def Start(self, filename):
        r"""

        Start capturing packets.

        :param filename: Location of where the pcap file should be stored.

        .. note:: if the file already existsit will be overwritten.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.Start('packetDump.pcap')


        """
        return _byteblower.PacketDump_Start(self, filename)

    def Stop(self):
        r"""

        Stop capturing packets.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.Stop()


        """
        return _byteblower.PacketDump_Stop(self)

    def FilterGet(self):
        r"""

        Returns the BPF filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FilterGet())


        """
        return _byteblower.PacketDump_FilterGet(self)

    def FilterSet(self, value):
        r"""

        Configures a BPF filter so that only packets that match the filter will be
        captured.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.FilterSet('udp port 4096')


        """
        return _byteblower.PacketDump_FilterSet(self, value)

    def SnapshotLengthGet(self):
        r"""

        Returns the maximum number of bytes that can be captured for each packet.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.SnapshotLengthGet())


        """
        return _byteblower.PacketDump_SnapshotLengthGet(self)

    def SnapshotLengthSet(self, value):
        r"""

        Configure the maximum number of bytes that can be captured for each packet.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.SnapshotLengthSet(100000)


        """
        return _byteblower.PacketDump_SnapshotLengthSet(self, value)

    def FileNameGet(self):
        r"""

        Returns file name of the target pcap file.

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FileNameGet())


        """
        return _byteblower.PacketDump_FileNameGet(self)

    def FileSizeGet(self):
        r"""

        Returns current size of the target pcap file.


        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FileSizeGet())


        """
        return _byteblower.PacketDump_FileSizeGet(self)

# Register PacketDump in _byteblower:
_byteblower.PacketDump_swigregister(PacketDump)

class ByteBlowerPort(AbstractObject):
    r"""

    Logical representation of a network host docked somewhere in the :term:`NUT`, 
    which can transmit or schedule network traffic, process incoming traffic and 
    run stateful network applications.  

    A ByteBlowerPort is physically connected (or 'attached') to the :term:`NUT` 
    through the physical ByteBlower interface on which it is created. See 
    :meth:`.ByteBlowerServer.PortCreate` for more information.  

    Multiple ports may be created on the same physical interface. From a network 
    view, they are just different (simulated) hosts within a shared (datalink or 
    layer 2) subnet. This means traffic to one port created on an interface is seen
    by all ports on that interface.  

    Most test scenarios start with one or more ByteBlower ports that are configured
    to do the following things:

    * become part of the network (layer2, layer3, perform DHCP, 
      join multicast groups, ...)
    * schedule network traffic streams for transmission (TX objects)
    * configure incoming packet processors (RX objects) that look for matching 
      packets and e.g. count them
    * start network applications such as HTTP servers
    * schedule network application actions (called 'schedulable objects') such an 
      HTTP client application sending out an HTTP request

    When such ports are subsequently activated, the scheduled streams and network 
    actions are performed at the configured time.  

    From that moment, relevant result data may be pulled from those streams (TX 
    statistics), incoming packet processors (RX statistics) and network 
    applications (application and session statistics).  

    Destroying a port will clean up everything that is configured on that port in a
    clean way:

    * streams, incoming packet processors and network applications are teared down,
      their results are gone
    * the port leaves all multicast groups of which it is part (but doesn't wait 
      for confirmation)
    * the port releases its DHCP lease (but doesn't wait for confirmation)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetByteBlowerInterface(self):
        return _byteblower.ByteBlowerPort_GetByteBlowerInterface(self)

    def ServerGet(self):
        return _byteblower.ByteBlowerPort_ServerGet(self)

    def InterfaceNameGet(self):
        r"""

        Returns physical ByteBlower interface code.  

        Each ByteBlower port is created on a physical ByteBlower interface of a server.
        This interface determines where the port will be 'attached' to the :term:`NUT`.  

        See :meth:`.ByteBlowerServer.PortCreate` for more information and to see how
        an interface name is structured.  

        :return: String code representing the physical interface name (e.g. trunk-1-4 
                 or nontrunk-1).  
        :rtype: str

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.InterfaceNameGet())
        	# prints trunk-1-1


        """
        return _byteblower.ByteBlowerPort_InterfaceNameGet(self)

    def InterfaceSpeedGet(self):
        r"""

        Returns physical ByteBlower interface speed.  

        See :meth:`.ByteBlowerServer.PortCreate` for more information and to see how an
        interface name is structured.  

        :return: The maximum speed in bits per second a ByteBlower Interface can 
                 transmit. This does not take any VLAN overhead into account!  
        :rtype: long

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.InterfaceSpeedGet())
        	# prints 1000000000


        """
        return _byteblower.ByteBlowerPort_InterfaceSpeedGet(self)

    def InterfaceSwitchIdGet(self):
        return _byteblower.ByteBlowerPort_InterfaceSwitchIdGet(self)

    def MDLMaximumGet(self):
        r"""

        Returns the port's highest allowed Maximum Data Length (MDL) value, which is limited by the physical interface.  

        The MDL of a ByteBlower port places a limit on the size of ethernet frames that may be sent on that port. It can be modified by the user through :meth:`MDLSet`. The MDL value (in bytes) covers the whole ethernet packet, but excluding CRC, preamble and interframe gap.  

        The physical ByteBlower interface (e.g. nontrunk-1) on which a port is created places an upper bound on the allowed MDL values. Through this method, this property can be retrieved at runtime.  

        The typical value of the maximum MDL is 9014 on non-trunking interfaces and 9010 on trunking interfaces.  

        .. note:: On trunking interfaces the ByteBlower server adds a temporary VLAN automatically, to select an interface (e.g. trunk-1-10) on the ByteBlower switch. This is hidden from the user. However, it also means that from a user perspective, the maximum MDL value of the same physical interface is 4 bytes less when it's configured as a trunking interface.  

        :return: Physical upper bound for the MDL in bytes.  

        Example


        Typical values for a trunking and a non-trunking
        port.  

        .. code-block:: python
        	:emphasize-lines: 1

            print(port1.MDLMaximumGet())


        """
        return _byteblower.ByteBlowerPort_MDLMaximumGet(self)

    def MDLGet(self):
        r"""

        Returns the port's current Maximum Data Length (MDL), the maximum ethernet frame size that can be transmitted.  

        The MDL is the maximum size (in bytes) for any ethernet packet leaving the 
        port. It includes the ethernet header, but excludes CRC, preamble and 
        interframe gap. To calculate the maximum size of the layer 2 *payload*, 
        substract the 14 bytes of the ethernet header.   

        This payload may be a layer 3 IP packet, a layer 2.5 VLAN tag followed by such a layer 3 IP packet or anything else.  

        The MDL value defaults to 1514, which corresponds with a layer 2 payload of 1500 bytes.  

        This value is used by the protocol stack. For example, the announced TCP Maximum Segment Size (MSS) is based on this MDL value. This value also limits the number of bytes that can be placed in a Frame when calling :meth:`.Frame.BytesSet`.  

        .. note:: For ports without layer 2.5 configurations, the default MDL of 1514 will also lead to a maximum layer 3 packet size of 1500. This value is often called the Maximum Transmission Unit or MTU of an interface. When a port has a VLAN configuration however, the MTU will only be 1496 by default! Consider increasing the MDL to 1518 in such cases to simulate typical real-world behavior.  

        .. note:: On trunking interfaces the ByteBlower server adds a temporary VLAN automatically, to select an interface (e.g. trunk-1-10) on the ByteBlower switch. This is hidden from the user and has no influence on the MDL value. See ByteBlowerPort::MDLMaximumGet for more information.  

        :return: Current MDL value in bytes.  

        Example

        Typical values for a trunking and non-trunking
        port.  

        .. code-block:: python
        	:emphasize-lines: 1

            print(port1.MDLGet())


        """
        return _byteblower.ByteBlowerPort_MDLGet(self)

    def MDLSet(self, mdl):
        r"""

        Sets the port's Maximum Data Length (MDL), the maximum ethernet frame size that
        can be transmitted.  

        See :meth:`MDLGet` for more information.  

        :param mdl: New MDL value in bytes. Should be less then the value returned by 
                    :meth:`MDLMaximumGet`.  
        :type mdl: long

        :raises: ByteBlower.Exception.InvalidValue.Integer - When ``mdl`` is no integer.  

        :raises: TBD - When the provided value was larger than the maximum supported MDL. 
                 TODO: Decide on this exception and document (Tim, February 2015)  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	port.MDLSet('1350')
        	print(port.MDLGet())
        	# prints 1350

        """
        return _byteblower.ByteBlowerPort_MDLSet(self, mdl)

    def CapabilityListGet(self):
        r"""

        Returns a list of Capability objects.  

        .. versionadded:: 2.6.0  

        :return: An object representing a list of known capabilities
        :rtype: :class:`.CapabilityList`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example shows how to query the capabilities on a ByteBlowerPort

           capability_list = port.CapabilityListGet()

           for capability in capability_list:
               print(capability.DescriptionGet())

        """
        return _byteblower.ByteBlowerPort_CapabilityListGet(self)

    def CapabilityGetByName(self, name):
        r"""

        Returns a Capability object by its name.  

        .. versionadded:: 2.6.0  

        :return: An object representing the requested capability
        :rtype: :class:`.Capability`

        :raises: :exc:`.ConfigError` - UnsupportedConfig error message when the     Capability is not supported  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	capability = port.CapabilityGetByName('IPv4')
        	print(capability.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_CapabilityGetByName(self, name)

    def CapabilityIsSupported(self, name):
        r"""

        Checks whether a capability is supported.  

        .. versionadded:: 2.6.0  

        :return: True if it is supported, False if not  
        :rtype: bool

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.CapabilityIsSupported('IPv4')
           # prints True

        """
        return _byteblower.ByteBlowerPort_CapabilityIsSupported(self, name)

    def Layer2EthIISet(self):
        r"""

        Sets the layer 2 configuration of this port.  

        .. versionadded: 2.5.0  

        Once the layer 2 configuration is set, it cannot be destroyed or overwritten.  

        :return: :class:`.EthernetConfiguration` object.  

        :raises: :exc:`.ConfigError` - When the layer 2 configuration is already set.  

        Example

        Configure `port`'s network connection as an Ethernet interface and add MAC address.  

        .. code-block:: python
        	:emphasize-lines: 1

        	port.Layer2EthIISet().MacSet('00bb1b000001')


        """
        return _byteblower.ByteBlowerPort_Layer2EthIISet(self)

    def Layer2EthIIGet(self):
        r"""

        Returns the layer 2 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: The ethernet configuration of the ByteBlower port
        :rtype: :class:`.EthernetConfiguration`

        :raises: :exc:`.ConfigError` - When the layer 2 configuration is not yet set.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	eth_conf = port.Layer2EthIIGet()



        """
        return _byteblower.ByteBlowerPort_Layer2EthIIGet(self)

    def Layer25VlanAdd(self):
        r"""

        Adds a layer 2.5 VLAN to this port.  

        .. versionchanged:: 2.5.0  
           Multiple layer 2.5 configurations can be added. They will be stacked on top 
           each other in the the port's network stack from the bottom up.  

        Once a layer 2.5 configuration is added to a port, it cannot be destroyed or 
        removed.  

        .. versionchanged:: 2.3.0
           Support for stacking multiple VLAN tags. Adding a second VLAN tag on an 
           older server will throw a technical exception.  

        :return: Created VLAN configuration object.  
        :rtype: :class:`VlanTag`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5
                 configuration is not yet fully configured.  

        Example

        Configure `port`'s network connection as a VLAN-enabled virtual interface.  

        .. code-block:: python
           :emphasize-lines: 1

           vlan_tag = port.Layer25VlanAdd()
           vlan_tag.IDSet(20)


        """
        return _byteblower.ByteBlowerPort_Layer25VlanAdd(self)

    def Layer25VlanGet(self):
        r"""

        Returns the ordered list of layer 2.5 Vlan objects of this port.  

        .. versionadded:: 2.5.0  
           VLAN  objects can be added by :meth:`Layer25VlanAdd`.

        :return: :class:`.Layer25VlanList`

        Example
        Reading the number of VlanTag` objects of `port`
        Configure `port`'s network connection as a VLAN-enabled virtual interface.  
        .. code-block:: python
        	:emphasize-lines: 1

            vlan_list = port.Layer25VlanGet()


        """
        return _byteblower.ByteBlowerPort_Layer25VlanGet(self)

    def Layer25VlanRemove(self, inVlanTag):
        return _byteblower.ByteBlowerPort_Layer25VlanRemove(self, inVlanTag)

    def Layer25PPPoEAdd(self):
        r"""

        Adds a layer 2.5 PPPoE Client to this port.  

        .. versionadded:: 2.5.0  

        Once a layer 2.5 configuration is added to a port, it cannot be destroyed or
        removed.  

        :return: an object representing an PPPoE client
        :rtype: :class:`.PPPoEClient`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5 
                 configuration is not yet fully configured.  

        Example

        Configure `port`'s network connection as a PPPoE-enabled virtual interface.  

        .. code-block:: python
        	:emphasize-lines: 1

        	# set an PPPoE client
        	client = port.Layer25PPPoEAdd()
        	print(client.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoEAdd(self)

    def Layer25PPPoEGet(self):
        r"""

        Returns the ordered list of layer 2.5 PPPoE objects of this port.  

        .. versionadded:: 2.5.0  
           PPPoE objects can be added by :meth:`.ByteBlowerPort.Layer25PPPoEAdd`

        :return: A list with all the PPPoE clients created
        :rtype: :class:`.Layer25PPPoEList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	layer25PPPoEGet = port.Layer25PPPoEGet()


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoEGet(self)

    def Layer25PPPoERemove(self, inPPPoEClient):
        return _byteblower.ByteBlowerPort_Layer25PPPoERemove(self, inPPPoEClient)

    def Layer3IPv4Set(self):
        r"""

        Sets the layer 3 IPv4 configuration of this port.  

        .. versionadded:: 2.5.0  

        Once a layer 3 configuration is set, it cannot be destroyed or overwritten.  

        Both IPv4 and IPv6 are supported. Dual stack is not available on a single port,
        but can be achieved by creating 2 separate ports with identical layer 2 and 
        (possibly) layer 2.5 configurations.  

        :return: an object representing the IPv4 configuration for the ByteBlower port
        :rtype: :class:`.IPv4Configuration`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5 
                 configuration is not yet fully configured.  
        :raises: :exc:`.ConfigError` - When the layer 3 configuration is already set.  

        Example

        Configure `port`'s network connection as an IPv4 host.  

        .. code-block:: python
        	:emphasize-lines: 1

        	ipv4_config = port.Layer3IPv4Set()

        """
        return _byteblower.ByteBlowerPort_Layer3IPv4Set(self)

    def Layer3IPv4Get(self):
        r"""

        Returns the layer 3 IPv4 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: A created IPv4 configuration object
        :rtype: :class:`.IPv4Configuration`.  

        :raises: :exc:`.ConfigError` - When the layer 3 configuration is not yet set.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	ipv4_config = port.Layer3IPv4Get()
        	print(ipv4_config.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_Layer3IPv4Get(self)

    def Layer3IPv6Set(self):
        r"""

        Sets the layer 3 IPv6 configuration of this port.  

        .. versionadded:: 2.5.0  

        Once a layer 3 configuration isM set, it cannot be destroyed or overwritten.  

        Both IPv4 and IPv6 are supported. Dual stack is not available on a single port, but can be achieved by creating 2 separate ports with identical layer 2 and (possibly) layer 2.5
        configurations.  

        :return: :class:`.IPv6Configuration`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5 configuration is not yet fully configured.  
        :raises: :exc:`.ConfigError` - When the layer 3 configuration is already set.  

        Example

        Configure `port`'s network connection as an IPv6 host.  

        .. code-block:: python	
        	:emphasize-lines: 1

            bbPort1_l3 = port1.Layer3IPv6Set().IpManualAdd('3000:3128::24/64')


        """
        return _byteblower.ByteBlowerPort_Layer3IPv6Set(self)

    def Layer3IPv6Get(self):
        r"""

        Returns the layer 3 IPv6 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: An object with the IPv6 configuration of the ByteBlower Port
        :rtype: :class:`.IPv6Configuration`

        :raises: :exc:`.ConfigError` - When the layer 3 configuration is not yet set.

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	l3_config = port.Layer3IPv6Get()



        """
        return _byteblower.ByteBlowerPort_Layer3IPv6Get(self)

    def ProtocolHttpServerAdd(self):
        r"""

        Creates a HTTP server application to run on this port.  

        An :class:`.HttpServer` application is a customized HTTP server that is typically used to emulate a TCP connection.  

        It listens for special HTTP requests (sent by :class:`.HttpClient` 
        applications) and responds in the desired way. For example, an HTTP request may
        ask (GET) for a response of a specified size and the HTTP server will emulate 
        sending such a file back.  

        :return: an object representing an HTTP Server object.
        :rtype: :class:`.HttpServer`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	http_server = port.ProtocolHttpServerAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerAdd(self)

    def ProtocolHttpServerGet(self):
        r"""

        Returns the list of all HTTP server applications created on this port.  

        See :meth:`ProtocolHttpServerAdd` for more information.  

        :return: class:`.HttpServerList`  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.ProtocolHttpServerGet())




        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerGet(self)

    def ProtocolHttpServerRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpServerRemove(self, arg2)

    def ProtocolHttpClientAdd(self):
        r"""

        Creates a HTTP client application to run on this port.  

        A ::class:`HttpMultiServer` application can initiate customized HTTP sessions that are typically used to emulate a TCP connection.  

        It allows configuring the special HTTP requests to which a running :class:`.HttpServer` application responds. For example, an HTTP client can ask (GET) for a response of a specified size or time or may send (PUT) a payload of a specified size or time itself.  

        Besides constructing such special HTTP requests, the HTTP client can interact with any normal webserver by configuring its URL.  

        :return: ::class:`HttpMultiServer`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	httpClient = port.ProtocolHttpClientAdd()



        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientAdd(self)

    def ProtocolHttpClientGet(self):
        r"""

        Returns the list of all HTTP client applications created on this port.  

        See :meth:`ProtocolHttpClientAdd` for more information.  

        :return: returns a list of created :class:`.HtppClient` objects
        :rtype: :class:`.HttpClientList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_clients = port.ProtocolHttpClientGet()
        	print(all_clients.size())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientGet(self)

    def ProtocolHttpClientRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpClientRemove(self, arg2)

    def ProtocolHttpMultiServerAdd(self):
        r"""

        Creates a :class:`HttpMultiServer` object on this port.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	# create the HTTP client
        	httpServer = port.ProtocolHttpMultiServerAdd()



        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerAdd(self)

    def ProtocolHttpMultiServerGet(self):
        r"""

        Returns the list of :class:`HttpMultiServer` objects on this port.  

        :return: :class:`HttpMultiServerList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.ProtocolHttpMultiServerGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerGet(self)

    def ProtocolHttpMultiServerRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerRemove(self, arg2)

    def ProtocolHttpMultiClientAdd(self):
        r"""

        Creates a Layer5.Http.MultiClient object on this port.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	httpClient = port.ProtocolHttpMultiClientAdd()



        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientAdd(self)

    def ProtocolHttpMultiClientGet(self):
        r"""

        Returns the list of a :class:`.HttpMultiClient` objects on this port.  

        :return: :class:`.HttpMultiClientList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.ProtocolHttpMultiClientGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientGet(self)

    def ProtocolHttpMultiClientRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientRemove(self, arg2)

    def TunnelTcpAdd(self):
        r"""

        Creates a TCP tunnel object.  

        A :class:`.TcpTunnel` can be used to configure TCP port forwarding between the
        user's office network and the lab network.  

        Through the protocol, a client can requesting dynamic changes to the firewall 
        or NAT port forwarding settings of a (PCP-enabled) gateway.  

        :return: The created TcpTunnel object.  This object can be used to configure 
                 the tunnel
        :rtype: :class:`.TcpTunnel`  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	tunnel = port.TunnelTcpAdd()
        	print(tunnel.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_TunnelTcpAdd(self)

    def TunnelTcpGet(self):
        r"""

        Returns a list of all TCP Tunnel objects created on this port.  

        See :meth:`TunnelTcpAdd` for more information.  

        :return: :class:`.TcpTunnelList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	tunnelTcp = port.TunnelTcpGet()


        """
        return _byteblower.ByteBlowerPort_TunnelTcpGet(self)

    def TunnelTcpRemove(self, arg2):
        return _byteblower.ByteBlowerPort_TunnelTcpRemove(self, arg2)

    def ProtocolTelnetClientAdd(self):
        r"""

        Creates a Telnet client application to run on this port.  

        .. versionadded:: API 2.2.0  

        A :class:`.TelnetClient` application can contact and interact with an external Telnet server.  

        Apart from simulating such scenarios for its own sake, this application can be used to contact important nodes within the :term:`NUT` (e.g. a router) and retrieve relevant statistics from it.  

        :return: :class:`.TelnetClient`.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	protocolTelnetClient = port.ProtocolTelnetClientAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientAdd(self)

    def ProtocolTelnetClientGet(self):
        r"""

        Returns the list of all Telnet client applications created on this port.  

        .. versionadded:: API 2.2.0  

        See :meth:`ProtocolTelnetClientAdd` for more information.  

        :return: :class:`.TelnetClientList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	protocolTelnetClient = port.ProtocolTelnetClientGet()


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientGet(self)

    def ProtocolTelnetClientRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientRemove(self, arg2)

    def TxStreamAdd(self):
        r"""

        Creates a transmit stream, which can be configured to blast layer 2 frames traffic from this port in a stateless way.  

        Initially, a stream does not contain any traffic. It must still be configured 
        by adding content (in the form of Frame objects) and timing information 
        (especially the interframe gap).

        A :class:`.Stream` can be compared to the transmitting part of a frame blasting
        flow in the GUI.  

        :return: an object representing a pure frame blasting stream.
        :rtype: :class:`.Stream`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	stream = port.TxStreamAdd()


        """
        return _byteblower.ByteBlowerPort_TxStreamAdd(self)

    def TxStreamRemove(self, inStream):
        return _byteblower.ByteBlowerPort_TxStreamRemove(self, inStream)

    def TxStreamGet(self):
        r"""

        Returns a list of transmit streams created on this port.  

        :return: A list with all created :class:`.Stream` objects
        :rtype: :class:`.StreamList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	streams = port.TxStreamGet()
        	print(streams.size())
        	# prints 1


        """
        return _byteblower.ByteBlowerPort_TxStreamGet(self)

    def RxTriggerBasicAdd(self):
        r"""

        Creates a basic receive trigger, whose counters are updated for each received frame (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        The receive trigger is activated as soon as it is created, so don't forget to 
        reset its counters after setting the filter and initializing your test.  

        See the class documentation of the returned types for more information.  

        :return: A basic trigger object, which allows to configure the trigger and 
                 getting the results
        :rtype: :class:`TriggerBasic`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	trigger = port.RxTriggerBasciAdd()

        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicAdd(self)

    def RxTriggerBasicGet(self):
        r"""

        Returns the list of receive triggers created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`RxTriggerBasicAdd` for more information.  

        :return: an object representing a list of create basic triggers
        :rtype: :class:`.TriggerBasicList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_triggers = port.RxTriggerBasicGet()
        	print(all_triggers.size())
        	# prints 1  

        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicGet(self)

    def RxTriggerBasicRemove(self, arg2):
        return _byteblower.ByteBlowerPort_RxTriggerBasicRemove(self, arg2)

    def RxTriggerSizeDistributionAdd(self):
        r"""

        Creates a size distribution receive trigger, whose counters are updated for each received frame (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        The receive trigger is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See the class documentation of the returned types for more information.  

        :return: :class:`.TriggerSizeDistribution`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	trigger = port.RxTriggerSizeDistributionAdd()



        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionAdd(self)

    def RxTriggerSizeDistributionGet(self):
        r"""

        Returns the list of receive triggers created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`RxTriggerSizeDistributionAdd` for more information.  

        :return: A list with all the sizedistribution triggers created
        :rtype: :class:`.TriggerSizeDistributionList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_size_dists = port.RxTriggerSizeDistributionGet()
        	print(all_size_dists.size())
        	# prints 1


        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionGet(self)

    def RxTriggerSizeDistributionRemove(self, arg2):
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionRemove(self, arg2)

    def RxLatencyBasicAdd(self):
        r"""

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.Frame` for information on timestamping.  

        :return: :class:`.LatencyBasic`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	latency = port.RxLatencyBasicAdd()



        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicAdd(self)

    def RxLatencyBasicRemove(self, inLatency):
        return _byteblower.ByteBlowerPort_RxLatencyBasicRemove(self, inLatency)

    def RxLatencyBasicGet(self):
        r"""

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`LatencyBasicAdd` for more information.  

        :return: :class:`.LatencyBasicList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_latency = port.RxLatencyBasicGet()
        	print(all_latency.size())
        	# prints 1


        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicGet(self)

    def RxLatencyDistributionAdd(self):
        r"""

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.Frame` for information on timestamping.  

        :return: :class:`.LatencyDistribution`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

           distribution = port.RxLatencyDistributionAdd()


        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionAdd(self)

    def RxLatencyDistributionRemove(self, inLatency):
        return _byteblower.ByteBlowerPort_RxLatencyDistributionRemove(self, inLatency)

    def RxLatencyDistributionGet(self):
        r"""

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`.LatencyDistributionAdd` for more information.  

        :return: :class:`.LatencyDistributionList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_latency = port.RxLatencyDistributionGet()




        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionGet(self)

    def RxOutOfSequenceBasicAdd(self):
        r"""

        Creates an out-of-sequence detector, which counts such cases based on sequence numbers in received frames (possibly restricted by a filter).

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        Typically, the filter should limit the matching traffic to the :class:`.Stream`
        whose transmitted frames actually contain the required sequence numbers!   

        The out-of-sequence detector is activated as soon as it is created, so don't 
        forget to reset its counters after setting the filter and initializing your 
        test.

        :return: Created out-of-sequence detector object.
        :rtype: :class:`.OutOfSequence`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           out_of_sequence = port.RxOutOfsequenceBasicAdd()
           # lets assume traffic is sent to UDP port 9000
           out_of_sequence.FilterSet('ip && dst port 9000')
           print(out_of_sequence.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicAdd(self)

    def RxOutOfSequenceBasicRemove(self, inOutOfSequence):
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicRemove(self, inOutOfSequence)

    def RxOutOfSequenceBasicGet(self):
        r"""

        Returns the list of out-of-sequence detectors created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`OutOfSequenceBasicAdd` for more information.  

        :return: A list of created objects
        :rtype: :class:`.OutOfSequenceList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_oos = port.RxOutOfSequenceBasicGet()
           print(all_oos.size())
           # prints 1


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicGet(self)

    def Start(self):
        r"""

        Starts all transmit streams and schedulable objects configured on this port.  

        See :meth:`.ByteBlower.PortsStart`, which does the same for a set of ports, for
        more information.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	port.Start()



        """
        return _byteblower.ByteBlowerPort_Start(self)

    def Stop(self):
        return _byteblower.ByteBlowerPort_Stop(self)

    def ResultGet(self):
        r"""

        Returns the result object.  

        :return: A result object which contains the packet count, byte count etc for 
                 this ByteBlower port. 
        :rtype: :class:`.ByteBlowerPortResultSnapshot`


        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	result = port.ResultGet()
        	print(result.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the history for the counters for the ByteBlower port.  

        :return: :class:`.ByteBlowerPortResultHistory`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	historyResult = port.ResultHistoryGet()
        	print(historyResult.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_ResultHistoryGet(self)

    def ResultClear(self):
        r"""

        Clears the counters for the ByteBlower port and empties the :class:`.ByteBlowerPortResultHistory`.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	port.ResultClear()


        """
        return _byteblower.ByteBlowerPort_ResultClear(self)

    def RxCaptureBasicAdd(self):
        r"""

        Creates a capture tool, which captures the data and metadata of incoming frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        Typically, the filter should limit the matching packets to the interesting 
        traffic, especially since capturing all incoming bytes at high rates may place
        a heavy load on the server.  

        .. note:: Unlike other Rx objects, the capture tool is not activated as soon as
           it is created.  See the class documentation of the returned types for more 
           information.  

        .. warning:: Using this tool requires a lot of system resources. Try to avoid 
           capturing at high rates or for a long time. Set the capture filter as strict
           as possible to avoid unwanted traffic. When too much incoming traffic must 
           be processed, the ByteBlower server may become unstable.  

        .. note:: It is also possible to log in to the server and capture there. Note
           that when capturing a trunking interface (i.e. connected to a switch) you 
           will see an extra VLAN tag that shows to or from which interface the traffic
           goes. This is currently *only* possible on the 1x00 series, where the
           Linux `tcpdump` tool can sniff the server's (native) data interfaces.  

        .. note:: This functionality is also available with a stand-alone command-line
           tool. It can be found and downloaded on our support portal.  

        The returned capture tool is a basic capture tool stores both the frame data 
        and some metadata.  

        :return: An object representing the servers implementation of the capture
                 functionality
        :rtype: :class:`CaptureRawPacket`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	captureTool = port.RxCaptureBasicAdd()
            captureTool.Start()


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicAdd(self)

    def RxCaptureBasicRemove(self, inCapture):
        return _byteblower.ByteBlowerPort_RxCaptureBasicRemove(self, inCapture)

    def RxCaptureBasicGet(self):
        r"""

        Returns the list of capture tools created on this port.  

        .. versionadded::: 2.5.0  

        See :meth:`RxCaptureBasicAdd` for more information.  

        :return: :class:`.CaptureRawPacketList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	tools = port.RxCaptureBasicGet()


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicGet(self)

# Register ByteBlowerPort in _byteblower:
_byteblower.ByteBlowerPort_swigregister(ByteBlowerPort)

class ByteBlowerPortResultRxData(AbstractObject):
    r"""

    ByteBlower port counter result set.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or :class:`.ByteBlowerPortResultSnapshot`

    .. note:: See What's new in API v2 for more information.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

        rx_result=port_result.RxAllGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    CounterType_RxBroadcast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxBroadcast
    CounterType_RxUnicast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxUnicast
    CounterType_RxAll = _byteblower.ByteBlowerPortResultRxData_CounterType_RxAll

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are  received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampFirstGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(rx_result.TimestampLastGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampLastGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampGet()) 

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.PacketCountGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.ByteCountGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_ByteCountGet(self)

    def ByteCountWithCRCGet(self):
        r"""

        Gets the current received bytes counter with the CRC.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(rx_result.ByteCountWithCRCGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_ByteCountWithCRCGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest frame size received in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.FramesizeMinimumGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_FramesizeMinimumGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size received in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                                      unavailable

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.FramesizeMaximumGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_FramesizeMaximumGet(self)

    def IntervalDurationGet(self):
        return _byteblower.ByteBlowerPortResultRxData_IntervalDurationGet(self)

# Register ByteBlowerPortResultRxData in _byteblower:
_byteblower.ByteBlowerPortResultRxData_swigregister(ByteBlowerPortResultRxData)


def ConvertCounterType(inType):
    return _byteblower.ConvertCounterType(inType)
class ByteBlowerPortResultData(AbstractObject):
    r"""

    ByteBlower port counter result set.

    The result set contains three different counters:

    - a Unicast counter, which counts all received unicast Ethernet frames.
    - a Broadcast counter, which counts all received broadcast Ethernet frames.
    - an All counter, which counts all received Ethernet frames.

    .. note:: The 'all' counter can be seen as the combination of the unicast and
              the broadcast counter.

    .. note:: See What's new in API v2 for more information.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or ByteBlowerPort.ResultSnapshot

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 2

    	result = port.ResultHistoryGet()
        resultData = result.CumulativeLatestGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxUnicastGet(self):
        r"""

        Gets the received unicast counters for the port.

        This will return a :class:`.ByteBlowerPortResultRxData` object which contain all
        unicast counters from a port. This will only contain the broadcast unicast
        received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxUnicastGet().DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultData_RxUnicastGet(self)

    def RxBroadcastGet(self):
        r"""

        Gets the received broadcast counters for the port.

        This will return a :class:`.ByteBlowerPortResultRxData` object which contain
        all counters from a port. This will only contain the broadcast packets
        received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxBroadcastGet().DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultData_RxBroadcastGet(self)

    def RxAllGet(self):
        r"""

        Gets the received counters for the port.

        This will return a :class:`.ByteBlowerPortResultRxData` object which contain
        all counters from a port

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxAllGet().DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultData_RxAllGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TimestampGet())


        """
        return _byteblower.ByteBlowerPortResultData_TimestampGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.IntervalDurationGet())


        """
        return _byteblower.ByteBlowerPortResultData_IntervalDurationGet(self)

# Register ByteBlowerPortResultData in _byteblower:
_byteblower.ByteBlowerPortResultData_swigregister(ByteBlowerPortResultData)

class ByteBlowerPortResultSnapshot(AbstractRefreshableResult):
    r"""

    ByteBlower port counter result set.

    The result set contains three different counters:

    - a Unicast counter, which counts all received unicast Ethernet frames.
    - a Broadcast counter, which counts all received broadcast Ethernet frames.
    - an All counter, which counts all received Ethernet frames.

    .. note:: The "all" counter can be seen as the combination of the unicast
              and the broadcast counter.

    .. note:: See What's new in API v2 for more information.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or :class:`.ByteBlowerPortResultSnapshot`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       port_result = port.ResultGet()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        return _byteblower.ByteBlowerPortResultSnapshot_Clear(self)

    def RxUnicastGet(self):
        r"""

        Gets the received unicast counters for the port. This will return a
        :class:`.ByteBlowerPortResultRxData` object which contain all unicast counters
        from a port. This will only contain the broadcast unicast received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.RxUnicastGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxUnicastGet(self)

    def RxBroadcastGet(self):
        r"""

        Gets the received broadcast counters for the port. This will return a
        :class:`.ByteBlowerPortResultRxData` object which contain all counters from a
        port. This will only contain the broadcast packets received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.RxBroadcastGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxBroadcastGet(self)

    def RxAllGet(self):
        r"""

        Gets the received counters for the port. This will return a
        :class:`.ByteBlowerPortResultRxData` object which contain all counters from a
        port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.RxAllGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxAllGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(port_result.TimestampGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_TimestampGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.IntervalDurationGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current snapshot is requested.

        When the snapshot is part of a history, the refresh timestamp will be the same
        as refresh timestamp of the History object.

        ..note:: This is not the same as :meth:`TimestampGet`

        :return: Timestamp on the server when the current snapshot is requested in
                 nanoseconds since epoch

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(port_result.RefreshTimestampGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RefreshTimestampGet(self)

    def RefreshImpl(self):
        return _byteblower.ByteBlowerPortResultSnapshot_RefreshImpl(self)

# Register ByteBlowerPortResultSnapshot in _byteblower:
_byteblower.ByteBlowerPortResultSnapshot_swigregister(ByteBlowerPortResultSnapshot)

class ByteBlowerPortResultDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerPortResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerPortResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerPortResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerPortResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerPortResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerPortResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerPortResultDataList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerPortResultDataList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerPortResultDataList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerPortResultDataList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerPortResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerPortResultDataList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerPortResultDataList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerPortResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerPortResultDataList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerPortResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerPortResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerPortResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerPortResultDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerPortResultDataList_swiginit(self, _byteblower.new_ByteBlowerPortResultDataList(*args))

    def push_back(self, x):
        return _byteblower.ByteBlowerPortResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerPortResultDataList_front(self)

    def back(self):
        return _byteblower.ByteBlowerPortResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerPortResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerPortResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerPortResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerPortResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerPortResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerPortResultDataList

# Register ByteBlowerPortResultDataList in _byteblower:
_byteblower.ByteBlowerPortResultDataList_swigregister(ByteBlowerPortResultDataList)

class ByteBlowerPortResultHistory(AbstractRefreshableResult):
    r"""

    Port counter result history.

    The port counter history is - as always - available in two flavors: the
    cumulative and the interval results

    .. note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See History result for more information.

    A result history object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.ResultHistoryGet`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 3

       port_resultHistory = port.ResultHistoryGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Removes the locally stored history snapshots.

        This can be used to save memory in long tests where the results are requested
        at regular intervals.

        .. warning:: Any interval or cumulative result object returned from this
                     history object before calling :meth:`Clear` will be destroyed and
                     thus become unusable.

        """
        return _byteblower.ByteBlowerPortResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.SamplingIntervalDurationGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. warning:: This affects all users on the same ByteBlower interface.

        .. warning:: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port1_resultHistory.SamplingIntervalDurationGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.SamplingBufferLengthGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inCount):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port_resultHistory.SamplingBufferLengthSet(10)


        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingBufferLengthSet(self, inCount)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        :return: :class:`.ByteBlowerPortResultDataList` containing the Interval
                 counters

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            for results in port_resultHistory.CumulativeGet():
                print(results.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval counters.

        :return: :class:`ByteBlowerPortResultDataList` containing the Interval counters

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            for i in resultHistory.IntervalGet():
                print(i.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :return: :class:`.ByteBlowerPortResultData` cumulative counter object at the
                 specified index

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.CumulativeGetByIndex(0).DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGetByIndex(self, index)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :return: :class:`.ByteBlowerPortResultData` interval counter object at the
                 specified index

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalGetByIndex(0).DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGetByIndex(self, index)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        .. versionadded:: 2.2

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        .. versionadded:: 2.2

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           interval = port_resultHistory.IntervalGetByTime(timestamp)

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :return: The latests closed :class:`.ByteBlowerPortResultData` cumulative
                  counter object.

        .. versionadded:: 2.2

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeLatestGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :return: The latests closed :class:`.ByteBlowerPortResultData` interval counter
                 object.

        .. versionadded:: 2.2

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalLatestGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalLatestGet(self)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeLengthGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeLengthGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalLengthGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history is requested.

        :return: Timestamp on the server when the current history is requested in
                 nanoseconds since epoch

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.RefreshTimestampGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_RefreshTimestampGet(self)

# Register ByteBlowerPortResultHistory in _byteblower:
_byteblower.ByteBlowerPortResultHistory_swigregister(ByteBlowerPortResultHistory)

class ByteBlowerServer(AbstractObject):
    r"""

    Representation of a client connection to a shared,  physical ByteBlower server, 
    which can send and receive network traffic through its interfaces.  

    Using this class, ByteBlower ports (logical network hosts) can be docked to a 
    :term:`NUT` at a specific place.  

    Furthermore, information about a shared ByteBlower Server, such as the 
    available interfaces and the current connections can be retrieved.  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PhysicalInterfacesGet(self):
        return _byteblower.ByteBlowerServer_PhysicalInterfacesGet(self)

    def PhysicalInterfacesGetByType(self, inPhysicalInterfaceType):
        return _byteblower.ByteBlowerServer_PhysicalInterfacesGetByType(self, inPhysicalInterfaceType)

    def InterfaceGetByName(self, name):
        return _byteblower.ByteBlowerServer_InterfaceGetByName(self, name)

    def InterfaceNamesGet(self):
        r"""

        Shows the available physical ByteBlower interfaces on the ByteBlower server.  

        The available interfaces on a server depend on the static server configuration. 
        Only the presence of USB interfaces can change dynamically (using ::Update).  

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        This format is used as keys in the key-value pair list returned by :meth:`UsersGet`.
        It is also the format that should be passed to :meth:`PortCreate` method as 
        argument.

        :return: A list of all available physical interfaces on this server.  

        Example

        Assume `server` has a single 48-port trunking interface and a single 
        non-trunking interface.

        .. code-block:: python
           :emphasize-lines: 1

           server.InterfaceNamesGet()
           # Returns ['trunk-1-1', 'trunk-1-2', 'trunk-1-3', ... , 'trunk-1-48', 'nontrunk-1']

        """
        return _byteblower.ByteBlowerServer_InterfaceNamesGet(self)

    def PacketDumpCreate(self, *args):
        r"""

        Creates a PacketDump object on the specified ByteBlower interface.  

        .. versionadded:: 2.9.0

        The PacketDump API allows to capture all incoming and outgoing network traffic 
        on a ByteBlower interface.  

        :param interface: Interface name of the ByteBlower interface

        :return: :class:`.PacketDump`

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - When the 
                 specified interface name does not exist on the connected server.  

        Example

        Create a PacketDump object on trunk-1-1  

        .. code-block:: python
           :emphasize-lines: 1

        	dump = server.PacketDumpCreate('trunk-1-1')


        Creates a PacketDump object on the specified ByteBlower interface.  

        .. versionadded:: 2.9.0

        The PacketDump API allows to capture all incoming and outgoing network traffic 
        on a ByteBlower interface.  

        :param interface: Interface name of the ByteBlower interface

        :return: :class:`.PacketDump`

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - When the 
                 specified interface name does not exist on the connected server.  

        Example

        Create a PacketDump object on trunk-1-1  

        .. code-block:: python
           :emphasize-lines: 1

        	dump = server.PacketDumpCreate('trunk-1-1')


        """
        return _byteblower.ByteBlowerServer_PacketDumpCreate(self, *args)

    def PacketDumpDestroy(self, packet_dump):
        return _byteblower.ByteBlowerServer_PacketDumpDestroy(self, packet_dump)

    def PortCreate(self, *args):
        r"""

        Creates a new ByteBlower port on the specified ByteBlower interface.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfacesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  

        :return: :class:`.ByteBlowerPort`  

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - 
                 When the specified interface name does not exist on the connected server.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')


        Creates a new ByteBlower port on the specified ByteBlower interface.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfacesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  

        :return: :class:`.ByteBlowerPort`  

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - 
                 When the specified interface name does not exist on the connected server.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')


        Creates a new ByteBlower port on the specified ByteBlower interface.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfacesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  

        :return: :class:`.ByteBlowerPort`  

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - 
                 When the specified interface name does not exist on the connected server.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')


        """
        return _byteblower.ByteBlowerServer_PortCreate(self, *args)

    def PortDestroy(self, inPort):
        return _byteblower.ByteBlowerServer_PortDestroy(self, inPort)

    def PortGet(self):
        r"""

        Returns a list of all ByteBlower ports created through this server connection.  

        Only ports created through the connection represented by this object are 
        returned, not those created by other client instances (either GUI or API) or 
        those created by other server connections within this API instance! See 
        :meth:`UsersGet` to see the interfaces on which other users have created ports.

        :return:  :class:`.ByteBlowerPortList`

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortGet()

        """
        return _byteblower.ByteBlowerServer_PortGet(self)

    def UsersGet(self):
        r"""

        Shows which physical interfaces of the (shared) physical ByteBlower server are currently used by which clients.  

        This method gives an overview of how a ByteBlower server is currently used. 
        It displays which client connections (whether from GUI scenario runs or API
        sessions) have created ByteBlowerPort objects on which of the server's physical
        ByteBlower interfaces.  

        Such a client connection to a server is represented by this very 
        ByteBlowerServer type! As soon as some client instance (e.g. a TCL shell, 
        python interpreter or a GUI) on some client computer creates such server 
        object, a  connection is established to that shared server.  

        Multiple client instances can be active on the same host. For example, a single
        host may be running a GUI scenario, two python scripts and an interactive Tcl 
        session at the same time.
        Similarly, a single client instance may have multiple parallel connections to 
        the same server, by calling :meth:`.ByteBlower.ServerAdd` multiple times for 
        the same server URL or IP.

        The server's physical interfaces are statically configured on the server 
        machine and can be retrieved using :meth:`InterfacesGet`. They are shared 
        among all connected clients.

        Client connections are identified by the client's hostname. This means that all
        server connections from all client instances on a single host will all be
        different 'users', but will have the same string representation. If they use 
        the same interfaces, that hostname will simply appear multiple times.  

        As soon as a specific ByteBlowerServer (representing a client connection) 
        creates a first ByteBlowerPort on some interface, it is 'using' that interface.
        The interface is no longer used when all all ports created by that server on 
        it are destroyed. Ports can be destroyed in the following ways:

        * Explicitly, by calling ``PortRemove`` on the ByteBlowerServer
        * By destroying the ByteBlowerServer for that port. This is also what happens 
          when a GUI finishes or cancels a scenario.
        * By destroying that client instances root ByteBlower object. This is also what
          happens when a client process (GUI or API) is killed.

        :return:  A list of name value pairs, one for each physical ByteBlower 
                  interface with one or more ports configured on it. The name is the 
                  string representation of the interface, the value is a list of the 
                  server connections (represented by their client's hostname) which 
                  have created ports on that interface.  

        Example

        Assume three client instances are currently connected to this server. The first
        runs on John's PC, the second runs on Jane's PC and the last one is a second 
        client instance connecting John's PC. Note the non-trunking interface is used 
        by multiple client instances!  

        .. code-block:: python
           :emphasize-lines: 1

           userList = server.UsersGet()

        """
        return _byteblower.ByteBlowerServer_UsersGet(self)

    def Update(self):
        r"""

        Updates dynamic interfaces (e.g. USB) on the connected server.  

        .. deprecated:: 2.0
           Since 2.0 are USB interfaces not supported anymore

        This methods looks for attached USB interfaces and updates its available 
        interfaces. If USB interfaces are attached, they will be returned by
        :meth:`InterfacesGet` after this running this method.  

        Bug
        Since USB interfaces are not yet supported, this method currently has no use. 
        Method is not yet implemented and will throw a :exc:`.TechnicalError`


        """
        return _byteblower.ByteBlowerServer_Update(self)

    def TimestampGet(self):
        r"""

        Returns the current timestamp on the server.  

        .. versionadded:: 2.3.0

        Retrieves the current timestamp of the server in nanoseconds. This can be used
        to calculate the offset between two servers to compare results.  

        :return: Timestamp in nanoseconds

        Example

        Assume the client is connected (through this object) to a server:  

        .. code-block:: python
           :emphasize-lines: 1

           server.TimestampGet()
           # :return: 1432805398000000000 


        """
        return _byteblower.ByteBlowerServer_TimestampGet(self)

    def PortsStart(self, inPorts):
        return _byteblower.ByteBlowerServer_PortsStart(self, inPorts)

    def PortsStop(self, inPorts):
        return _byteblower.ByteBlowerServer_PortsStop(self, inPorts)

    def PortsStartAll(self):
        return _byteblower.ByteBlowerServer_PortsStartAll(self)

    def PortsStopAll(self):
        return _byteblower.ByteBlowerServer_PortsStopAll(self)

    def ServiceInfoGet(self):
        r"""

        Returns the service information of the ByteBlower server daemon.  

        .. versionadded:: 2.6.0  

        .. code-block:: python
           :emphasize-lines: 1

           server.ServiceInfoGet()


        """
        return _byteblower.ByteBlowerServer_ServiceInfoGet(self)

    def ResultsRefreshAll(self):
        return _byteblower.ByteBlowerServer_ResultsRefreshAll(self)

# Register ByteBlowerServer in _byteblower:
_byteblower.ByteBlowerServer_swigregister(ByteBlowerServer)

class ByteBlowerServerServiceInfo(ServiceInfo):
    r"""

    This class contains information on the ByteBlower System.

    With this object you can get information concerning the Type / version / IP or hostname etc... information.

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       service_info = server.ServiceInfoGet()

    .. versionadded:: 2.6.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LicenseGet(self):
        r"""

        Returns the License information for this ByteBlower server.

        .. versionadded:: 2.6.0
        .. deprecated:: 2.10

        Each physical ByteBlower server (represented by this type of object) has a
        specific ByteBlower License.

        :return: :class:`ByteBlowerLicense`


        """
        return _byteblower.ByteBlowerServerServiceInfo_LicenseGet(self)

    def ManagementIPAddressGet(self):
        r"""

        Returns all management IP addresses of the connected ByteBlower server.

        .. versionadded:: 2.6.0

        :return: List of management IP addresses

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ManagementIPAddressGet())

        """
        return _byteblower.ByteBlowerServerServiceInfo_ManagementIPAddressGet(self)

    def ConnectionHostGet(self):
        r"""

        Returns the host (either registered name or IP address) used to connect to the
        ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ConnectionHostGet())
           # prints 'bytblower-1.lab.byteblower.com'

        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionHostGet(self)

    def ConnectionIPAddressGet(self):
        r"""

        Returns the IP address used to connect to the ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 5

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           server.PortCreate('trunk-1-1')
           service_info = server.ServiceInfoGet()
           print(service_info.ConnectionIPAddressGet())
           # prints ip address

        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionIPAddressGet(self)

    def ConnectionPortNumberGet(self):
        r"""

        Returns the TCP port number of the connected ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ConnectionPortNumberGet())


        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionPortNumberGet(self)

# Register ByteBlowerServerServiceInfo in _byteblower:
_byteblower.ByteBlowerServerServiceInfo_swigregister(ByteBlowerServerServiceInfo)

class ByteBlowerLicense(AbstractObject):
    r"""

    This class represents the license information of your connected server.

    The license is defined by the security key hardware on your ByteBlower server.

    .. versionadded:: 2.6.0
    .. deprecated:: 2.10.0

    Example

    .. code-block:: python
       :emphasize-lines: 2

    	license = serverServiceInfo.LicenseGet()
        print(license.TimeAllowedGet())



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VersionGet(self):
        r"""

        Gets the version of the license.

        :return: the version of the license
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.VersionGet())

        """
        return _byteblower.ByteBlowerLicense_VersionGet(self)

    def SerialGet(self):
        r"""

        Retrieves the serial number.

        This serial number is the serial number of the hardware containing the license.
        This is handy info when contacting the ByteBlower support department.

        :return: the serial number of the hardware containing the license
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.SerialGet())

        """
        return _byteblower.ByteBlowerLicense_SerialGet(self)

    def NumberOfNonTrunksGet(self):
        r"""

        The maximum number of non-trunking interfaces allowed by the license

        :return: number of nontrunks
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.NumberOfNonTrunksGet())

        """
        return _byteblower.ByteBlowerLicense_NumberOfNonTrunksGet(self)

    def NumberOfTrunksGet(self):
        r"""

        The maximum number of trunking interfaces allowed by the license

        :return: number of trunking interfaces
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.NumberOfTrunksGet())

        """
        return _byteblower.ByteBlowerLicense_NumberOfTrunksGet(self)

    def NumberOfTrunkPortsGet(self, index):
        r"""

        The maximum number of ByteBlower Interfaces that can reside at the given trunk
        interface.

        :param index: Index of the trunk interface to obtain the value for.
        :type index: int

        :return: Allowed number of ByteBlower Interfaces on the physical interface
        :rtype int:

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.NumberOfTrunkPortsGet())

        """
        return _byteblower.ByteBlowerLicense_NumberOfTrunkPortsGet(self, index)

    def TimeConsumedGet(self):
        r"""

        The number of minutes the ByteBlower server has run on the license.

        This value has only a meaning when the license is a temporary (demo) license.

        :return: Number of minutes the ByteBlower server has used of the maximum allowed
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.TimeConsumedGet())


        """
        return _byteblower.ByteBlowerLicense_TimeConsumedGet(self)

    def TimeAllowedGet(self):
        r"""

        The number of minutes the ByteBlower server can run on the license.

        If the value is set to 4294967295, the license is permanent and the number
        should be treated as infinity.

        :return: Number of minutes the ByteBlower server can run.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.TimeAllowedGet())



        """
        return _byteblower.ByteBlowerLicense_TimeAllowedGet(self)

# Register ByteBlowerLicense in _byteblower:
_byteblower.ByteBlowerLicense_swigregister(ByteBlowerLicense)

class GroupSchedulableObject(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_GroupSchedulableObject

    def SetScheduleGroup(self, group):
        return _byteblower.GroupSchedulableObject_SetScheduleGroup(self, group)

    def UnsetScheduleGroup(self):
        return _byteblower.GroupSchedulableObject_UnsetScheduleGroup(self)

# Register GroupSchedulableObject in _byteblower:
_byteblower.GroupSchedulableObject_swigregister(GroupSchedulableObject)

class AbstractObjectList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.AbstractObjectList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.AbstractObjectList___nonzero__(self)

    def __bool__(self):
        return _byteblower.AbstractObjectList___bool__(self)

    def __len__(self):
        return _byteblower.AbstractObjectList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.AbstractObjectList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.AbstractObjectList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.AbstractObjectList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.AbstractObjectList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.AbstractObjectList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.AbstractObjectList___setitem__(self, *args)

    def pop(self):
        return _byteblower.AbstractObjectList_pop(self)

    def append(self, x):
        return _byteblower.AbstractObjectList_append(self, x)

    def empty(self):
        return _byteblower.AbstractObjectList_empty(self)

    def size(self):
        return _byteblower.AbstractObjectList_size(self)

    def swap(self, v):
        return _byteblower.AbstractObjectList_swap(self, v)

    def begin(self):
        return _byteblower.AbstractObjectList_begin(self)

    def end(self):
        return _byteblower.AbstractObjectList_end(self)

    def rbegin(self):
        return _byteblower.AbstractObjectList_rbegin(self)

    def rend(self):
        return _byteblower.AbstractObjectList_rend(self)

    def clear(self):
        return _byteblower.AbstractObjectList_clear(self)

    def get_allocator(self):
        return _byteblower.AbstractObjectList_get_allocator(self)

    def pop_back(self):
        return _byteblower.AbstractObjectList_pop_back(self)

    def erase(self, *args):
        return _byteblower.AbstractObjectList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.AbstractObjectList_swiginit(self, _byteblower.new_AbstractObjectList(*args))

    def push_back(self, x):
        return _byteblower.AbstractObjectList_push_back(self, x)

    def front(self):
        return _byteblower.AbstractObjectList_front(self)

    def back(self):
        return _byteblower.AbstractObjectList_back(self)

    def assign(self, n, x):
        return _byteblower.AbstractObjectList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.AbstractObjectList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.AbstractObjectList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.AbstractObjectList_reserve(self, n)

    def capacity(self):
        return _byteblower.AbstractObjectList_capacity(self)
    __swig_destroy__ = _byteblower.delete_AbstractObjectList

# Register AbstractObjectList in _byteblower:
_byteblower.AbstractObjectList_swigregister(AbstractObjectList)

ScheduleGroupStatus_Configuration = _byteblower.ScheduleGroupStatus_Configuration
ScheduleGroupStatus_Prepared = _byteblower.ScheduleGroupStatus_Prepared
ScheduleGroupStatus_Started = _byteblower.ScheduleGroupStatus_Started
ScheduleGroupStatus_Stopped = _byteblower.ScheduleGroupStatus_Stopped
ScheduleGroupStatus_Error = _byteblower.ScheduleGroupStatus_Error
class ScheduleGroup(AbstractObject):
    r"""

    A collection of schedulable objects that can be started.

    Example

    remove all members from the group

    .. code-block:: python

        scheduleGroup = bbInstance.ScheduleGroupCreate()
        scheduleGroup.MembersAdd(httpClient)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MembersGet(self):
        r"""

        Returns a list of ToopOIDs of the members of this group.

        :return: List of schedulable objects in order of addition. Possible empty.
                 Their individual object types depend on the types used in :meth:`MembersAdd`:

        HTTPClient
            Layer5.Http.Client

        ICMPEchoSession
            Layer3.ICMPEchoSession

        ICMPv6EchoSession
            Layer3.ICMPv6EchoSession

        Igmp Join
            Layer4.Igmp.Schedule.Join

        Igmp Leave
            Layer4.Igmp.Schedule.Leave

        Igmp IpMulticastListen
            Layer4.Igmp.Schedule.IpMulticastListen

        Mld StartListening
            Layer4.Mld.Schedule.StartListening

        Mld StopListening
            Layer4.Mld.Schedule.StopListening

        Mld Ipv6MulticastListen
            Layer4.Mld.Schedule.Ipv6MulticastListen

        TxStream
             Tx.Stream

        Example

        return the ObjectID of the members

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.MembersGet()[0].DescriptionGet())


        """
        return _byteblower.ScheduleGroup_MembersGet(self)

    def MembersLengthGet(self):
        r"""

        This method returns the number of members in the scheduleGroup.

        :return:  Size of memberlist

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 3

           print(scheduleGroup.MembersLengthGet())


        """
        return _byteblower.ScheduleGroup_MembersLengthGet(self)

    def MembersAdd(self, *args):
        r"""

        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: A ScheduleObject or Stream which will be added to the
                                  ScheduleGroup.

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)


        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: A ScheduleObject or Stream which will be added to the
                                  ScheduleGroup.

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)


        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: A ScheduleObject or Stream which will be added to the
                                  ScheduleGroup.

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)


        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.ScheduleGroup_MembersAdd(self, *args)

    def MembersRemove(self, *args):
        r"""

        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.ScheduleGroup_MembersRemove(self, *args)

    def MembersClear(self):
        r"""

        This method will remove all members from the schedulegroup.

        Example

        remove all members from the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersClear()



        """
        return _byteblower.ScheduleGroup_MembersClear(self)

    def Prepare(self):
        r"""

        This method will prepare all the schedules, but NOT start them.

        :raises: If - one of the Schedules fail to prepare, the others are canceled and
                 an exception is thrown. This exception will contain onformation about
                 the object which caused it.

        Example

        Preparing the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

        	scheduleGroup.Prepare()


        """
        return _byteblower.ScheduleGroup_Prepare(self)

    def Start(self):
        r"""

        This method will start the schedules. The Schedules must be in the prepared
        state.

        :raises: ByteBlower.Exception.ScheduleNotPrepared - The schedulegroup must be
                 prepared before it can be started.

        Example

        Start the ScheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

        	scheduleGroup.Start()



        """
        return _byteblower.ScheduleGroup_Start(self)

    def Stop(self):
        r"""

        This method will stop the schedules.

        :raises: ByteBlower.Exception.ScheduleNotRunning - You can only stop a schedule
                 that is running.

        Example

        Stop the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.stop()



        """
        return _byteblower.ScheduleGroup_Stop(self)

    def StatusGet(self):
        r"""

        Returns the status of the ScheduleGroup.

        :return: The status

        Valid status values are

        - configure
        - prepared
        - started
        - stopped
        - error

        Example

        Start the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.StatusGet())



        """
        return _byteblower.ScheduleGroup_StatusGet(self)

# Register ScheduleGroup in _byteblower:
_byteblower.ScheduleGroup_swigregister(ScheduleGroup)


def ConvertScheduleGroupStatusToString(inStatus):
    return _byteblower.ConvertScheduleGroupStatusToString(inStatus)
class ScheduleGroupList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ScheduleGroupList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ScheduleGroupList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ScheduleGroupList___bool__(self)

    def __len__(self):
        return _byteblower.ScheduleGroupList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ScheduleGroupList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ScheduleGroupList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ScheduleGroupList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ScheduleGroupList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ScheduleGroupList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ScheduleGroupList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ScheduleGroupList_pop(self)

    def append(self, x):
        return _byteblower.ScheduleGroupList_append(self, x)

    def empty(self):
        return _byteblower.ScheduleGroupList_empty(self)

    def size(self):
        return _byteblower.ScheduleGroupList_size(self)

    def swap(self, v):
        return _byteblower.ScheduleGroupList_swap(self, v)

    def begin(self):
        return _byteblower.ScheduleGroupList_begin(self)

    def end(self):
        return _byteblower.ScheduleGroupList_end(self)

    def rbegin(self):
        return _byteblower.ScheduleGroupList_rbegin(self)

    def rend(self):
        return _byteblower.ScheduleGroupList_rend(self)

    def clear(self):
        return _byteblower.ScheduleGroupList_clear(self)

    def get_allocator(self):
        return _byteblower.ScheduleGroupList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ScheduleGroupList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ScheduleGroupList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ScheduleGroupList_swiginit(self, _byteblower.new_ScheduleGroupList(*args))

    def push_back(self, x):
        return _byteblower.ScheduleGroupList_push_back(self, x)

    def front(self):
        return _byteblower.ScheduleGroupList_front(self)

    def back(self):
        return _byteblower.ScheduleGroupList_back(self)

    def assign(self, n, x):
        return _byteblower.ScheduleGroupList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ScheduleGroupList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ScheduleGroupList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ScheduleGroupList_reserve(self, n)

    def capacity(self):
        return _byteblower.ScheduleGroupList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ScheduleGroupList

# Register ScheduleGroupList in _byteblower:
_byteblower.ScheduleGroupList_swigregister(ScheduleGroupList)

class MeetingPoint(AbstractObject):
    r"""

    A MeetingPoint is a server that controls a set of wireless devices.

    .. versionadded 2.6.0

    Wireless Endpoints can connect to a Meeting Point by using the
    ByteBlower Wireless Endpoints App.

    Example

    .. code-block:: python
       :caption: Typical usage flow

       instance = ByteBlower.InstanceGet()

       meetingpoint = instance.MeetingPointAdd('byteblower-1.lab.byteblower.com')

       device = meetingpoint.DeviceGet('1234-1345-123')

       stream = device.TxStreamAdd()
       # ...

       device.Lock(True)
       device.Prepare()
       # ...


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def DeviceListLengthGet(self):
        r"""

        Returns the number of devices that are connected to the Meeting Point.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           meetingPoint.DeviceListLengthGet()



        """
        return _byteblower.MeetingPoint_DeviceListLengthGet(self)

    def DeviceGet(self, mobileDeviceId):
        r"""

        Returns the device that matches the given device identifier.

        :return: A :class:`.WirelessEndpoint` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

           wirelessEndpoint = meetingPoint.DeviceGet('1189-456dad-45654')


        """
        return _byteblower.MeetingPoint_DeviceGet(self, mobileDeviceId)

    def DeviceListGet(self):
        r"""

        Returns the list of devices that are connected to the Meeting Point.

        :return: A list with all known WirelessEndpoints
        :rtype: :class:`.WirelessEndpointList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device_list = meetingpoint.DeviceListGet()

        """
        return _byteblower.MeetingPoint_DeviceListGet(self)

    def DeviceDestroy(self, device):
        return _byteblower.MeetingPoint_DeviceDestroy(self, device)

    def DeviceIdentifiersGet(self):
        r"""

        Returns the list of device identifiers of the devices connected to the Meeting Point.

        :return: A list of device identifiers
        :rtype: :class:`StringList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device_list = meetingpoint.DeviceIdentifiersGet()


        """
        return _byteblower.MeetingPoint_DeviceIdentifiersGet(self)

    def TimestampGet(self):
        r"""

        Returns the current timestamp on the server.

        .. versionadded:: 2.3.0

        Retrieves the current timestamp of the server in nanoseconds. This can be used
        to calculate the offset between two servers to compare results.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3,4
           :caption: Get the current time from a MeetingPoint

           print(server.TimestampGet())
           # Returns 1432805398000000000


        """
        return _byteblower.MeetingPoint_TimestampGet(self)

    def ServiceInfoGet(self):
        r"""

        Returns the service information of the MeetingPoint daemon.

        .. versionadded:: 2.6.0

        :return: An object representing the service information
        :rtype: :class:`.MeetingPointServiceInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           meetingPoint.ServiceInfoGet()

        """
        return _byteblower.MeetingPoint_ServiceInfoGet(self)

    def UsersGet(self):
        r"""

        Shows which Wireless Endpoints of the (shared) MeetingPoint are currently used by which clients.

        This method gives an overview of how a MeetingPoint is currently used. It
        displays which client connections (whether from GUI scenario runs or API
        sessions) have created :class:`WirelessEndpoint` objects.

        Such a client connection to a meetingpoint is represented by this very
        :class:`MeetingPoint` type! As soon as some client instance (e.g. a Tcl shell
        or a GUI) on some client computer creates such meetingpoint object, a
        connection is established to that shared server.

        Multiple client instances can be active on the same host. For example, a single
        host may be running a GUI scenario, two Tcl scripts and an interactive Tcl
        session at the same time.  Similarly, a single client instance may have
        multiple parallel connections to the same server, by calling
        :meth:`ByteBlower.MeetingPointAdd` multiple times for the same server URL or IP.

        The server's physical interfaces are statically configured on the server
        machine and can be retrieved using :meth:`InterfacesGet`. They are shared among
        all connected clients.

        Client connections are identified by the client's hostname. This means that all
        server connections from all client instances on a single host will all be
        different 'users', but will have the same string representation. If they use
        the same interfaces, that hostname will simply appear multiple times.

        As soon as a specific MeetingPoint (representing a client connection) creates a
        first WirelessEndpoint, it is 'using' that WirelessEndpoint. The
        MeetingPoint is no longer used when all wireless endpoints created by that
        server on it are destroyed. Ports can be destroyed in the following ways:

        * Explicitly, by calling :meth:`.MeetingPoint.WirelessEndpointRemove`.
        * By destroying the :class:`.MeetingPoint` for that port. This is also what
          happens when a GUI finishes or cancels a scenario.
        * By destroying that client instances root :class:`.ByteBlower` object. This is
          also what happens when a client process (GUI or API) is killed.

        :return: A :class:`.UserMobileList` with an item for each user

        Example

        Assume three client instances are currently connected to this server. The first
        runs on John's PC, the second runs on Jane's PC and the last one is a second
        client instance connecting John's PC. Note the non-trunking interface is used
        by multiple client instances!

        .. code-block:: python
           :emphasize-lines: 1

        	users = meetingpoint.UsersGet()


        """
        return _byteblower.MeetingPoint_UsersGet(self)

    def DevicesStart(self, inDevices):
        r"""

        Starts all the given Wireless Endpoints.

        :param endpoints: a list on which to start the traffic, triggers and HTTPClients
        :type endpoints: :class:`.WirelessEndpointList`

        :return: Timestamp when the devices will start in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	meetingPoint.DevicesStart()



        """
        return _byteblower.MeetingPoint_DevicesStart(self, inDevices)

    def DevicesPrepare(self, inDevices):
        r"""

        Prepare all the given Wireless Endpoints.

        :param endpoints: A :class:`.WirelessEndpointList` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	meetingPoint.DevicesPrepare()


        """
        return _byteblower.MeetingPoint_DevicesPrepare(self, inDevices)

    def DevicesPrepareAsync(self, inDevices):
        r"""

        Prepares all the given Wireless Endpoints.

        After the meeting point is informed about the wish to prepare the endpoints the
        API directly returns. Call :meth:`DevicesPrepare` to wait until all devices are
        prepared.

        :param endpoints: A list of wireless endpoints to prepare.
        :type endpoints: :class:`.WirelessEndpointList`

        Example

        .. code-block:: python
           :emphasize-lines: 5-7,9
           :caption: Prepare a set of wireless endpoints at once.

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           device_1 = meetingpoint.DeviceGet('123-123-1')
           device_2 = meetingpoint.DeviceGet('123-123-2')

           device_list = WirelessEndpointList()
           device_list.push_back(device_1)
           device_list.push_back(device_2)

           meetingpoint.DevicesPrepareAsync(device_list)

        """
        return _byteblower.MeetingPoint_DevicesPrepareAsync(self, inDevices)

    def DevicesStartAll(self):
        r"""

        Starts all the known Wireless Endpoints.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	meetingPoint.DevicesStartAll()


        """
        return _byteblower.MeetingPoint_DevicesStartAll(self)

# Register MeetingPoint in _byteblower:
_byteblower.MeetingPoint_swigregister(MeetingPoint)

class MeetingPointServiceInfo(ServiceInfo):
    r"""



    This class contains information on the MeetingPoint System.

    With this object you can get information concerning the Type / version / IP or hostname etc... information.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       service_info = meetingpoint.ServiceInfoGet()

    .. versionadded:: 2.6.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LicenseGet(self):
        r"""

        Returns a license object for the MeetingPoint.

        .. deprecated:: 2.10

        Each physical ByteBlower Meetingpoint (represented by this type of object) has a specific ByteBlower License.

        :return: :class:`.MeetingPointLicense`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.LicenseGet())



        """
        return _byteblower.MeetingPointServiceInfo_LicenseGet(self)

    def ManagementIPAddressGet(self):
        r"""

        Returns all management IP addresses of the meeting point.

        :return:  List of management IP addresses

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ManagementIPAddressGet()[0])



        """
        return _byteblower.MeetingPointServiceInfo_ManagementIPAddressGet(self)

    def ConnectionHostGet(self):
        r"""

        Returns the host (either registered name or IP address)used to connect to the MeetingPoint.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(service_info.ConnectionHostGet())




        """
        return _byteblower.MeetingPointServiceInfo_ConnectionHostGet(self)

    def ConnectionIPAddressGet(self):
        r"""

        Returns the IP address used to connect to the meeting point.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ConnectionIPAddressGet())


        """
        return _byteblower.MeetingPointServiceInfo_ConnectionIPAddressGet(self)

    def ConnectionPortNumberGet(self):
        r"""

        Returns the TCP port number of the Meeting Point service daemon.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ConnectionPortNumberGet())



        """
        return _byteblower.MeetingPointServiceInfo_ConnectionPortNumberGet(self)

# Register MeetingPointServiceInfo in _byteblower:
_byteblower.MeetingPointServiceInfo_swigregister(MeetingPointServiceInfo)

class MeetingPointLicense(AbstractObject):
    r"""

    This class represents the license information of your connected Meeting Point.

    The license is defined by the security key hardware on your Meeting Point.

    .. versionadded:: 2.6.0

    .. deprecated::  2.10.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VersionGet(self):
        r"""

        :return:  the version of the license

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.VersionGet())



        """
        return _byteblower.MeetingPointLicense_VersionGet(self)

    def SerialGet(self):
        r"""

        Retrieves the serial number. This serial number is the serial number of the
        hardware containing the license. This is handy info when contacting the
        ByteBlower support department.

        :return:  the serial number of the hardware containing the license

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.SerialGet())



        """
        return _byteblower.MeetingPointLicense_SerialGet(self)

    def NumberOfWirelessEndpointsGet(self):
        r"""

        The maximum number of Wireless Endpoints that can be locked simultaneously

        :return: number of Wireless Endpoints

        .. code-block:: python
           :emphasize-lines: 1

           	print(meetingpointLicense.NumberOfWirelessEndpointsGet())



        """
        return _byteblower.MeetingPointLicense_NumberOfWirelessEndpointsGet(self)

    def TimeConsumedGet(self):
        r"""

        The number of minutes the Meeting Point has run on the license. This value has
        only a meaning when the license is a temporary (demo) license.

        :return: Number of minutes the Meeting Point has used of the maximum allowed

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.TimeConsumedGet())



        """
        return _byteblower.MeetingPointLicense_TimeConsumedGet(self)

    def TimeAllowedGet(self):
        r"""

        The number of minutes the Meeting Point can run on the license. If the value is
        set to 4294967295, the license is permanent and the number should be treated as
        infinity.

        :return:  Number of minutes the Meeting Point can run.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.TimeAllowedGet())



        """
        return _byteblower.MeetingPointLicense_TimeAllowedGet(self)

# Register MeetingPointLicense in _byteblower:
_byteblower.MeetingPointLicense_swigregister(MeetingPointLicense)

LogLevel_Debug = _byteblower.LogLevel_Debug
LogLevel_Info = _byteblower.LogLevel_Info
LogLevel_Warning = _byteblower.LogLevel_Warning
LogLevel_Error = _byteblower.LogLevel_Error
LogLevel_Critical = _byteblower.LogLevel_Critical
DeviceStatus_Unavailable = _byteblower.DeviceStatus_Unavailable
DeviceStatus_Available = _byteblower.DeviceStatus_Available
DeviceStatus_Reserved = _byteblower.DeviceStatus_Reserved
DeviceStatus_Starting = _byteblower.DeviceStatus_Starting
DeviceStatus_Running = _byteblower.DeviceStatus_Running

def ConvertLogLevelFromString(inLevel):
    return _byteblower.ConvertLogLevelFromString(inLevel)

def ConvertToString(inLevel):
    return _byteblower.ConvertToString(inLevel)
class WirelessEndpoint(AbstractObject):
    r"""

    A WirelessEndpoint is a handle to a wireless device-under-test.

    .. versionadded:: 2.6.0

    Example

    This example shows how to obtain a WirelessEndpoint object from a
    :class:`MeetingPoint` and configure a simple trigger.

    .. code-block:: python
       :caption: Typical flow to create a trigger on a wireless endpoint

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       device = meetingpoint.DeviceGet('00ff11-234-234')
       trigger = device.RxTriggerBasicAdd()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MeetingPointGet(self):
        r"""

        Returns the meetingpoint of this wireless endpoint.

        :return: A: class:`.MeetingPoint` object
        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(wirelessEndpoint.MeetingPointGet().DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_MeetingPointGet(self)

    def AppVersionGet(self):
        r"""

        Returns the App version.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.AppVersionGet())


        """
        return _byteblower.WirelessEndpoint_AppVersionGet(self)

    def DeviceIdentifierGet(self):
        r"""

        Returns device identifier.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.DeviceIdentifierGet())


        """
        return _byteblower.WirelessEndpoint_DeviceIdentifierGet(self)

    def CapabilityListGet(self):
        r"""

        Returns a list of Capability objects.

        .. versionadded:: 2.6.0

        :return: A :class:`.CapabilityList` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

            capabilityList = wirelessEndpoint.CapabilityListGet()


        """
        return _byteblower.WirelessEndpoint_CapabilityListGet(self)

    def CapabilityGetByName(self, name):
        r"""

        Returns a Capability object by its name.

        .. versionadded:: 2.6.0

        ::return: A :class:`.Capability`

        :raises: :exc:`.ConfigError` - UnsupportedConfig error message when the Capability is not supported

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.CapabilityGetByName('Tcp.Restart').DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_CapabilityGetByName(self, name)

    def CapabilityIsSupported(self, name):
        r"""

        Checks whether a capability is supported.

        .. versionadded:: 2.6.0

        :return: bool - True if it is supported, False if not

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.CapabilityIsSupported('Tcp.Restart'))

        """
        return _byteblower.WirelessEndpoint_CapabilityIsSupported(self, name)

    def DeviceInfoGet(self):
        r"""

        Returns an object with the Wireless Endpoint DeviceInfo.

        .. versionadded:: 2.6.0

        :return: <WirelessEndpoint.DeviceInfo object>

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.DeviceInfoGet().DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_DeviceInfoGet(self)

    def HeartbeatCountGet(self):
        r"""

        Returns the number of heartbeats performed by the device.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.HeartbeatCountGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatCountGet(self)

    def HeartbeatIntervalGet(self):
        r"""

        Returns the heartbeat interval.

        Default value is 1 second

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(self.wireless_endpoint.HeartbeatIntervalGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatIntervalGet(self)

    def HeartbeatIntervalSet(self, arg2):
        r"""

        Sets the heartbeat interval.

        .. note:: Minimum is 1 second

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.HeartbeatIntervalSet(50000000000)


        """
        return _byteblower.WirelessEndpoint_HeartbeatIntervalSet(self, arg2)

    def HeartbeatMaxFailcountGet(self):
        r"""

        Returns the maximum number of heartbeats that may fail before the Wireless Endpoint considers the communication broken.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(self.wireless_endpoint.HeartbeatMaxFailcountGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatMaxFailcountGet(self)

    def HeartbeatMaxFailcountSet(self, arg2):
        r"""

        Sets the maximum number of heartbeats that may fail before the Wireless Endpoint considers the communication broken.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.HeartbeatMaxFailcountSet(3)


        """
        return _byteblower.WirelessEndpoint_HeartbeatMaxFailcountSet(self, arg2)

    def HeartbeatTimestampLastGet(self):
        r"""

        Returns the timestamp of the last received heartbeat.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(self.wireless_endpoint.HeartbeatTimestampLastGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatTimestampLastGet(self)

    def Lock(self, arg2):
        r"""

        Locks or unlocks the device for exclusive access.

        :param lock: bool - True to lock, False to unlock

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	self.wireless_endpoint.Lock(True)


        """
        return _byteblower.WirelessEndpoint_Lock(self, arg2)

    def LockGet(self):
        r"""

        Indicates whether or not the device is locked.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.LockGet())


        """
        return _byteblower.WirelessEndpoint_LockGet(self)

    def LockOwnerGet(self):
        r"""

        Returns the name of the current lock owner.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(self.wireless_endpoint.LockOwnerGet())


        """
        return _byteblower.WirelessEndpoint_LockOwnerGet(self)

    def LockIsOwner(self):
        r"""

        Indicates whether or not we are the current owner of the lock.

        :return: bool - True when we have the lock.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(self.wireless_endpoint.LockIsOwner())


        """
        return _byteblower.WirelessEndpoint_LockIsOwner(self)

    def LockTry(self, lock, expected):
        r"""

        Tries to lock the Wireless Endpoint.

        :param lock: bool, whether to lock the device or not
        :param expected_state: bool The state the device currently is

        :return: bool: True if the operation succeeded, False if the operation failed

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.LockTry(False, True)


        """
        return _byteblower.WirelessEndpoint_LockTry(self, lock, expected)

    def LogGet(self):
        r"""

        Returns a string containing the device log messages.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.LogGet())


        """
        return _byteblower.WirelessEndpoint_LogGet(self)

    def LogClear(self):
        r"""

        Clears the log messages on the device.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           wirelessEndpoint.LogGet()


        """
        return _byteblower.WirelessEndpoint_LogClear(self)

    def LogLevelGet(self):
        r"""

        Gets the log level on the Wireless Endpoint.

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.WirelessEndpoint_LogLevelGet(self)

    def LogLevelSet(self, l):
        r"""

        Sets the log level on the Wireless Endpoint.

        Accepted log levels are DEBUG, INFO, WARNING, ERROR, CRITICAL

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.WirelessEndpoint_LogLevelSet(self, l)

    def ProtocolHttpClientAdd(self):
        r"""

        Adds a httpClient to this mobile device.

        :return: a :class:`.HttpClientMobile` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client = wirelessEndpoint.ProtocolHttpClientAdd()


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientAdd(self)

    def ProtocolHttpClientGet(self):
        r"""

        Returns the list of HTTP clients created on this mobile device.

        :return: A list of configured HTTP clients on the device.
        :rtype: :class:`.HttpClientMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for http_client in device.ProtocolHttpClientGet():
               print(http_client.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientGet(self)

    def ProtocolHttpClientRemove(self, arg2):
        return _byteblower.WirelessEndpoint_ProtocolHttpClientRemove(self, arg2)

    def RxTriggerBasicAdd(self):
        r"""

        Adding a RxTrigger to this mobile device.

        :return: :class:`.TriggerBasicMobile`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	trigger = self.wireless_endpoint.RxTriggerBasicAdd()


        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicAdd(self)

    def RxTriggerBasicGet(self):
        r"""

        Returns the list of receive triggers created on this mobile device.

        :return: :class:`.RxTriggerBasicMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.RxTriggerBasicGet()[0])


        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicGet(self)

    def RxTriggerBasicRemove(self, arg2):
        return _byteblower.WirelessEndpoint_RxTriggerBasicRemove(self, arg2)

    def RxLatencyBasicAdd(self):
        r"""

        Adding a RxLatency to this mobile device.

        :return: Rx.Latency.Basic.Mobile

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyTrigger = wirelessEndpoint.RxLatencyBasicAdd()


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicAdd(self)

    def RxLatencyBasicGet(self):
        r"""

        Returns the list of latency triggers created on this mobile device.

        :return: A :class:`.LatencyBasicMobileList` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

            for rxLatency in wirelessEndpoint.RxLatencyBasicGet():
        		print(rxLatency.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicGet(self)

    def RxLatencyBasicRemove(self, arg2):
        return _byteblower.WirelessEndpoint_RxLatencyBasicRemove(self, arg2)

    def TxStreamAdd(self):
        r"""

        Adding a :class:`StreamMobile` to this mobile device.

        :return: a :class:`.StreamMobile` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	stream = wirelessEndpoint.TxStreamAdd()


        """
        return _byteblower.WirelessEndpoint_TxStreamAdd(self)

    def TxStreamGet(self):
        r"""

        Returns the list of streams created on this mobile device.

        :return: A list of streams configured on the mobile device.
        :rtype: :class:`.StreamMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for stream in device.TxStreamGet():
               print(stream.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_TxStreamGet(self)

    def TxStreamRemove(self, arg2):
        return _byteblower.WirelessEndpoint_TxStreamRemove(self, arg2)

    def Prepare(self):
        r"""

        Prepare the device


        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.Prepare()


        """
        return _byteblower.WirelessEndpoint_Prepare(self)

    def PrepareAsync(self):
        r"""

        PrepareAsync.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.PrepareAsync()


        """
        return _byteblower.WirelessEndpoint_PrepareAsync(self)

    def Start(self):
        r"""

        Start.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.Start()


        """
        return _byteblower.WirelessEndpoint_Start(self)

    def StartAsync(self):
        r"""

        Start without waiting for confirmation.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.StartAsync()


        """
        return _byteblower.WirelessEndpoint_StartAsync(self)

    def ResultGet(self):
        r"""

        Request the results.

        Requests the result and waits for the reply. If a previous call to Request.Async was made then this call does not trigger a new request and instead waits for the async result.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.ResultGet())


        """
        return _byteblower.WirelessEndpoint_ResultGet(self)

    def ResultAsyncGet(self):
        r"""

        Request the results without waiting for the reply.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.WirelessEndpoint_ResultAsyncGet(self)

    def ResultClear(self):
        r"""

        Clear the result list on the device.

        TODO: does this affect the result snapshots too?

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device.ResultClear()

        """
        return _byteblower.WirelessEndpoint_ResultClear(self)

    def StatusGet(self):
        r"""

        Returns the device status.

        :return: :class:`.DeviceStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.StatusGet())


        """
        return _byteblower.WirelessEndpoint_StatusGet(self)

    def ScenarioDurationGet(self):
        return _byteblower.WirelessEndpoint_ScenarioDurationGet(self)

    def ScenarioDurationSet(self, arg2):
        return _byteblower.WirelessEndpoint_ScenarioDurationSet(self, arg2)

# Register WirelessEndpoint in _byteblower:
_byteblower.WirelessEndpoint_swigregister(WirelessEndpoint)

class MeetingPointList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.MeetingPointList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.MeetingPointList___nonzero__(self)

    def __bool__(self):
        return _byteblower.MeetingPointList___bool__(self)

    def __len__(self):
        return _byteblower.MeetingPointList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.MeetingPointList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.MeetingPointList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.MeetingPointList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.MeetingPointList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.MeetingPointList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.MeetingPointList___setitem__(self, *args)

    def pop(self):
        return _byteblower.MeetingPointList_pop(self)

    def append(self, x):
        return _byteblower.MeetingPointList_append(self, x)

    def empty(self):
        return _byteblower.MeetingPointList_empty(self)

    def size(self):
        return _byteblower.MeetingPointList_size(self)

    def swap(self, v):
        return _byteblower.MeetingPointList_swap(self, v)

    def begin(self):
        return _byteblower.MeetingPointList_begin(self)

    def end(self):
        return _byteblower.MeetingPointList_end(self)

    def rbegin(self):
        return _byteblower.MeetingPointList_rbegin(self)

    def rend(self):
        return _byteblower.MeetingPointList_rend(self)

    def clear(self):
        return _byteblower.MeetingPointList_clear(self)

    def get_allocator(self):
        return _byteblower.MeetingPointList_get_allocator(self)

    def pop_back(self):
        return _byteblower.MeetingPointList_pop_back(self)

    def erase(self, *args):
        return _byteblower.MeetingPointList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.MeetingPointList_swiginit(self, _byteblower.new_MeetingPointList(*args))

    def push_back(self, x):
        return _byteblower.MeetingPointList_push_back(self, x)

    def front(self):
        return _byteblower.MeetingPointList_front(self)

    def back(self):
        return _byteblower.MeetingPointList_back(self)

    def assign(self, n, x):
        return _byteblower.MeetingPointList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.MeetingPointList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.MeetingPointList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.MeetingPointList_reserve(self, n)

    def capacity(self):
        return _byteblower.MeetingPointList_capacity(self)
    __swig_destroy__ = _byteblower.delete_MeetingPointList

# Register MeetingPointList in _byteblower:
_byteblower.MeetingPointList_swigregister(MeetingPointList)

class WirelessEndpointList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.WirelessEndpointList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.WirelessEndpointList___nonzero__(self)

    def __bool__(self):
        return _byteblower.WirelessEndpointList___bool__(self)

    def __len__(self):
        return _byteblower.WirelessEndpointList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.WirelessEndpointList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.WirelessEndpointList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.WirelessEndpointList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.WirelessEndpointList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.WirelessEndpointList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.WirelessEndpointList___setitem__(self, *args)

    def pop(self):
        return _byteblower.WirelessEndpointList_pop(self)

    def append(self, x):
        return _byteblower.WirelessEndpointList_append(self, x)

    def empty(self):
        return _byteblower.WirelessEndpointList_empty(self)

    def size(self):
        return _byteblower.WirelessEndpointList_size(self)

    def swap(self, v):
        return _byteblower.WirelessEndpointList_swap(self, v)

    def begin(self):
        return _byteblower.WirelessEndpointList_begin(self)

    def end(self):
        return _byteblower.WirelessEndpointList_end(self)

    def rbegin(self):
        return _byteblower.WirelessEndpointList_rbegin(self)

    def rend(self):
        return _byteblower.WirelessEndpointList_rend(self)

    def clear(self):
        return _byteblower.WirelessEndpointList_clear(self)

    def get_allocator(self):
        return _byteblower.WirelessEndpointList_get_allocator(self)

    def pop_back(self):
        return _byteblower.WirelessEndpointList_pop_back(self)

    def erase(self, *args):
        return _byteblower.WirelessEndpointList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.WirelessEndpointList_swiginit(self, _byteblower.new_WirelessEndpointList(*args))

    def push_back(self, x):
        return _byteblower.WirelessEndpointList_push_back(self, x)

    def front(self):
        return _byteblower.WirelessEndpointList_front(self)

    def back(self):
        return _byteblower.WirelessEndpointList_back(self)

    def assign(self, n, x):
        return _byteblower.WirelessEndpointList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.WirelessEndpointList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.WirelessEndpointList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.WirelessEndpointList_reserve(self, n)

    def capacity(self):
        return _byteblower.WirelessEndpointList_capacity(self)
    __swig_destroy__ = _byteblower.delete_WirelessEndpointList

# Register WirelessEndpointList in _byteblower:
_byteblower.WirelessEndpointList_swigregister(WirelessEndpointList)

class CapabilityValue(AbstractObject):
    r"""

    The Capability Value class.

    A capability ( Capability ) can have a different type of value (INTEGER,
    BOOLEAN, STRING). Using :meth:`TypeGet` you can discover the value-type and
    then use the corresponding getter to get the real value


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Type_BOOLEAN = _byteblower.CapabilityValue_Type_BOOLEAN
    Type_INTEGER = _byteblower.CapabilityValue_Type_INTEGER
    Type_STRING = _byteblower.CapabilityValue_Type_STRING

    def StringGet(self):
        r"""

        Returns the value as a string.

        :return: The capability value as a string
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 7

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())


        """
        return _byteblower.CapabilityValue_StringGet(self)

    def IntegerGet(self):
        r"""

        Returns the value as an integer.

        :return: The value of the capability as an integer
        :rtype: long

        Example

        .. code-block:: python
           :emphasize-lines: 5

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())

        """
        return _byteblower.CapabilityValue_IntegerGet(self)

    def BooleanGet(self):
        r"""

        Returns the value as a boolean.

        :return: The value of the capability as a boolean (if possible)
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 3

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())

        """
        return _byteblower.CapabilityValue_BooleanGet(self)

    def TypeGet(self):
        r"""

        Returns the type of value.

        :return: The type of the value
        :rtype: TODO

        Example

        .. code-block:: python
           :emphasize-lines: 1

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())

        """
        return _byteblower.CapabilityValue_TypeGet(self)

# Register CapabilityValue in _byteblower:
_byteblower.CapabilityValue_swigregister(CapabilityValue)


def __lshift__(stream, type):
    return _byteblower.__lshift__(stream, type)
class Capability(AbstractObject):
    r"""

    Represents a capability, A feature it supports or not.

    Using this class, you can check if e.g. a WirelessEndpoint supports latency
    measurements or not

    Available Capabilities:
    - TODO
    - TODO

    Example

    .. code-block:: python
       :emphasize-lines: 3

    	from byteblowerll.byteblower import ByteBlower
    	server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
    	port = server.PortCreate('trunk-1-1')
    	capability_list = port.CapabilityListGet()
    	capability = capability_list[0]
    	# print version
    	print(capability.VersionAddedGet())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_Capability

    def NameGet(self):
        r"""

        Returns a human-readable name of the capability.

        :return: The human readable name of the capability.
        :rtype str:

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(capability.NameGet())

        """
        return _byteblower.Capability_NameGet(self)

    def CapabilityDescriptionGet(self):
        r"""

        Returns a human-readable description of the capability.

        :return: A human readable description
        :rtype: str

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(capability.CapabilityDescriptionGet())

        """
        return _byteblower.Capability_CapabilityDescriptionGet(self)

    def VersionAddedGet(self):
        r"""

        Returns the ByteBlower Server/ByteBlower MeetingPoint version since when this
        capability is added.

        :return: The server/meetingpoint version the capability was added
        :rtype: string

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(capability.VersionAddedGet())

        """
        return _byteblower.Capability_VersionAddedGet(self)

    def ValueGet(self):
        r"""

        Returns a CapabilityValue object.

        :return: the value of the capability
        :rtype: :class:`.CapabilityValue`


        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	capabilityValue = capability.ValueGet()

        """
        return _byteblower.Capability_ValueGet(self)

# Register Capability in _byteblower:
_byteblower.Capability_swigregister(Capability)

DeviceOsType_Android = _byteblower.DeviceOsType_Android
DeviceOsType_iOS = _byteblower.DeviceOsType_iOS
DeviceOsType_OSx = _byteblower.DeviceOsType_OSx
DeviceOsType_Linux = _byteblower.DeviceOsType_Linux
DeviceOsType_Windows = _byteblower.DeviceOsType_Windows
DeviceOsType_Unknown = _byteblower.DeviceOsType_Unknown
class DeviceInfo(AbstractObject):
    r"""

    Device information of the wireless endpoint.

    Contains all usefull device information of a wireless endpoint like OS,
    Network, Battery etc...

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 4

       from byteblowerll.byteblower import ByteBlower
       meetingPoint = bb.MeetingPointAdd('byteblower-tutorial-1300.lab.byteblower.excentis.com')
       weDevice = meetingPoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
       deviceInfo = weDevice.DeviceInfoGet()
       print(deviceInfo.BatteryLevelGet())

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BatteryLevelGet(self):
        r"""

        Returns the device's battery level.

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.BatteryLevelGet())

        """
        return _byteblower.DeviceInfo_BatteryLevelGet(self)

    def GivenNameGet(self):
        r"""

        Returns the user-provided device name.

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.GivenNameGet())

        """
        return _byteblower.DeviceInfo_GivenNameGet(self)

    def TypeGet(self):
        r"""

        Returns the type of device. I.e "iPad Air", "iPhone 6S", "Nexus 5x",
        etc...

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.TypeGet())

        """
        return _byteblower.DeviceInfo_TypeGet(self)

    def OsTypeGet(self):
        r"""

        Returns the OS type.

        :return: :class:`.DeviceOsType`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.OsTypeGet())

        """
        return _byteblower.DeviceInfo_OsTypeGet(self)

    def NetworkInfoGet(self):
        r"""

        Return the networkInfoObject containing all the network information of the Wireless Endpoint.

        :return: :class:`.NetworkInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           networkInfo = weDevice.NetworkInfoGet()

        """
        return _byteblower.DeviceInfo_NetworkInfoGet(self)

    def NetworkInfoMonitorAdd(self):
        r"""

        Creates a NetworkInfo monitor to be used during a scenario

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        :return: The newly created NetworkInfoMonitor
        :rtype: :class:`.NetworkInfoMonitor`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           monitor = weDevice.NetworkInfoMonitorAdd()

        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorAdd(self)

    def NetworkInfoMonitorGet(self):
        r"""

        Get the created NetworkInfo monitors

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        :return: A list of NetworkInfoMonitors
        :rtype: :class:`.NetworkInfoMonitorList`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           deviceInfo = weDevice.DeviceInfoGet()
           monitor = weDevice.NetworkInfoMonitorAdd()
           monitors = weDevice.NetworkInfoMonitorGet()

        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorGet(self)

    def NetworkInfoMonitorRemove(self, arg2):
        r"""

        Removes the specified NetworkInfoMonitor

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        :param monitor: The monitor to be removed
        :type monitor: :class:`.NetworkInfoMonitor`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           deviceInfo = weDevice.DeviceInfoGet()
           monitor = weDevice.NetworkInfoMonitorAdd()
           weDevice.NetworkInfoMonitorRemove(monitor)

        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorRemove(self, arg2)

    def OsVersionGet(self):
        r"""

        Returns the OS version.

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.OsVersionGet())

        """
        return _byteblower.DeviceInfo_OsVersionGet(self)

# Register DeviceInfo in _byteblower:
_byteblower.DeviceInfo_swigregister(DeviceInfo)

class NetworkInfo(AbstractObject):
    r"""

    Network information of the wireless endpoint.

    Contains all usefull network information of a wireless endpoint

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 5

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
       deviceInfo = wirelessendpoint.DeviceInfoGet()
       networkInfo = deviceInfo.NetworkInfoGet()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterfaceGet(self):
        r"""

        Returns a list of NetworkInterfaces 

        This list contains all the NetworkInterfaces detected on the device.
        Be aware that their are more networkinterfaces than you would expect.

        :return: :class:`.NetworkInterfaceList`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.InterfaceGet()[0].NameGet())


        """
        return _byteblower.NetworkInfo_InterfaceGet(self)

    def IPv4Get(self):
        r"""

        Returns a list of IPv4 addresses.

        This is a convenient method that will return the list of IPv4 addresses of the
        first interface. If you want the IP of a specific interface use the
        :meth:`InterfaceGet` method to retrieve them.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv4Get()[0])



        """
        return _byteblower.NetworkInfo_IPv4Get(self)

    def IPv6GlobalGet(self):
        r"""

        Returns a list of IPv6 global addresses.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv6GlobalGet()[0])


        """
        return _byteblower.NetworkInfo_IPv6GlobalGet(self)

    def IPv6LinkLocalGet(self):
        r"""

        Returns a list of IPv6 linklocal addresses.

        This is a convenient method to get a list of the IPv6 linkLocal addresses.
        If your WE has 2 active interfaces, only the first will be returned. You
        can use :meth:`InterfaceGet` to retrieve the interfaces

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv6LinkLocalGet()[0])



        """
        return _byteblower.NetworkInfo_IPv6LinkLocalGet(self)

    def SSIDGet(self):
        r"""

        Returns the SSID

        This is the first SSID discoverd by the wireless endpoint. If your device has
        more than 1 connected wireless interface. One of these will be shown here

        If you want to see the others, please use :meth:`InterfaceGet`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.SSIDGet())



        """
        return _byteblower.NetworkInfo_SSIDGet(self)

    def BSSIDGet(self):
        r"""

        Returns the BSSID

        This is the first BSSID discoverd by the wireless endpoint. If your device has
        more than 1 connected wireless interface. One of these will be shown here

        If you want to see the others, please use :meth:`InterfaceGet`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.BSSIDGet())



        """
        return _byteblower.NetworkInfo_BSSIDGet(self)

# Register NetworkInfo in _byteblower:
_byteblower.NetworkInfo_swigregister(NetworkInfo)

class NetworkInfoMonitorResultData(AbstractObject):
    r"""

    Result snapshot for the network information.

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	monitor = deviceInfo.NetworkInfoMonitorAdd()
    	history = monitor.ResultHistoryGet()
    	for item in history.IntervalGet():
    	    print(item.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Time in nanoseconds when the data was retrieved


        :return: Timestamp
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(interval.TimestampGet())


        """
        return _byteblower.NetworkInfoMonitorResultData_TimestampGet(self)

    def InterfaceGet(self):
        r"""

        Returns a list of network interfaces available on the device


        :return: List of network interfaces
        :rtype: :class:`.NetworkInterfaceList`

        Example

        .. code-block:: python
           :emphasize-lines: 1,3

                interfaces = interval.InterfacesGet()
                for interface in interfaces:
                    print(interface.DescriptionGet()


        """
        return _byteblower.NetworkInfoMonitorResultData_InterfaceGet(self)

    def IntervalDurationGet(self):
        r"""

        Duration in nanoseconds of the interval


        :return: Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(interval.IntervalDurationGet())


        """
        return _byteblower.NetworkInfoMonitorResultData_IntervalDurationGet(self)

# Register NetworkInfoMonitorResultData in _byteblower:
_byteblower.NetworkInfoMonitorResultData_swigregister(NetworkInfoMonitorResultData)

class NetworkInfoMonitorResultList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInfoMonitorResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInfoMonitorResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInfoMonitorResultList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInfoMonitorResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___setitem__(self, *args)

    def pop(self):
        return _byteblower.NetworkInfoMonitorResultList_pop(self)

    def append(self, x):
        return _byteblower.NetworkInfoMonitorResultList_append(self, x)

    def empty(self):
        return _byteblower.NetworkInfoMonitorResultList_empty(self)

    def size(self):
        return _byteblower.NetworkInfoMonitorResultList_size(self)

    def swap(self, v):
        return _byteblower.NetworkInfoMonitorResultList_swap(self, v)

    def begin(self):
        return _byteblower.NetworkInfoMonitorResultList_begin(self)

    def end(self):
        return _byteblower.NetworkInfoMonitorResultList_end(self)

    def rbegin(self):
        return _byteblower.NetworkInfoMonitorResultList_rbegin(self)

    def rend(self):
        return _byteblower.NetworkInfoMonitorResultList_rend(self)

    def clear(self):
        return _byteblower.NetworkInfoMonitorResultList_clear(self)

    def get_allocator(self):
        return _byteblower.NetworkInfoMonitorResultList_get_allocator(self)

    def pop_back(self):
        return _byteblower.NetworkInfoMonitorResultList_pop_back(self)

    def erase(self, *args):
        return _byteblower.NetworkInfoMonitorResultList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.NetworkInfoMonitorResultList_swiginit(self, _byteblower.new_NetworkInfoMonitorResultList(*args))

    def push_back(self, x):
        return _byteblower.NetworkInfoMonitorResultList_push_back(self, x)

    def front(self):
        return _byteblower.NetworkInfoMonitorResultList_front(self)

    def back(self):
        return _byteblower.NetworkInfoMonitorResultList_back(self)

    def assign(self, n, x):
        return _byteblower.NetworkInfoMonitorResultList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.NetworkInfoMonitorResultList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.NetworkInfoMonitorResultList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.NetworkInfoMonitorResultList_reserve(self, n)

    def capacity(self):
        return _byteblower.NetworkInfoMonitorResultList_capacity(self)
    __swig_destroy__ = _byteblower.delete_NetworkInfoMonitorResultList

# Register NetworkInfoMonitorResultList in _byteblower:
_byteblower.NetworkInfoMonitorResultList_swigregister(NetworkInfoMonitorResultList)

class NetworkInfoMonitorResultHistory(AbstractRefreshableResult):
    r"""

    History for the network info monitor representing the results over time

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	networkInfo = deviceInfo.NetworkInfoMonitorAdd()
    	history = networkInfo.ResultHistoryGet()
    	print(history.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clears all results of the monitor


        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Clear()


        """
        return _byteblower.NetworkInfoMonitorResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Returns the duration of one result interval

        :return: The duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(history.SamplingIntervalDurationGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one result interval

        :param duration: The duration in nanoseconds (default: 1 second)
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.SamplingIntervalDurationSet(2000000000)


        """
        return _byteblower.NetworkInfoMonitorResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def IntervalGet(self):
        r"""

        Returns the collected intervals

        :return: A list of the collected intervals
        :rtype: :class:`NetworkInfoMonitorResultList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	for interval in history.IntervalGet():
        	    print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Return an interval as specified by the index in the list

        :param index: number of the index in the list
        :type index: int

        :raises: :exc:`.ConfigError` - When the index is out of range

        :return: The specified interval snapshot
        :rtype: :class:`NetworkInfoMonitorResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	interval = history.IntervalGetByIndex(1):
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGetByIndex(self, index)

    def IntervalGetByTime(self, timestamp):
        r"""

        Return an interval as specified by the timestamp it was created

        :param timestamp: A timestamp in nanoseconds rounded to the second
        :type index: int

        :raises: :exc:`.ConfigError` - When the timestamp is out of range

        :return: The specified interval snapshot
        :rtype: :class:`NetworkInfoMonitorResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	interval = history.IntervalGetByTime(1568194819000000000):
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGetByTime(self, timestamp)

    def IntervalLatestGet(self):
        r"""

        Return the last interval snapshot created

        :return: The specified interval snapshot
        :rtype: :class:`NetworkInfoMonitorResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	interval = history.IntervalLatestGet():
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalLatestGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the number of collected interval snapshots


        :return: number of interval snapshots
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
                print(history.IntervalLengthGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Time in nanoseconds when the data was last retrieved


        :return: Timestamp
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
                print(history.RefreshTimestampGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_RefreshTimestampGet(self)

# Register NetworkInfoMonitorResultHistory in _byteblower:
_byteblower.NetworkInfoMonitorResultHistory_swigregister(NetworkInfoMonitorResultHistory)

class NetworkInfoMonitor(AbstractObject):
    r"""

    Monitor to collect the NetworkInfo over time

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	networkInfo = deviceInfo.NetworkInfoMonitorAdd()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultHistoryGet(self):
        r"""

        Returns the result history of the network monitor

        :return: The history object for the network monitor
        :rtype: :class:`.NetworkInfoMonitorResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(monitor.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitor_ResultHistoryGet(self)

# Register NetworkInfoMonitor in _byteblower:
_byteblower.NetworkInfoMonitor_swigregister(NetworkInfoMonitor)

NetworkInterfaceType_Unknown = _byteblower.NetworkInterfaceType_Unknown
NetworkInterfaceType_Loopback = _byteblower.NetworkInterfaceType_Loopback
NetworkInterfaceType_Ethernet = _byteblower.NetworkInterfaceType_Ethernet
NetworkInterfaceType_WiFi = _byteblower.NetworkInterfaceType_WiFi

def NetworkInterfaceTypeToString(t):
    return _byteblower.NetworkInterfaceTypeToString(t)
class NetworkInterface(AbstractObject):
    r"""

    NetworkInterface information of the wireless endpoint.

    Represents a network interface of a wireless endpoint.

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	etworkInfo = deviceInfo.NetworkInfoGet()
    	networkInterface = networkInfo.InterfaceGet()[0]


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        r"""

        Returns the type of a network interface.

        This can be used to distinguish e.g. WiFi interfaces from others

        :return: The type of the network interface
        :rtype: :class:`.NetworkInterfaceType`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.TypeGet() == NetworkInterfaceType.WiFi)

        """
        return _byteblower.NetworkInterface_TypeGet(self)

    def NameGet(self):
        r"""


        Returns the name of the interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.NameGet())



        """
        return _byteblower.NetworkInterface_NameGet(self)

    def DisplayNameGet(self):
        r"""

        Returns the display name of the interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.DisplayNameGet())



        """
        return _byteblower.NetworkInterface_DisplayNameGet(self)

    def MacGet(self):
        r"""

        Returns the mac-address of the interface.

        On some platforms (e.g. iOS) this isn't allowed so a fake address will be
        returned.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.MacGet())



        """
        return _byteblower.NetworkInterface_MacGet(self)

    def IPv4Get(self):
        r"""

        Returns a list of IPv4 addresses of this interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.IPv4Get())



        """
        return _byteblower.NetworkInterface_IPv4Get(self)

    def IPv6GlobalGet(self):
        r"""

        Returns a list of the Global IPv6 addresses of this interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.IPv6GlobalGet())



        """
        return _byteblower.NetworkInterface_IPv6GlobalGet(self)

    def IPv6LinkLocalGet(self):
        r"""

        Returns a list of the LinkLocal addresses of this interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.IPv6LinkLocalGet())



        """
        return _byteblower.NetworkInterface_IPv6LinkLocalGet(self)

    def WiFiSsidGet(self):
        r"""

        Returns the SSID of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return an empty string

        :return: The SSID of the network interface
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiSsidGet())
        	# Prints e.g. MyFavoriteNetwork

        """
        return _byteblower.NetworkInterface_WiFiSsidGet(self)

    def WiFiBssidGet(self):
        r"""

        Returns the BSSID of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return an empty string

        :return: The BSSID of the network interface in colon-delimited format
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiBssidGet())
        	# prints e.g. 00:bb:1b:00:12:22

        """
        return _byteblower.NetworkInterface_WiFiBssidGet(self)

    def WiFiRssiGet(self):
        r"""

        Returns the RSSI of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -127

        :return: The RSSI of the network interface in dBm
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiRssiGet())
        	# prints e.g. -67

        """
        return _byteblower.NetworkInterface_WiFiRssiGet(self)

    def WiFiTxRateGet(self):
        r"""

        Returns the announced maximum transmit speed of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        :return: The maximum transmit speed of the network interface in Mbps
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiTxRateGet())
        	# prints e.g. 54

        """
        return _byteblower.NetworkInterface_WiFiTxRateGet(self)

    def WiFiChannelGet(self):
        r"""

        Returns the channel of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        :return: The channel of the network interface
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiChannelGet())
        	# prints e.g. 9

        """
        return _byteblower.NetworkInterface_WiFiChannelGet(self)

# Register NetworkInterface in _byteblower:
_byteblower.NetworkInterface_swigregister(NetworkInterface)

class NetworkInterfaceList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInterfaceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.NetworkInterfaceList_pop(self)

    def append(self, x):
        return _byteblower.NetworkInterfaceList_append(self, x)

    def empty(self):
        return _byteblower.NetworkInterfaceList_empty(self)

    def size(self):
        return _byteblower.NetworkInterfaceList_size(self)

    def swap(self, v):
        return _byteblower.NetworkInterfaceList_swap(self, v)

    def begin(self):
        return _byteblower.NetworkInterfaceList_begin(self)

    def end(self):
        return _byteblower.NetworkInterfaceList_end(self)

    def rbegin(self):
        return _byteblower.NetworkInterfaceList_rbegin(self)

    def rend(self):
        return _byteblower.NetworkInterfaceList_rend(self)

    def clear(self):
        return _byteblower.NetworkInterfaceList_clear(self)

    def get_allocator(self):
        return _byteblower.NetworkInterfaceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.NetworkInterfaceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.NetworkInterfaceList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.NetworkInterfaceList_swiginit(self, _byteblower.new_NetworkInterfaceList(*args))

    def push_back(self, x):
        return _byteblower.NetworkInterfaceList_push_back(self, x)

    def front(self):
        return _byteblower.NetworkInterfaceList_front(self)

    def back(self):
        return _byteblower.NetworkInterfaceList_back(self)

    def assign(self, n, x):
        return _byteblower.NetworkInterfaceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.NetworkInterfaceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.NetworkInterfaceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.NetworkInterfaceList_reserve(self, n)

    def capacity(self):
        return _byteblower.NetworkInterfaceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_NetworkInterfaceList

# Register NetworkInterfaceList in _byteblower:
_byteblower.NetworkInterfaceList_swigregister(NetworkInterfaceList)

class Stats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Stats_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Stats___nonzero__(self)

    def __bool__(self):
        return _byteblower.Stats___bool__(self)

    def __len__(self):
        return _byteblower.Stats___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.Stats___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.Stats___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.Stats_has_key(self, key)

    def keys(self):
        return _byteblower.Stats_keys(self)

    def values(self):
        return _byteblower.Stats_values(self)

    def items(self):
        return _byteblower.Stats_items(self)

    def __contains__(self, key):
        return _byteblower.Stats___contains__(self, key)

    def key_iterator(self):
        return _byteblower.Stats_key_iterator(self)

    def value_iterator(self):
        return _byteblower.Stats_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.Stats___setitem__(self, *args)

    def asdict(self):
        return _byteblower.Stats_asdict(self)

    def __init__(self, *args):
        _byteblower.Stats_swiginit(self, _byteblower.new_Stats(*args))

    def empty(self):
        return _byteblower.Stats_empty(self)

    def size(self):
        return _byteblower.Stats_size(self)

    def swap(self, v):
        return _byteblower.Stats_swap(self, v)

    def begin(self):
        return _byteblower.Stats_begin(self)

    def end(self):
        return _byteblower.Stats_end(self)

    def rbegin(self):
        return _byteblower.Stats_rbegin(self)

    def rend(self):
        return _byteblower.Stats_rend(self)

    def clear(self):
        return _byteblower.Stats_clear(self)

    def get_allocator(self):
        return _byteblower.Stats_get_allocator(self)

    def count(self, x):
        return _byteblower.Stats_count(self, x)

    def erase(self, *args):
        return _byteblower.Stats_erase(self, *args)

    def find(self, x):
        return _byteblower.Stats_find(self, x)

    def lower_bound(self, x):
        return _byteblower.Stats_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.Stats_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_Stats

# Register Stats in _byteblower:
_byteblower.Stats_swigregister(Stats)

class StatsList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StatsList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StatsList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StatsList___bool__(self)

    def __len__(self):
        return _byteblower.StatsList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StatsList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StatsList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StatsList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StatsList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StatsList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StatsList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StatsList_pop(self)

    def append(self, x):
        return _byteblower.StatsList_append(self, x)

    def empty(self):
        return _byteblower.StatsList_empty(self)

    def size(self):
        return _byteblower.StatsList_size(self)

    def swap(self, v):
        return _byteblower.StatsList_swap(self, v)

    def begin(self):
        return _byteblower.StatsList_begin(self)

    def end(self):
        return _byteblower.StatsList_end(self)

    def rbegin(self):
        return _byteblower.StatsList_rbegin(self)

    def rend(self):
        return _byteblower.StatsList_rend(self)

    def clear(self):
        return _byteblower.StatsList_clear(self)

    def get_allocator(self):
        return _byteblower.StatsList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StatsList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StatsList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.StatsList_swiginit(self, _byteblower.new_StatsList(*args))

    def push_back(self, x):
        return _byteblower.StatsList_push_back(self, x)

    def front(self):
        return _byteblower.StatsList_front(self)

    def back(self):
        return _byteblower.StatsList_back(self)

    def assign(self, n, x):
        return _byteblower.StatsList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StatsList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StatsList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StatsList_reserve(self, n)

    def capacity(self):
        return _byteblower.StatsList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StatsList

# Register StatsList in _byteblower:
_byteblower.StatsList_swigregister(StatsList)

class StatsByTime(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StatsByTime_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StatsByTime___nonzero__(self)

    def __bool__(self):
        return _byteblower.StatsByTime___bool__(self)

    def __len__(self):
        return _byteblower.StatsByTime___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.StatsByTime___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.StatsByTime___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.StatsByTime_has_key(self, key)

    def keys(self):
        return _byteblower.StatsByTime_keys(self)

    def values(self):
        return _byteblower.StatsByTime_values(self)

    def items(self):
        return _byteblower.StatsByTime_items(self)

    def __contains__(self, key):
        return _byteblower.StatsByTime___contains__(self, key)

    def key_iterator(self):
        return _byteblower.StatsByTime_key_iterator(self)

    def value_iterator(self):
        return _byteblower.StatsByTime_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.StatsByTime___setitem__(self, *args)

    def asdict(self):
        return _byteblower.StatsByTime_asdict(self)

    def __init__(self, *args):
        _byteblower.StatsByTime_swiginit(self, _byteblower.new_StatsByTime(*args))

    def empty(self):
        return _byteblower.StatsByTime_empty(self)

    def size(self):
        return _byteblower.StatsByTime_size(self)

    def swap(self, v):
        return _byteblower.StatsByTime_swap(self, v)

    def begin(self):
        return _byteblower.StatsByTime_begin(self)

    def end(self):
        return _byteblower.StatsByTime_end(self)

    def rbegin(self):
        return _byteblower.StatsByTime_rbegin(self)

    def rend(self):
        return _byteblower.StatsByTime_rend(self)

    def clear(self):
        return _byteblower.StatsByTime_clear(self)

    def get_allocator(self):
        return _byteblower.StatsByTime_get_allocator(self)

    def count(self, x):
        return _byteblower.StatsByTime_count(self, x)

    def erase(self, *args):
        return _byteblower.StatsByTime_erase(self, *args)

    def find(self, x):
        return _byteblower.StatsByTime_find(self, x)

    def lower_bound(self, x):
        return _byteblower.StatsByTime_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.StatsByTime_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_StatsByTime

# Register StatsByTime in _byteblower:
_byteblower.StatsByTime_swigregister(StatsByTime)

class Int64StringMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Int64StringMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Int64StringMap___nonzero__(self)

    def __bool__(self):
        return _byteblower.Int64StringMap___bool__(self)

    def __len__(self):
        return _byteblower.Int64StringMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.Int64StringMap___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.Int64StringMap___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.Int64StringMap_has_key(self, key)

    def keys(self):
        return _byteblower.Int64StringMap_keys(self)

    def values(self):
        return _byteblower.Int64StringMap_values(self)

    def items(self):
        return _byteblower.Int64StringMap_items(self)

    def __contains__(self, key):
        return _byteblower.Int64StringMap___contains__(self, key)

    def key_iterator(self):
        return _byteblower.Int64StringMap_key_iterator(self)

    def value_iterator(self):
        return _byteblower.Int64StringMap_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.Int64StringMap___setitem__(self, *args)

    def asdict(self):
        return _byteblower.Int64StringMap_asdict(self)

    def __init__(self, *args):
        _byteblower.Int64StringMap_swiginit(self, _byteblower.new_Int64StringMap(*args))

    def empty(self):
        return _byteblower.Int64StringMap_empty(self)

    def size(self):
        return _byteblower.Int64StringMap_size(self)

    def swap(self, v):
        return _byteblower.Int64StringMap_swap(self, v)

    def begin(self):
        return _byteblower.Int64StringMap_begin(self)

    def end(self):
        return _byteblower.Int64StringMap_end(self)

    def rbegin(self):
        return _byteblower.Int64StringMap_rbegin(self)

    def rend(self):
        return _byteblower.Int64StringMap_rend(self)

    def clear(self):
        return _byteblower.Int64StringMap_clear(self)

    def get_allocator(self):
        return _byteblower.Int64StringMap_get_allocator(self)

    def count(self, x):
        return _byteblower.Int64StringMap_count(self, x)

    def erase(self, *args):
        return _byteblower.Int64StringMap_erase(self, *args)

    def find(self, x):
        return _byteblower.Int64StringMap_find(self, x)

    def lower_bound(self, x):
        return _byteblower.Int64StringMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.Int64StringMap_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_Int64StringMap

# Register Int64StringMap in _byteblower:
_byteblower.Int64StringMap_swigregister(Int64StringMap)

class Buffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Buffer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Buffer___nonzero__(self)

    def __bool__(self):
        return _byteblower.Buffer___bool__(self)

    def __len__(self):
        return _byteblower.Buffer___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Buffer___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Buffer___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Buffer___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Buffer___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Buffer___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Buffer___setitem__(self, *args)

    def pop(self):
        return _byteblower.Buffer_pop(self)

    def append(self, x):
        return _byteblower.Buffer_append(self, x)

    def empty(self):
        return _byteblower.Buffer_empty(self)

    def size(self):
        return _byteblower.Buffer_size(self)

    def swap(self, v):
        return _byteblower.Buffer_swap(self, v)

    def begin(self):
        return _byteblower.Buffer_begin(self)

    def end(self):
        return _byteblower.Buffer_end(self)

    def rbegin(self):
        return _byteblower.Buffer_rbegin(self)

    def rend(self):
        return _byteblower.Buffer_rend(self)

    def clear(self):
        return _byteblower.Buffer_clear(self)

    def get_allocator(self):
        return _byteblower.Buffer_get_allocator(self)

    def pop_back(self):
        return _byteblower.Buffer_pop_back(self)

    def erase(self, *args):
        return _byteblower.Buffer_erase(self, *args)

    def __init__(self, *args):
        _byteblower.Buffer_swiginit(self, _byteblower.new_Buffer(*args))

    def push_back(self, x):
        return _byteblower.Buffer_push_back(self, x)

    def front(self):
        return _byteblower.Buffer_front(self)

    def back(self):
        return _byteblower.Buffer_back(self)

    def assign(self, n, x):
        return _byteblower.Buffer_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Buffer_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Buffer_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Buffer_reserve(self, n)

    def capacity(self):
        return _byteblower.Buffer_capacity(self)
    __swig_destroy__ = _byteblower.delete_Buffer

# Register Buffer in _byteblower:
_byteblower.Buffer_swigregister(Buffer)

class BufferList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.BufferList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.BufferList___nonzero__(self)

    def __bool__(self):
        return _byteblower.BufferList___bool__(self)

    def __len__(self):
        return _byteblower.BufferList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.BufferList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.BufferList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.BufferList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.BufferList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.BufferList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.BufferList___setitem__(self, *args)

    def pop(self):
        return _byteblower.BufferList_pop(self)

    def append(self, x):
        return _byteblower.BufferList_append(self, x)

    def empty(self):
        return _byteblower.BufferList_empty(self)

    def size(self):
        return _byteblower.BufferList_size(self)

    def swap(self, v):
        return _byteblower.BufferList_swap(self, v)

    def begin(self):
        return _byteblower.BufferList_begin(self)

    def end(self):
        return _byteblower.BufferList_end(self)

    def rbegin(self):
        return _byteblower.BufferList_rbegin(self)

    def rend(self):
        return _byteblower.BufferList_rend(self)

    def clear(self):
        return _byteblower.BufferList_clear(self)

    def get_allocator(self):
        return _byteblower.BufferList_get_allocator(self)

    def pop_back(self):
        return _byteblower.BufferList_pop_back(self)

    def erase(self, *args):
        return _byteblower.BufferList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.BufferList_swiginit(self, _byteblower.new_BufferList(*args))

    def push_back(self, x):
        return _byteblower.BufferList_push_back(self, x)

    def front(self):
        return _byteblower.BufferList_front(self)

    def back(self):
        return _byteblower.BufferList_back(self)

    def assign(self, n, x):
        return _byteblower.BufferList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.BufferList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.BufferList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.BufferList_reserve(self, n)

    def capacity(self):
        return _byteblower.BufferList_capacity(self)
    __swig_destroy__ = _byteblower.delete_BufferList

# Register BufferList in _byteblower:
_byteblower.BufferList_swigregister(BufferList)

class Int64List(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Int64List_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Int64List___nonzero__(self)

    def __bool__(self):
        return _byteblower.Int64List___bool__(self)

    def __len__(self):
        return _byteblower.Int64List___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Int64List___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Int64List___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Int64List___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Int64List___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Int64List___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Int64List___setitem__(self, *args)

    def pop(self):
        return _byteblower.Int64List_pop(self)

    def append(self, x):
        return _byteblower.Int64List_append(self, x)

    def empty(self):
        return _byteblower.Int64List_empty(self)

    def size(self):
        return _byteblower.Int64List_size(self)

    def swap(self, v):
        return _byteblower.Int64List_swap(self, v)

    def begin(self):
        return _byteblower.Int64List_begin(self)

    def end(self):
        return _byteblower.Int64List_end(self)

    def rbegin(self):
        return _byteblower.Int64List_rbegin(self)

    def rend(self):
        return _byteblower.Int64List_rend(self)

    def clear(self):
        return _byteblower.Int64List_clear(self)

    def get_allocator(self):
        return _byteblower.Int64List_get_allocator(self)

    def pop_back(self):
        return _byteblower.Int64List_pop_back(self)

    def erase(self, *args):
        return _byteblower.Int64List_erase(self, *args)

    def __init__(self, *args):
        _byteblower.Int64List_swiginit(self, _byteblower.new_Int64List(*args))

    def push_back(self, x):
        return _byteblower.Int64List_push_back(self, x)

    def front(self):
        return _byteblower.Int64List_front(self)

    def back(self):
        return _byteblower.Int64List_back(self)

    def assign(self, n, x):
        return _byteblower.Int64List_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Int64List_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Int64List_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Int64List_reserve(self, n)

    def capacity(self):
        return _byteblower.Int64List_capacity(self)
    __swig_destroy__ = _byteblower.delete_Int64List

# Register Int64List in _byteblower:
_byteblower.Int64List_swigregister(Int64List)

class IntegerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IntegerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IntegerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IntegerList___bool__(self)

    def __len__(self):
        return _byteblower.IntegerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IntegerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IntegerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IntegerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IntegerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IntegerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IntegerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.IntegerList_pop(self)

    def append(self, x):
        return _byteblower.IntegerList_append(self, x)

    def empty(self):
        return _byteblower.IntegerList_empty(self)

    def size(self):
        return _byteblower.IntegerList_size(self)

    def swap(self, v):
        return _byteblower.IntegerList_swap(self, v)

    def begin(self):
        return _byteblower.IntegerList_begin(self)

    def end(self):
        return _byteblower.IntegerList_end(self)

    def rbegin(self):
        return _byteblower.IntegerList_rbegin(self)

    def rend(self):
        return _byteblower.IntegerList_rend(self)

    def clear(self):
        return _byteblower.IntegerList_clear(self)

    def get_allocator(self):
        return _byteblower.IntegerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.IntegerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.IntegerList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.IntegerList_swiginit(self, _byteblower.new_IntegerList(*args))

    def push_back(self, x):
        return _byteblower.IntegerList_push_back(self, x)

    def front(self):
        return _byteblower.IntegerList_front(self)

    def back(self):
        return _byteblower.IntegerList_back(self)

    def assign(self, n, x):
        return _byteblower.IntegerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.IntegerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.IntegerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.IntegerList_reserve(self, n)

    def capacity(self):
        return _byteblower.IntegerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_IntegerList

# Register IntegerList in _byteblower:
_byteblower.IntegerList_swigregister(IntegerList)

class UnsignedIntegerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UnsignedIntegerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UnsignedIntegerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UnsignedIntegerList___bool__(self)

    def __len__(self):
        return _byteblower.UnsignedIntegerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UnsignedIntegerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UnsignedIntegerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UnsignedIntegerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UnsignedIntegerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UnsignedIntegerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UnsignedIntegerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.UnsignedIntegerList_pop(self)

    def append(self, x):
        return _byteblower.UnsignedIntegerList_append(self, x)

    def empty(self):
        return _byteblower.UnsignedIntegerList_empty(self)

    def size(self):
        return _byteblower.UnsignedIntegerList_size(self)

    def swap(self, v):
        return _byteblower.UnsignedIntegerList_swap(self, v)

    def begin(self):
        return _byteblower.UnsignedIntegerList_begin(self)

    def end(self):
        return _byteblower.UnsignedIntegerList_end(self)

    def rbegin(self):
        return _byteblower.UnsignedIntegerList_rbegin(self)

    def rend(self):
        return _byteblower.UnsignedIntegerList_rend(self)

    def clear(self):
        return _byteblower.UnsignedIntegerList_clear(self)

    def get_allocator(self):
        return _byteblower.UnsignedIntegerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.UnsignedIntegerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.UnsignedIntegerList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.UnsignedIntegerList_swiginit(self, _byteblower.new_UnsignedIntegerList(*args))

    def push_back(self, x):
        return _byteblower.UnsignedIntegerList_push_back(self, x)

    def front(self):
        return _byteblower.UnsignedIntegerList_front(self)

    def back(self):
        return _byteblower.UnsignedIntegerList_back(self)

    def assign(self, n, x):
        return _byteblower.UnsignedIntegerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.UnsignedIntegerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.UnsignedIntegerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.UnsignedIntegerList_reserve(self, n)

    def capacity(self):
        return _byteblower.UnsignedIntegerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_UnsignedIntegerList

# Register UnsignedIntegerList in _byteblower:
_byteblower.UnsignedIntegerList_swigregister(UnsignedIntegerList)

class StringList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StringList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StringList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StringList___bool__(self)

    def __len__(self):
        return _byteblower.StringList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StringList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StringList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StringList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StringList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StringList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StringList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StringList_pop(self)

    def append(self, x):
        return _byteblower.StringList_append(self, x)

    def empty(self):
        return _byteblower.StringList_empty(self)

    def size(self):
        return _byteblower.StringList_size(self)

    def swap(self, v):
        return _byteblower.StringList_swap(self, v)

    def begin(self):
        return _byteblower.StringList_begin(self)

    def end(self):
        return _byteblower.StringList_end(self)

    def rbegin(self):
        return _byteblower.StringList_rbegin(self)

    def rend(self):
        return _byteblower.StringList_rend(self)

    def clear(self):
        return _byteblower.StringList_clear(self)

    def get_allocator(self):
        return _byteblower.StringList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StringList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StringList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.StringList_swiginit(self, _byteblower.new_StringList(*args))

    def push_back(self, x):
        return _byteblower.StringList_push_back(self, x)

    def front(self):
        return _byteblower.StringList_front(self)

    def back(self):
        return _byteblower.StringList_back(self)

    def assign(self, n, x):
        return _byteblower.StringList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StringList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StringList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StringList_reserve(self, n)

    def capacity(self):
        return _byteblower.StringList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StringList

# Register StringList in _byteblower:
_byteblower.StringList_swigregister(StringList)

class Int64Pair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.Int64Pair_swiginit(self, _byteblower.new_Int64Pair(*args))
    first = property(_byteblower.Int64Pair_first_get, _byteblower.Int64Pair_first_set)
    second = property(_byteblower.Int64Pair_second_get, _byteblower.Int64Pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _byteblower.delete_Int64Pair

# Register Int64Pair in _byteblower:
_byteblower.Int64Pair_swigregister(Int64Pair)

class AbstractRefreshableResultList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.AbstractRefreshableResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.AbstractRefreshableResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.AbstractRefreshableResultList___bool__(self)

    def __len__(self):
        return _byteblower.AbstractRefreshableResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.AbstractRefreshableResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.AbstractRefreshableResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.AbstractRefreshableResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___setitem__(self, *args)

    def pop(self):
        return _byteblower.AbstractRefreshableResultList_pop(self)

    def append(self, x):
        return _byteblower.AbstractRefreshableResultList_append(self, x)

    def empty(self):
        return _byteblower.AbstractRefreshableResultList_empty(self)

    def size(self):
        return _byteblower.AbstractRefreshableResultList_size(self)

    def swap(self, v):
        return _byteblower.AbstractRefreshableResultList_swap(self, v)

    def begin(self):
        return _byteblower.AbstractRefreshableResultList_begin(self)

    def end(self):
        return _byteblower.AbstractRefreshableResultList_end(self)

    def rbegin(self):
        return _byteblower.AbstractRefreshableResultList_rbegin(self)

    def rend(self):
        return _byteblower.AbstractRefreshableResultList_rend(self)

    def clear(self):
        return _byteblower.AbstractRefreshableResultList_clear(self)

    def get_allocator(self):
        return _byteblower.AbstractRefreshableResultList_get_allocator(self)

    def pop_back(self):
        return _byteblower.AbstractRefreshableResultList_pop_back(self)

    def erase(self, *args):
        return _byteblower.AbstractRefreshableResultList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.AbstractRefreshableResultList_swiginit(self, _byteblower.new_AbstractRefreshableResultList(*args))

    def push_back(self, x):
        return _byteblower.AbstractRefreshableResultList_push_back(self, x)

    def front(self):
        return _byteblower.AbstractRefreshableResultList_front(self)

    def back(self):
        return _byteblower.AbstractRefreshableResultList_back(self)

    def assign(self, n, x):
        return _byteblower.AbstractRefreshableResultList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.AbstractRefreshableResultList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.AbstractRefreshableResultList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.AbstractRefreshableResultList_reserve(self, n)

    def capacity(self):
        return _byteblower.AbstractRefreshableResultList_capacity(self)
    __swig_destroy__ = _byteblower.delete_AbstractRefreshableResultList

# Register AbstractRefreshableResultList in _byteblower:
_byteblower.AbstractRefreshableResultList_swigregister(AbstractRefreshableResultList)

class UserList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UserList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UserList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UserList___bool__(self)

    def __len__(self):
        return _byteblower.UserList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UserList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UserList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UserList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UserList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UserList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UserList___setitem__(self, *args)

    def pop(self):
        return _byteblower.UserList_pop(self)

    def append(self, x):
        return _byteblower.UserList_append(self, x)

    def empty(self):
        return _byteblower.UserList_empty(self)

    def size(self):
        return _byteblower.UserList_size(self)

    def swap(self, v):
        return _byteblower.UserList_swap(self, v)

    def begin(self):
        return _byteblower.UserList_begin(self)

    def end(self):
        return _byteblower.UserList_end(self)

    def rbegin(self):
        return _byteblower.UserList_rbegin(self)

    def rend(self):
        return _byteblower.UserList_rend(self)

    def clear(self):
        return _byteblower.UserList_clear(self)

    def get_allocator(self):
        return _byteblower.UserList_get_allocator(self)

    def pop_back(self):
        return _byteblower.UserList_pop_back(self)

    def erase(self, *args):
        return _byteblower.UserList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.UserList_swiginit(self, _byteblower.new_UserList(*args))

    def push_back(self, x):
        return _byteblower.UserList_push_back(self, x)

    def front(self):
        return _byteblower.UserList_front(self)

    def back(self):
        return _byteblower.UserList_back(self)

    def assign(self, n, x):
        return _byteblower.UserList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.UserList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.UserList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.UserList_reserve(self, n)

    def capacity(self):
        return _byteblower.UserList_capacity(self)
    __swig_destroy__ = _byteblower.delete_UserList

# Register UserList in _byteblower:
_byteblower.UserList_swigregister(UserList)

class UserMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UserMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UserMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UserMobileList___bool__(self)

    def __len__(self):
        return _byteblower.UserMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UserMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UserMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UserMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UserMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UserMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UserMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.UserMobileList_pop(self)

    def append(self, x):
        return _byteblower.UserMobileList_append(self, x)

    def empty(self):
        return _byteblower.UserMobileList_empty(self)

    def size(self):
        return _byteblower.UserMobileList_size(self)

    def swap(self, v):
        return _byteblower.UserMobileList_swap(self, v)

    def begin(self):
        return _byteblower.UserMobileList_begin(self)

    def end(self):
        return _byteblower.UserMobileList_end(self)

    def rbegin(self):
        return _byteblower.UserMobileList_rbegin(self)

    def rend(self):
        return _byteblower.UserMobileList_rend(self)

    def clear(self):
        return _byteblower.UserMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.UserMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.UserMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.UserMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.UserMobileList_swiginit(self, _byteblower.new_UserMobileList(*args))

    def push_back(self, x):
        return _byteblower.UserMobileList_push_back(self, x)

    def front(self):
        return _byteblower.UserMobileList_front(self)

    def back(self):
        return _byteblower.UserMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.UserMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.UserMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.UserMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.UserMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.UserMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_UserMobileList

# Register UserMobileList in _byteblower:
_byteblower.UserMobileList_swigregister(UserMobileList)

class ByteBlowerServerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerServerList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerServerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerServerList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerServerList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerServerList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerServerList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerServerList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerServerList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerServerList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerServerList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerServerList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerServerList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerServerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerServerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerServerList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerServerList_swiginit(self, _byteblower.new_ByteBlowerServerList(*args))

    def push_back(self, x):
        return _byteblower.ByteBlowerServerList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerServerList_front(self)

    def back(self):
        return _byteblower.ByteBlowerServerList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerServerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerServerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerServerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerServerList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerServerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerList

# Register ByteBlowerServerList in _byteblower:
_byteblower.ByteBlowerServerList_swigregister(ByteBlowerServerList)

class PhysicalInterfaceList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.PhysicalInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.PhysicalInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.PhysicalInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.PhysicalInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.PhysicalInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.PhysicalInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.PhysicalInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.PhysicalInterfaceList_pop(self)

    def append(self, x):
        return _byteblower.PhysicalInterfaceList_append(self, x)

    def empty(self):
        return _byteblower.PhysicalInterfaceList_empty(self)

    def size(self):
        return _byteblower.PhysicalInterfaceList_size(self)

    def swap(self, v):
        return _byteblower.PhysicalInterfaceList_swap(self, v)

    def begin(self):
        return _byteblower.PhysicalInterfaceList_begin(self)

    def end(self):
        return _byteblower.PhysicalInterfaceList_end(self)

    def rbegin(self):
        return _byteblower.PhysicalInterfaceList_rbegin(self)

    def rend(self):
        return _byteblower.PhysicalInterfaceList_rend(self)

    def clear(self):
        return _byteblower.PhysicalInterfaceList_clear(self)

    def get_allocator(self):
        return _byteblower.PhysicalInterfaceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.PhysicalInterfaceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.PhysicalInterfaceList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.PhysicalInterfaceList_swiginit(self, _byteblower.new_PhysicalInterfaceList(*args))

    def push_back(self, x):
        return _byteblower.PhysicalInterfaceList_push_back(self, x)

    def front(self):
        return _byteblower.PhysicalInterfaceList_front(self)

    def back(self):
        return _byteblower.PhysicalInterfaceList_back(self)

    def assign(self, n, x):
        return _byteblower.PhysicalInterfaceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.PhysicalInterfaceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.PhysicalInterfaceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.PhysicalInterfaceList_reserve(self, n)

    def capacity(self):
        return _byteblower.PhysicalInterfaceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_PhysicalInterfaceList

# Register PhysicalInterfaceList in _byteblower:
_byteblower.PhysicalInterfaceList_swigregister(PhysicalInterfaceList)

class ByteBlowerInterfaceList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerInterfaceList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerInterfaceList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerInterfaceList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerInterfaceList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerInterfaceList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerInterfaceList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerInterfaceList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerInterfaceList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerInterfaceList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerInterfaceList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerInterfaceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerInterfaceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerInterfaceList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerInterfaceList_swiginit(self, _byteblower.new_ByteBlowerInterfaceList(*args))

    def push_back(self, x):
        return _byteblower.ByteBlowerInterfaceList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerInterfaceList_front(self)

    def back(self):
        return _byteblower.ByteBlowerInterfaceList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerInterfaceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerInterfaceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerInterfaceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerInterfaceList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerInterfaceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerInterfaceList

# Register ByteBlowerInterfaceList in _byteblower:
_byteblower.ByteBlowerInterfaceList_swigregister(ByteBlowerInterfaceList)

class ByteBlowerPortList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerPortList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerPortList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerPortList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerPortList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerPortList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerPortList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerPortList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerPortList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerPortList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerPortList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerPortList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerPortList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerPortList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerPortList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerPortList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerPortList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerPortList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerPortList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerPortList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerPortList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerPortList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerPortList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerPortList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerPortList_swiginit(self, _byteblower.new_ByteBlowerPortList(*args))

    def push_back(self, x):
        return _byteblower.ByteBlowerPortList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerPortList_front(self)

    def back(self):
        return _byteblower.ByteBlowerPortList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerPortList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerPortList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerPortList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerPortList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerPortList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerPortList

# Register ByteBlowerPortList in _byteblower:
_byteblower.ByteBlowerPortList_swigregister(ByteBlowerPortList)

class Layer25VlanList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Layer25VlanList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Layer25VlanList___nonzero__(self)

    def __bool__(self):
        return _byteblower.Layer25VlanList___bool__(self)

    def __len__(self):
        return _byteblower.Layer25VlanList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Layer25VlanList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Layer25VlanList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Layer25VlanList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Layer25VlanList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Layer25VlanList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Layer25VlanList___setitem__(self, *args)

    def pop(self):
        return _byteblower.Layer25VlanList_pop(self)

    def append(self, x):
        return _byteblower.Layer25VlanList_append(self, x)

    def empty(self):
        return _byteblower.Layer25VlanList_empty(self)

    def size(self):
        return _byteblower.Layer25VlanList_size(self)

    def swap(self, v):
        return _byteblower.Layer25VlanList_swap(self, v)

    def begin(self):
        return _byteblower.Layer25VlanList_begin(self)

    def end(self):
        return _byteblower.Layer25VlanList_end(self)

    def rbegin(self):
        return _byteblower.Layer25VlanList_rbegin(self)

    def rend(self):
        return _byteblower.Layer25VlanList_rend(self)

    def clear(self):
        return _byteblower.Layer25VlanList_clear(self)

    def get_allocator(self):
        return _byteblower.Layer25VlanList_get_allocator(self)

    def pop_back(self):
        return _byteblower.Layer25VlanList_pop_back(self)

    def erase(self, *args):
        return _byteblower.Layer25VlanList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.Layer25VlanList_swiginit(self, _byteblower.new_Layer25VlanList(*args))

    def push_back(self, x):
        return _byteblower.Layer25VlanList_push_back(self, x)

    def front(self):
        return _byteblower.Layer25VlanList_front(self)

    def back(self):
        return _byteblower.Layer25VlanList_back(self)

    def assign(self, n, x):
        return _byteblower.Layer25VlanList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Layer25VlanList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Layer25VlanList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Layer25VlanList_reserve(self, n)

    def capacity(self):
        return _byteblower.Layer25VlanList_capacity(self)
    __swig_destroy__ = _byteblower.delete_Layer25VlanList

# Register Layer25VlanList in _byteblower:
_byteblower.Layer25VlanList_swigregister(Layer25VlanList)

class Layer25PPPoEList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Layer25PPPoEList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Layer25PPPoEList___nonzero__(self)

    def __bool__(self):
        return _byteblower.Layer25PPPoEList___bool__(self)

    def __len__(self):
        return _byteblower.Layer25PPPoEList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Layer25PPPoEList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Layer25PPPoEList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Layer25PPPoEList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Layer25PPPoEList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Layer25PPPoEList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Layer25PPPoEList___setitem__(self, *args)

    def pop(self):
        return _byteblower.Layer25PPPoEList_pop(self)

    def append(self, x):
        return _byteblower.Layer25PPPoEList_append(self, x)

    def empty(self):
        return _byteblower.Layer25PPPoEList_empty(self)

    def size(self):
        return _byteblower.Layer25PPPoEList_size(self)

    def swap(self, v):
        return _byteblower.Layer25PPPoEList_swap(self, v)

    def begin(self):
        return _byteblower.Layer25PPPoEList_begin(self)

    def end(self):
        return _byteblower.Layer25PPPoEList_end(self)

    def rbegin(self):
        return _byteblower.Layer25PPPoEList_rbegin(self)

    def rend(self):
        return _byteblower.Layer25PPPoEList_rend(self)

    def clear(self):
        return _byteblower.Layer25PPPoEList_clear(self)

    def get_allocator(self):
        return _byteblower.Layer25PPPoEList_get_allocator(self)

    def pop_back(self):
        return _byteblower.Layer25PPPoEList_pop_back(self)

    def erase(self, *args):
        return _byteblower.Layer25PPPoEList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.Layer25PPPoEList_swiginit(self, _byteblower.new_Layer25PPPoEList(*args))

    def push_back(self, x):
        return _byteblower.Layer25PPPoEList_push_back(self, x)

    def front(self):
        return _byteblower.Layer25PPPoEList_front(self)

    def back(self):
        return _byteblower.Layer25PPPoEList_back(self)

    def assign(self, n, x):
        return _byteblower.Layer25PPPoEList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Layer25PPPoEList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Layer25PPPoEList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Layer25PPPoEList_reserve(self, n)

    def capacity(self):
        return _byteblower.Layer25PPPoEList_capacity(self)
    __swig_destroy__ = _byteblower.delete_Layer25PPPoEList

# Register Layer25PPPoEList in _byteblower:
_byteblower.Layer25PPPoEList_swigregister(Layer25PPPoEList)

class ScheduleList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ScheduleList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ScheduleList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ScheduleList___bool__(self)

    def __len__(self):
        return _byteblower.ScheduleList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ScheduleList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ScheduleList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ScheduleList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ScheduleList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ScheduleList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ScheduleList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ScheduleList_pop(self)

    def append(self, x):
        return _byteblower.ScheduleList_append(self, x)

    def empty(self):
        return _byteblower.ScheduleList_empty(self)

    def size(self):
        return _byteblower.ScheduleList_size(self)

    def swap(self, v):
        return _byteblower.ScheduleList_swap(self, v)

    def begin(self):
        return _byteblower.ScheduleList_begin(self)

    def end(self):
        return _byteblower.ScheduleList_end(self)

    def rbegin(self):
        return _byteblower.ScheduleList_rbegin(self)

    def rend(self):
        return _byteblower.ScheduleList_rend(self)

    def clear(self):
        return _byteblower.ScheduleList_clear(self)

    def get_allocator(self):
        return _byteblower.ScheduleList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ScheduleList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ScheduleList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ScheduleList_swiginit(self, _byteblower.new_ScheduleList(*args))

    def push_back(self, x):
        return _byteblower.ScheduleList_push_back(self, x)

    def front(self):
        return _byteblower.ScheduleList_front(self)

    def back(self):
        return _byteblower.ScheduleList_back(self)

    def assign(self, n, x):
        return _byteblower.ScheduleList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ScheduleList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ScheduleList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ScheduleList_reserve(self, n)

    def capacity(self):
        return _byteblower.ScheduleList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ScheduleList

# Register ScheduleList in _byteblower:
_byteblower.ScheduleList_swigregister(ScheduleList)

class StreamList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamList___bool__(self)

    def __len__(self):
        return _byteblower.StreamList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StreamList_pop(self)

    def append(self, x):
        return _byteblower.StreamList_append(self, x)

    def empty(self):
        return _byteblower.StreamList_empty(self)

    def size(self):
        return _byteblower.StreamList_size(self)

    def swap(self, v):
        return _byteblower.StreamList_swap(self, v)

    def begin(self):
        return _byteblower.StreamList_begin(self)

    def end(self):
        return _byteblower.StreamList_end(self)

    def rbegin(self):
        return _byteblower.StreamList_rbegin(self)

    def rend(self):
        return _byteblower.StreamList_rend(self)

    def clear(self):
        return _byteblower.StreamList_clear(self)

    def get_allocator(self):
        return _byteblower.StreamList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StreamList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StreamList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.StreamList_swiginit(self, _byteblower.new_StreamList(*args))

    def push_back(self, x):
        return _byteblower.StreamList_push_back(self, x)

    def front(self):
        return _byteblower.StreamList_front(self)

    def back(self):
        return _byteblower.StreamList_back(self)

    def assign(self, n, x):
        return _byteblower.StreamList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StreamList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StreamList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StreamList_reserve(self, n)

    def capacity(self):
        return _byteblower.StreamList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StreamList

# Register StreamList in _byteblower:
_byteblower.StreamList_swigregister(StreamList)

class StreamMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamMobileList___bool__(self)

    def __len__(self):
        return _byteblower.StreamMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StreamMobileList_pop(self)

    def append(self, x):
        return _byteblower.StreamMobileList_append(self, x)

    def empty(self):
        return _byteblower.StreamMobileList_empty(self)

    def size(self):
        return _byteblower.StreamMobileList_size(self)

    def swap(self, v):
        return _byteblower.StreamMobileList_swap(self, v)

    def begin(self):
        return _byteblower.StreamMobileList_begin(self)

    def end(self):
        return _byteblower.StreamMobileList_end(self)

    def rbegin(self):
        return _byteblower.StreamMobileList_rbegin(self)

    def rend(self):
        return _byteblower.StreamMobileList_rend(self)

    def clear(self):
        return _byteblower.StreamMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.StreamMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StreamMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StreamMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.StreamMobileList_swiginit(self, _byteblower.new_StreamMobileList(*args))

    def push_back(self, x):
        return _byteblower.StreamMobileList_push_back(self, x)

    def front(self):
        return _byteblower.StreamMobileList_front(self)

    def back(self):
        return _byteblower.StreamMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.StreamMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StreamMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StreamMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StreamMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.StreamMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StreamMobileList

# Register StreamMobileList in _byteblower:
_byteblower.StreamMobileList_swigregister(StreamMobileList)

class FrameList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameList___bool__(self)

    def __len__(self):
        return _byteblower.FrameList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameList_pop(self)

    def append(self, x):
        return _byteblower.FrameList_append(self, x)

    def empty(self):
        return _byteblower.FrameList_empty(self)

    def size(self):
        return _byteblower.FrameList_size(self)

    def swap(self, v):
        return _byteblower.FrameList_swap(self, v)

    def begin(self):
        return _byteblower.FrameList_begin(self)

    def end(self):
        return _byteblower.FrameList_end(self)

    def rbegin(self):
        return _byteblower.FrameList_rbegin(self)

    def rend(self):
        return _byteblower.FrameList_rend(self)

    def clear(self):
        return _byteblower.FrameList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.FrameList_swiginit(self, _byteblower.new_FrameList(*args))

    def push_back(self, x):
        return _byteblower.FrameList_push_back(self, x)

    def front(self):
        return _byteblower.FrameList_front(self)

    def back(self):
        return _byteblower.FrameList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameList

# Register FrameList in _byteblower:
_byteblower.FrameList_swigregister(FrameList)

class FrameMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameMobileList___bool__(self)

    def __len__(self):
        return _byteblower.FrameMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameMobileList_pop(self)

    def append(self, x):
        return _byteblower.FrameMobileList_append(self, x)

    def empty(self):
        return _byteblower.FrameMobileList_empty(self)

    def size(self):
        return _byteblower.FrameMobileList_size(self)

    def swap(self, v):
        return _byteblower.FrameMobileList_swap(self, v)

    def begin(self):
        return _byteblower.FrameMobileList_begin(self)

    def end(self):
        return _byteblower.FrameMobileList_end(self)

    def rbegin(self):
        return _byteblower.FrameMobileList_rbegin(self)

    def rend(self):
        return _byteblower.FrameMobileList_rend(self)

    def clear(self):
        return _byteblower.FrameMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.FrameMobileList_swiginit(self, _byteblower.new_FrameMobileList(*args))

    def push_back(self, x):
        return _byteblower.FrameMobileList_push_back(self, x)

    def front(self):
        return _byteblower.FrameMobileList_front(self)

    def back(self):
        return _byteblower.FrameMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameMobileList

# Register FrameMobileList in _byteblower:
_byteblower.FrameMobileList_swigregister(FrameMobileList)

class FrameModifierFieldRandomList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameModifierFieldRandomList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameModifierFieldRandomList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameModifierFieldRandomList___bool__(self)

    def __len__(self):
        return _byteblower.FrameModifierFieldRandomList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameModifierFieldRandomList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameModifierFieldRandomList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameModifierFieldRandomList_pop(self)

    def append(self, x):
        return _byteblower.FrameModifierFieldRandomList_append(self, x)

    def empty(self):
        return _byteblower.FrameModifierFieldRandomList_empty(self)

    def size(self):
        return _byteblower.FrameModifierFieldRandomList_size(self)

    def swap(self, v):
        return _byteblower.FrameModifierFieldRandomList_swap(self, v)

    def begin(self):
        return _byteblower.FrameModifierFieldRandomList_begin(self)

    def end(self):
        return _byteblower.FrameModifierFieldRandomList_end(self)

    def rbegin(self):
        return _byteblower.FrameModifierFieldRandomList_rbegin(self)

    def rend(self):
        return _byteblower.FrameModifierFieldRandomList_rend(self)

    def clear(self):
        return _byteblower.FrameModifierFieldRandomList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameModifierFieldRandomList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameModifierFieldRandomList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameModifierFieldRandomList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.FrameModifierFieldRandomList_swiginit(self, _byteblower.new_FrameModifierFieldRandomList(*args))

    def push_back(self, x):
        return _byteblower.FrameModifierFieldRandomList_push_back(self, x)

    def front(self):
        return _byteblower.FrameModifierFieldRandomList_front(self)

    def back(self):
        return _byteblower.FrameModifierFieldRandomList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameModifierFieldRandomList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameModifierFieldRandomList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameModifierFieldRandomList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameModifierFieldRandomList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameModifierFieldRandomList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameModifierFieldRandomList

# Register FrameModifierFieldRandomList in _byteblower:
_byteblower.FrameModifierFieldRandomList_swigregister(FrameModifierFieldRandomList)

class FrameModifierFieldIncrementalList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameModifierFieldIncrementalList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameModifierFieldIncrementalList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameModifierFieldIncrementalList___bool__(self)

    def __len__(self):
        return _byteblower.FrameModifierFieldIncrementalList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameModifierFieldIncrementalList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameModifierFieldIncrementalList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameModifierFieldIncrementalList_pop(self)

    def append(self, x):
        return _byteblower.FrameModifierFieldIncrementalList_append(self, x)

    def empty(self):
        return _byteblower.FrameModifierFieldIncrementalList_empty(self)

    def size(self):
        return _byteblower.FrameModifierFieldIncrementalList_size(self)

    def swap(self, v):
        return _byteblower.FrameModifierFieldIncrementalList_swap(self, v)

    def begin(self):
        return _byteblower.FrameModifierFieldIncrementalList_begin(self)

    def end(self):
        return _byteblower.FrameModifierFieldIncrementalList_end(self)

    def rbegin(self):
        return _byteblower.FrameModifierFieldIncrementalList_rbegin(self)

    def rend(self):
        return _byteblower.FrameModifierFieldIncrementalList_rend(self)

    def clear(self):
        return _byteblower.FrameModifierFieldIncrementalList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameModifierFieldIncrementalList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameModifierFieldIncrementalList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.FrameModifierFieldIncrementalList_swiginit(self, _byteblower.new_FrameModifierFieldIncrementalList(*args))

    def push_back(self, x):
        return _byteblower.FrameModifierFieldIncrementalList_push_back(self, x)

    def front(self):
        return _byteblower.FrameModifierFieldIncrementalList_front(self)

    def back(self):
        return _byteblower.FrameModifierFieldIncrementalList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameModifierFieldIncrementalList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameModifierFieldIncrementalList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameModifierFieldIncrementalList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameModifierFieldIncrementalList

# Register FrameModifierFieldIncrementalList in _byteblower:
_byteblower.FrameModifierFieldIncrementalList_swigregister(FrameModifierFieldIncrementalList)

class TriggerBasicList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerBasicList_pop(self)

    def append(self, x):
        return _byteblower.TriggerBasicList_append(self, x)

    def empty(self):
        return _byteblower.TriggerBasicList_empty(self)

    def size(self):
        return _byteblower.TriggerBasicList_size(self)

    def swap(self, v):
        return _byteblower.TriggerBasicList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerBasicList_begin(self)

    def end(self):
        return _byteblower.TriggerBasicList_end(self)

    def rbegin(self):
        return _byteblower.TriggerBasicList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerBasicList_rend(self)

    def clear(self):
        return _byteblower.TriggerBasicList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerBasicList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerBasicList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerBasicList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TriggerBasicList_swiginit(self, _byteblower.new_TriggerBasicList(*args))

    def push_back(self, x):
        return _byteblower.TriggerBasicList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerBasicList_front(self)

    def back(self):
        return _byteblower.TriggerBasicList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerBasicList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerBasicList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerBasicList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerBasicList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerBasicList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerBasicList

# Register TriggerBasicList in _byteblower:
_byteblower.TriggerBasicList_swigregister(TriggerBasicList)

class TriggerBasicMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicMobileList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerBasicMobileList_pop(self)

    def append(self, x):
        return _byteblower.TriggerBasicMobileList_append(self, x)

    def empty(self):
        return _byteblower.TriggerBasicMobileList_empty(self)

    def size(self):
        return _byteblower.TriggerBasicMobileList_size(self)

    def swap(self, v):
        return _byteblower.TriggerBasicMobileList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerBasicMobileList_begin(self)

    def end(self):
        return _byteblower.TriggerBasicMobileList_end(self)

    def rbegin(self):
        return _byteblower.TriggerBasicMobileList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerBasicMobileList_rend(self)

    def clear(self):
        return _byteblower.TriggerBasicMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerBasicMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerBasicMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerBasicMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TriggerBasicMobileList_swiginit(self, _byteblower.new_TriggerBasicMobileList(*args))

    def push_back(self, x):
        return _byteblower.TriggerBasicMobileList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerBasicMobileList_front(self)

    def back(self):
        return _byteblower.TriggerBasicMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerBasicMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerBasicMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerBasicMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerBasicMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerBasicMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerBasicMobileList

# Register TriggerBasicMobileList in _byteblower:
_byteblower.TriggerBasicMobileList_swigregister(TriggerBasicMobileList)

class TriggerSizeDistributionList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerSizeDistributionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerSizeDistributionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerSizeDistributionList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerSizeDistributionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerSizeDistributionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerSizeDistributionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerSizeDistributionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerSizeDistributionList_pop(self)

    def append(self, x):
        return _byteblower.TriggerSizeDistributionList_append(self, x)

    def empty(self):
        return _byteblower.TriggerSizeDistributionList_empty(self)

    def size(self):
        return _byteblower.TriggerSizeDistributionList_size(self)

    def swap(self, v):
        return _byteblower.TriggerSizeDistributionList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerSizeDistributionList_begin(self)

    def end(self):
        return _byteblower.TriggerSizeDistributionList_end(self)

    def rbegin(self):
        return _byteblower.TriggerSizeDistributionList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerSizeDistributionList_rend(self)

    def clear(self):
        return _byteblower.TriggerSizeDistributionList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerSizeDistributionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerSizeDistributionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerSizeDistributionList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TriggerSizeDistributionList_swiginit(self, _byteblower.new_TriggerSizeDistributionList(*args))

    def push_back(self, x):
        return _byteblower.TriggerSizeDistributionList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerSizeDistributionList_front(self)

    def back(self):
        return _byteblower.TriggerSizeDistributionList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerSizeDistributionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerSizeDistributionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerSizeDistributionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerSizeDistributionList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerSizeDistributionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerSizeDistributionList

# Register TriggerSizeDistributionList in _byteblower:
_byteblower.TriggerSizeDistributionList_swigregister(TriggerSizeDistributionList)

class LatencyBasicList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyBasicList_swiginit(self, _byteblower.new_LatencyBasicList(*args))

    def push_back(self, x):
        return _byteblower.LatencyBasicList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicList_front(self)

    def back(self):
        return _byteblower.LatencyBasicList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicList

# Register LatencyBasicList in _byteblower:
_byteblower.LatencyBasicList_swigregister(LatencyBasicList)

class LatencyBasicMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicMobileList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicMobileList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicMobileList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicMobileList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicMobileList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicMobileList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicMobileList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicMobileList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicMobileList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicMobileList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyBasicMobileList_swiginit(self, _byteblower.new_LatencyBasicMobileList(*args))

    def push_back(self, x):
        return _byteblower.LatencyBasicMobileList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicMobileList_front(self)

    def back(self):
        return _byteblower.LatencyBasicMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicMobileList

# Register LatencyBasicMobileList in _byteblower:
_byteblower.LatencyBasicMobileList_swigregister(LatencyBasicMobileList)

class LatencyDistributionList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyDistributionList_pop(self)

    def append(self, x):
        return _byteblower.LatencyDistributionList_append(self, x)

    def empty(self):
        return _byteblower.LatencyDistributionList_empty(self)

    def size(self):
        return _byteblower.LatencyDistributionList_size(self)

    def swap(self, v):
        return _byteblower.LatencyDistributionList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyDistributionList_begin(self)

    def end(self):
        return _byteblower.LatencyDistributionList_end(self)

    def rbegin(self):
        return _byteblower.LatencyDistributionList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyDistributionList_rend(self)

    def clear(self):
        return _byteblower.LatencyDistributionList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyDistributionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyDistributionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyDistributionList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyDistributionList_swiginit(self, _byteblower.new_LatencyDistributionList(*args))

    def push_back(self, x):
        return _byteblower.LatencyDistributionList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyDistributionList_front(self)

    def back(self):
        return _byteblower.LatencyDistributionList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyDistributionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyDistributionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyDistributionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyDistributionList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyDistributionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyDistributionList

# Register LatencyDistributionList in _byteblower:
_byteblower.LatencyDistributionList_swigregister(LatencyDistributionList)

class OutOfSequenceList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.OutOfSequenceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.OutOfSequenceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.OutOfSequenceList___bool__(self)

    def __len__(self):
        return _byteblower.OutOfSequenceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.OutOfSequenceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.OutOfSequenceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.OutOfSequenceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.OutOfSequenceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.OutOfSequenceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.OutOfSequenceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.OutOfSequenceList_pop(self)

    def append(self, x):
        return _byteblower.OutOfSequenceList_append(self, x)

    def empty(self):
        return _byteblower.OutOfSequenceList_empty(self)

    def size(self):
        return _byteblower.OutOfSequenceList_size(self)

    def swap(self, v):
        return _byteblower.OutOfSequenceList_swap(self, v)

    def begin(self):
        return _byteblower.OutOfSequenceList_begin(self)

    def end(self):
        return _byteblower.OutOfSequenceList_end(self)

    def rbegin(self):
        return _byteblower.OutOfSequenceList_rbegin(self)

    def rend(self):
        return _byteblower.OutOfSequenceList_rend(self)

    def clear(self):
        return _byteblower.OutOfSequenceList_clear(self)

    def get_allocator(self):
        return _byteblower.OutOfSequenceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.OutOfSequenceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.OutOfSequenceList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.OutOfSequenceList_swiginit(self, _byteblower.new_OutOfSequenceList(*args))

    def push_back(self, x):
        return _byteblower.OutOfSequenceList_push_back(self, x)

    def front(self):
        return _byteblower.OutOfSequenceList_front(self)

    def back(self):
        return _byteblower.OutOfSequenceList_back(self)

    def assign(self, n, x):
        return _byteblower.OutOfSequenceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.OutOfSequenceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.OutOfSequenceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.OutOfSequenceList_reserve(self, n)

    def capacity(self):
        return _byteblower.OutOfSequenceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_OutOfSequenceList

# Register OutOfSequenceList in _byteblower:
_byteblower.OutOfSequenceList_swigregister(OutOfSequenceList)

class HTTPClientList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPClientList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPClientList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPClientList_pop(self)

    def append(self, x):
        return _byteblower.HTTPClientList_append(self, x)

    def empty(self):
        return _byteblower.HTTPClientList_empty(self)

    def size(self):
        return _byteblower.HTTPClientList_size(self)

    def swap(self, v):
        return _byteblower.HTTPClientList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPClientList_begin(self)

    def end(self):
        return _byteblower.HTTPClientList_end(self)

    def rbegin(self):
        return _byteblower.HTTPClientList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPClientList_rend(self)

    def clear(self):
        return _byteblower.HTTPClientList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPClientList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPClientList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPClientList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPClientList_swiginit(self, _byteblower.new_HTTPClientList(*args))

    def push_back(self, x):
        return _byteblower.HTTPClientList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPClientList_front(self)

    def back(self):
        return _byteblower.HTTPClientList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPClientList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPClientList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPClientList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPClientList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPClientList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPClientList

# Register HTTPClientList in _byteblower:
_byteblower.HTTPClientList_swigregister(HTTPClientList)

class HTTPMultiDataList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiDataList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPMultiDataList_pop(self)

    def append(self, x):
        return _byteblower.HTTPMultiDataList_append(self, x)

    def empty(self):
        return _byteblower.HTTPMultiDataList_empty(self)

    def size(self):
        return _byteblower.HTTPMultiDataList_size(self)

    def swap(self, v):
        return _byteblower.HTTPMultiDataList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPMultiDataList_begin(self)

    def end(self):
        return _byteblower.HTTPMultiDataList_end(self)

    def rbegin(self):
        return _byteblower.HTTPMultiDataList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPMultiDataList_rend(self)

    def clear(self):
        return _byteblower.HTTPMultiDataList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPMultiDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPMultiDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPMultiDataList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPMultiDataList_swiginit(self, _byteblower.new_HTTPMultiDataList(*args))

    def push_back(self, x):
        return _byteblower.HTTPMultiDataList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPMultiDataList_front(self)

    def back(self):
        return _byteblower.HTTPMultiDataList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPMultiDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPMultiDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPMultiDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPMultiDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPMultiDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPMultiDataList

# Register HTTPMultiDataList in _byteblower:
_byteblower.HTTPMultiDataList_swigregister(HTTPMultiDataList)

class HTTPMultiClientList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiClientList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiClientList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPMultiClientList_pop(self)

    def append(self, x):
        return _byteblower.HTTPMultiClientList_append(self, x)

    def empty(self):
        return _byteblower.HTTPMultiClientList_empty(self)

    def size(self):
        return _byteblower.HTTPMultiClientList_size(self)

    def swap(self, v):
        return _byteblower.HTTPMultiClientList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPMultiClientList_begin(self)

    def end(self):
        return _byteblower.HTTPMultiClientList_end(self)

    def rbegin(self):
        return _byteblower.HTTPMultiClientList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPMultiClientList_rend(self)

    def clear(self):
        return _byteblower.HTTPMultiClientList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPMultiClientList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPMultiClientList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPMultiClientList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPMultiClientList_swiginit(self, _byteblower.new_HTTPMultiClientList(*args))

    def push_back(self, x):
        return _byteblower.HTTPMultiClientList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPMultiClientList_front(self)

    def back(self):
        return _byteblower.HTTPMultiClientList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPMultiClientList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPMultiClientList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPMultiClientList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPMultiClientList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPMultiClientList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPMultiClientList

# Register HTTPMultiClientList in _byteblower:
_byteblower.HTTPMultiClientList_swigregister(HTTPMultiClientList)

class HTTPClientMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPClientMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPClientMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPClientMobileList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPClientMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPClientMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPClientMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPClientMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPClientMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPClientMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPClientMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPClientMobileList_pop(self)

    def append(self, x):
        return _byteblower.HTTPClientMobileList_append(self, x)

    def empty(self):
        return _byteblower.HTTPClientMobileList_empty(self)

    def size(self):
        return _byteblower.HTTPClientMobileList_size(self)

    def swap(self, v):
        return _byteblower.HTTPClientMobileList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPClientMobileList_begin(self)

    def end(self):
        return _byteblower.HTTPClientMobileList_end(self)

    def rbegin(self):
        return _byteblower.HTTPClientMobileList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPClientMobileList_rend(self)

    def clear(self):
        return _byteblower.HTTPClientMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPClientMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPClientMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPClientMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPClientMobileList_swiginit(self, _byteblower.new_HTTPClientMobileList(*args))

    def push_back(self, x):
        return _byteblower.HTTPClientMobileList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPClientMobileList_front(self)

    def back(self):
        return _byteblower.HTTPClientMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPClientMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPClientMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPClientMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPClientMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPClientMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPClientMobileList

# Register HTTPClientMobileList in _byteblower:
_byteblower.HTTPClientMobileList_swigregister(HTTPClientMobileList)

class HTTPServerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPServerList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPServerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPServerList_pop(self)

    def append(self, x):
        return _byteblower.HTTPServerList_append(self, x)

    def empty(self):
        return _byteblower.HTTPServerList_empty(self)

    def size(self):
        return _byteblower.HTTPServerList_size(self)

    def swap(self, v):
        return _byteblower.HTTPServerList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPServerList_begin(self)

    def end(self):
        return _byteblower.HTTPServerList_end(self)

    def rbegin(self):
        return _byteblower.HTTPServerList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPServerList_rend(self)

    def clear(self):
        return _byteblower.HTTPServerList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPServerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPServerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPServerList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPServerList_swiginit(self, _byteblower.new_HTTPServerList(*args))

    def push_back(self, x):
        return _byteblower.HTTPServerList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPServerList_front(self)

    def back(self):
        return _byteblower.HTTPServerList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPServerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPServerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPServerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPServerList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPServerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPServerList

# Register HTTPServerList in _byteblower:
_byteblower.HTTPServerList_swigregister(HTTPServerList)

class HTTPMultiServerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiServerList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiServerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPMultiServerList_pop(self)

    def append(self, x):
        return _byteblower.HTTPMultiServerList_append(self, x)

    def empty(self):
        return _byteblower.HTTPMultiServerList_empty(self)

    def size(self):
        return _byteblower.HTTPMultiServerList_size(self)

    def swap(self, v):
        return _byteblower.HTTPMultiServerList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPMultiServerList_begin(self)

    def end(self):
        return _byteblower.HTTPMultiServerList_end(self)

    def rbegin(self):
        return _byteblower.HTTPMultiServerList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPMultiServerList_rend(self)

    def clear(self):
        return _byteblower.HTTPMultiServerList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPMultiServerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPMultiServerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPMultiServerList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPMultiServerList_swiginit(self, _byteblower.new_HTTPMultiServerList(*args))

    def push_back(self, x):
        return _byteblower.HTTPMultiServerList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPMultiServerList_front(self)

    def back(self):
        return _byteblower.HTTPMultiServerList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPMultiServerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPMultiServerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPMultiServerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPMultiServerList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPMultiServerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPMultiServerList

# Register HTTPMultiServerList in _byteblower:
_byteblower.HTTPMultiServerList_swigregister(HTTPMultiServerList)

class TelnetClientList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TelnetClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TelnetClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TelnetClientList___bool__(self)

    def __len__(self):
        return _byteblower.TelnetClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TelnetClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TelnetClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TelnetClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TelnetClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TelnetClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TelnetClientList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TelnetClientList_pop(self)

    def append(self, x):
        return _byteblower.TelnetClientList_append(self, x)

    def empty(self):
        return _byteblower.TelnetClientList_empty(self)

    def size(self):
        return _byteblower.TelnetClientList_size(self)

    def swap(self, v):
        return _byteblower.TelnetClientList_swap(self, v)

    def begin(self):
        return _byteblower.TelnetClientList_begin(self)

    def end(self):
        return _byteblower.TelnetClientList_end(self)

    def rbegin(self):
        return _byteblower.TelnetClientList_rbegin(self)

    def rend(self):
        return _byteblower.TelnetClientList_rend(self)

    def clear(self):
        return _byteblower.TelnetClientList_clear(self)

    def get_allocator(self):
        return _byteblower.TelnetClientList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TelnetClientList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TelnetClientList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TelnetClientList_swiginit(self, _byteblower.new_TelnetClientList(*args))

    def push_back(self, x):
        return _byteblower.TelnetClientList_push_back(self, x)

    def front(self):
        return _byteblower.TelnetClientList_front(self)

    def back(self):
        return _byteblower.TelnetClientList_back(self)

    def assign(self, n, x):
        return _byteblower.TelnetClientList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TelnetClientList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TelnetClientList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TelnetClientList_reserve(self, n)

    def capacity(self):
        return _byteblower.TelnetClientList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TelnetClientList

# Register TelnetClientList in _byteblower:
_byteblower.TelnetClientList_swigregister(TelnetClientList)

class TCPTunnelList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPTunnelList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPTunnelList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPTunnelList___bool__(self)

    def __len__(self):
        return _byteblower.TCPTunnelList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPTunnelList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPTunnelList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPTunnelList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPTunnelList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPTunnelList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPTunnelList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TCPTunnelList_pop(self)

    def append(self, x):
        return _byteblower.TCPTunnelList_append(self, x)

    def empty(self):
        return _byteblower.TCPTunnelList_empty(self)

    def size(self):
        return _byteblower.TCPTunnelList_size(self)

    def swap(self, v):
        return _byteblower.TCPTunnelList_swap(self, v)

    def begin(self):
        return _byteblower.TCPTunnelList_begin(self)

    def end(self):
        return _byteblower.TCPTunnelList_end(self)

    def rbegin(self):
        return _byteblower.TCPTunnelList_rbegin(self)

    def rend(self):
        return _byteblower.TCPTunnelList_rend(self)

    def clear(self):
        return _byteblower.TCPTunnelList_clear(self)

    def get_allocator(self):
        return _byteblower.TCPTunnelList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TCPTunnelList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TCPTunnelList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.TCPTunnelList_swiginit(self, _byteblower.new_TCPTunnelList(*args))

    def push_back(self, x):
        return _byteblower.TCPTunnelList_push_back(self, x)

    def front(self):
        return _byteblower.TCPTunnelList_front(self)

    def back(self):
        return _byteblower.TCPTunnelList_back(self)

    def assign(self, n, x):
        return _byteblower.TCPTunnelList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TCPTunnelList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TCPTunnelList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TCPTunnelList_reserve(self, n)

    def capacity(self):
        return _byteblower.TCPTunnelList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TCPTunnelList

# Register TCPTunnelList in _byteblower:
_byteblower.TCPTunnelList_swigregister(TCPTunnelList)

class ICMPEchoSessionList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ICMPEchoSessionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ICMPEchoSessionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ICMPEchoSessionList___bool__(self)

    def __len__(self):
        return _byteblower.ICMPEchoSessionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ICMPEchoSessionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ICMPEchoSessionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ICMPEchoSessionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ICMPEchoSessionList_pop(self)

    def append(self, x):
        return _byteblower.ICMPEchoSessionList_append(self, x)

    def empty(self):
        return _byteblower.ICMPEchoSessionList_empty(self)

    def size(self):
        return _byteblower.ICMPEchoSessionList_size(self)

    def swap(self, v):
        return _byteblower.ICMPEchoSessionList_swap(self, v)

    def begin(self):
        return _byteblower.ICMPEchoSessionList_begin(self)

    def end(self):
        return _byteblower.ICMPEchoSessionList_end(self)

    def rbegin(self):
        return _byteblower.ICMPEchoSessionList_rbegin(self)

    def rend(self):
        return _byteblower.ICMPEchoSessionList_rend(self)

    def clear(self):
        return _byteblower.ICMPEchoSessionList_clear(self)

    def get_allocator(self):
        return _byteblower.ICMPEchoSessionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ICMPEchoSessionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ICMPEchoSessionList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ICMPEchoSessionList_swiginit(self, _byteblower.new_ICMPEchoSessionList(*args))

    def push_back(self, x):
        return _byteblower.ICMPEchoSessionList_push_back(self, x)

    def front(self):
        return _byteblower.ICMPEchoSessionList_front(self)

    def back(self):
        return _byteblower.ICMPEchoSessionList_back(self)

    def assign(self, n, x):
        return _byteblower.ICMPEchoSessionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ICMPEchoSessionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ICMPEchoSessionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ICMPEchoSessionList_reserve(self, n)

    def capacity(self):
        return _byteblower.ICMPEchoSessionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ICMPEchoSessionList

# Register ICMPEchoSessionList in _byteblower:
_byteblower.ICMPEchoSessionList_swigregister(ICMPEchoSessionList)

class ICMPv6EchoSessionList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ICMPv6EchoSessionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ICMPv6EchoSessionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ICMPv6EchoSessionList___bool__(self)

    def __len__(self):
        return _byteblower.ICMPv6EchoSessionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ICMPv6EchoSessionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ICMPv6EchoSessionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ICMPv6EchoSessionList_pop(self)

    def append(self, x):
        return _byteblower.ICMPv6EchoSessionList_append(self, x)

    def empty(self):
        return _byteblower.ICMPv6EchoSessionList_empty(self)

    def size(self):
        return _byteblower.ICMPv6EchoSessionList_size(self)

    def swap(self, v):
        return _byteblower.ICMPv6EchoSessionList_swap(self, v)

    def begin(self):
        return _byteblower.ICMPv6EchoSessionList_begin(self)

    def end(self):
        return _byteblower.ICMPv6EchoSessionList_end(self)

    def rbegin(self):
        return _byteblower.ICMPv6EchoSessionList_rbegin(self)

    def rend(self):
        return _byteblower.ICMPv6EchoSessionList_rend(self)

    def clear(self):
        return _byteblower.ICMPv6EchoSessionList_clear(self)

    def get_allocator(self):
        return _byteblower.ICMPv6EchoSessionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ICMPv6EchoSessionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ICMPv6EchoSessionList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ICMPv6EchoSessionList_swiginit(self, _byteblower.new_ICMPv6EchoSessionList(*args))

    def push_back(self, x):
        return _byteblower.ICMPv6EchoSessionList_push_back(self, x)

    def front(self):
        return _byteblower.ICMPv6EchoSessionList_front(self)

    def back(self):
        return _byteblower.ICMPv6EchoSessionList_back(self)

    def assign(self, n, x):
        return _byteblower.ICMPv6EchoSessionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ICMPv6EchoSessionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ICMPv6EchoSessionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ICMPv6EchoSessionList_reserve(self, n)

    def capacity(self):
        return _byteblower.ICMPv6EchoSessionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ICMPv6EchoSessionList

# Register ICMPv6EchoSessionList in _byteblower:
_byteblower.ICMPv6EchoSessionList_swigregister(ICMPv6EchoSessionList)

class CaptureRawPacketList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CaptureRawPacketList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CaptureRawPacketList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CaptureRawPacketList___bool__(self)

    def __len__(self):
        return _byteblower.CaptureRawPacketList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CaptureRawPacketList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CaptureRawPacketList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CaptureRawPacketList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CaptureRawPacketList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CaptureRawPacketList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CaptureRawPacketList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CaptureRawPacketList_pop(self)

    def append(self, x):
        return _byteblower.CaptureRawPacketList_append(self, x)

    def empty(self):
        return _byteblower.CaptureRawPacketList_empty(self)

    def size(self):
        return _byteblower.CaptureRawPacketList_size(self)

    def swap(self, v):
        return _byteblower.CaptureRawPacketList_swap(self, v)

    def begin(self):
        return _byteblower.CaptureRawPacketList_begin(self)

    def end(self):
        return _byteblower.CaptureRawPacketList_end(self)

    def rbegin(self):
        return _byteblower.CaptureRawPacketList_rbegin(self)

    def rend(self):
        return _byteblower.CaptureRawPacketList_rend(self)

    def clear(self):
        return _byteblower.CaptureRawPacketList_clear(self)

    def get_allocator(self):
        return _byteblower.CaptureRawPacketList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CaptureRawPacketList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CaptureRawPacketList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.CaptureRawPacketList_swiginit(self, _byteblower.new_CaptureRawPacketList(*args))

    def push_back(self, x):
        return _byteblower.CaptureRawPacketList_push_back(self, x)

    def front(self):
        return _byteblower.CaptureRawPacketList_front(self)

    def back(self):
        return _byteblower.CaptureRawPacketList_back(self)

    def assign(self, n, x):
        return _byteblower.CaptureRawPacketList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CaptureRawPacketList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CaptureRawPacketList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CaptureRawPacketList_reserve(self, n)

    def capacity(self):
        return _byteblower.CaptureRawPacketList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CaptureRawPacketList

# Register CaptureRawPacketList in _byteblower:
_byteblower.CaptureRawPacketList_swigregister(CaptureRawPacketList)

class CapturedFrameList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CapturedFrameList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CapturedFrameList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CapturedFrameList___bool__(self)

    def __len__(self):
        return _byteblower.CapturedFrameList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CapturedFrameList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CapturedFrameList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CapturedFrameList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CapturedFrameList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CapturedFrameList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CapturedFrameList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CapturedFrameList_pop(self)

    def append(self, x):
        return _byteblower.CapturedFrameList_append(self, x)

    def empty(self):
        return _byteblower.CapturedFrameList_empty(self)

    def size(self):
        return _byteblower.CapturedFrameList_size(self)

    def swap(self, v):
        return _byteblower.CapturedFrameList_swap(self, v)

    def begin(self):
        return _byteblower.CapturedFrameList_begin(self)

    def end(self):
        return _byteblower.CapturedFrameList_end(self)

    def rbegin(self):
        return _byteblower.CapturedFrameList_rbegin(self)

    def rend(self):
        return _byteblower.CapturedFrameList_rend(self)

    def clear(self):
        return _byteblower.CapturedFrameList_clear(self)

    def get_allocator(self):
        return _byteblower.CapturedFrameList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CapturedFrameList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CapturedFrameList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.CapturedFrameList_swiginit(self, _byteblower.new_CapturedFrameList(*args))

    def push_back(self, x):
        return _byteblower.CapturedFrameList_push_back(self, x)

    def front(self):
        return _byteblower.CapturedFrameList_front(self)

    def back(self):
        return _byteblower.CapturedFrameList_back(self)

    def assign(self, n, x):
        return _byteblower.CapturedFrameList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CapturedFrameList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CapturedFrameList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CapturedFrameList_reserve(self, n)

    def capacity(self):
        return _byteblower.CapturedFrameList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CapturedFrameList

# Register CapturedFrameList in _byteblower:
_byteblower.CapturedFrameList_swigregister(CapturedFrameList)

class CapabilityList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CapabilityList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CapabilityList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CapabilityList___bool__(self)

    def __len__(self):
        return _byteblower.CapabilityList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CapabilityList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CapabilityList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CapabilityList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CapabilityList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CapabilityList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CapabilityList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CapabilityList_pop(self)

    def append(self, x):
        return _byteblower.CapabilityList_append(self, x)

    def empty(self):
        return _byteblower.CapabilityList_empty(self)

    def size(self):
        return _byteblower.CapabilityList_size(self)

    def swap(self, v):
        return _byteblower.CapabilityList_swap(self, v)

    def begin(self):
        return _byteblower.CapabilityList_begin(self)

    def end(self):
        return _byteblower.CapabilityList_end(self)

    def rbegin(self):
        return _byteblower.CapabilityList_rbegin(self)

    def rend(self):
        return _byteblower.CapabilityList_rend(self)

    def clear(self):
        return _byteblower.CapabilityList_clear(self)

    def get_allocator(self):
        return _byteblower.CapabilityList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CapabilityList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CapabilityList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.CapabilityList_swiginit(self, _byteblower.new_CapabilityList(*args))

    def push_back(self, x):
        return _byteblower.CapabilityList_push_back(self, x)

    def front(self):
        return _byteblower.CapabilityList_front(self)

    def back(self):
        return _byteblower.CapabilityList_back(self)

    def assign(self, n, x):
        return _byteblower.CapabilityList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CapabilityList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CapabilityList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CapabilityList_reserve(self, n)

    def capacity(self):
        return _byteblower.CapabilityList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CapabilityList

# Register CapabilityList in _byteblower:
_byteblower.CapabilityList_swigregister(CapabilityList)

# This file expects that the lower layer ByteBlower is included as _byteblower


class ByteBlowerPortCounterType(object):

    RxAll = _byteblower.ByteBlowerPortResultRxData_CounterType_RxAll
    """ TODO"""

    RxBroadcast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxBroadcast  # noqa: E501
    """ TODO"""

    RxUnicast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxUnicast
    """ TODO"""


class DeviceOsType(object):
    Android = _byteblower.DeviceOsType_Android
    """ TODO"""

    iOS = _byteblower.DeviceOsType_iOS
    """ TODO"""

    Linux = _byteblower.DeviceOsType_Linux
    """ TODO"""

    OSx = _byteblower.DeviceOsType_OSx
    """ TODO"""

    Unknown = _byteblower.DeviceOsType_Unknown
    """ TODO"""

    Windows = _byteblower.DeviceOsType_Windows
    """ TODO"""


class DeviceStatus(object):
    Available = _byteblower.DeviceStatus_Available
    """ Wireless endpoint is registered  """

    Reserved = _byteblower.DeviceStatus_Reserved
    """ Wireless endpoint is locked/used by (another) user  """

    Running = _byteblower.DeviceStatus_Running
    """ Wireless endpoint is currently running a test """

    Starting = _byteblower.DeviceStatus_Starting
    """ Wireless endpoint will start any second now with a test"""

    Unavailable = _byteblower.DeviceStatus_Unavailable
    """Wireless endpoint not available/registered"""


class EthernetEncoding(object):
    DIX = _byteblower.EthernetEncoding_DIX
    SNAP = _byteblower.EthernetEncoding_SNAP


class FrameTagType(object):
    """ The type of the FrameTag as found in a Trigger and a Frame """

    SequenceNumber = _byteblower.FrameTagType_SequenceNumber
    """This is a FrameTag with a sequence number.  """

    TimeStamp = _byteblower.FrameTagType_TimeStamp
    """This is a FrameTag with a timestamp."""


class HTTPMultiClientStatus(object):
    Configuration = _byteblower.HTTPMultiClientStatus_Configuration
    """ initial state in which the configuration takes place"""

    Finished = _byteblower.HTTPMultiClientStatus_Finished
    """ flow finished succesfully"""

    Running = _byteblower.HTTPMultiClientStatus_Running
    """ when the flow is running"""

    Scheduled = _byteblower.HTTPMultiClientStatus_Scheduled
    """ during the initial time to wait"""

    Stopped = _byteblower.HTTPMultiClientStatus_Stopped
    """ flow was stopped by user"""


class HTTPMultiServerStatus(object):
    Started = _byteblower.HTTPMultiServerStatus_Started
    """ The HTTP server is active"""
    Stopped = _byteblower.HTTPMultiServerStatus_Stopped
    """ The HTTP server is not running"""


class HTTPRequestMethod(object):
    Delete = _byteblower.HTTPRequestMethod_Delete
    """ TODO"""
    Get = _byteblower.HTTPRequestMethod_Get
    """ TODO"""
    Head = _byteblower.HTTPRequestMethod_Head
    """ TODO"""
    Options = _byteblower.HTTPRequestMethod_Options
    """ TODO"""
    Post = _byteblower.HTTPRequestMethod_Post
    """ TODO"""
    Put = _byteblower.HTTPRequestMethod_Put
    """ TODO"""
    Trace = _byteblower.HTTPRequestMethod_Trace
    """ TODO"""
    Undefined = _byteblower.HTTPRequestMethod_Undefined
    """ TODO"""


class HTTPRequestStatus(object):
    Configuration = _byteblower.HTTPRequestStatus_Configuration
    """ initial state in which the configuration takes place"""
    Connecting = _byteblower.HTTPRequestStatus_Connecting
    """ while trying to establish a connection"""
    Error = _byteblower.HTTPRequestStatus_Error
    """ if an error occurred while trying to connect or while running"""
    Finished = _byteblower.HTTPRequestStatus_Finished
    """ after the http request has completed"""
    Running = _byteblower.HTTPRequestStatus_Running
    """ while the connection is established and before http request has
    completed"""
    Scheduled = _byteblower.HTTPRequestStatus_Scheduled
    """ during the initial time to wait of a scheduled request"""
    Stopped = _byteblower.HTTPRequestStatus_Stopped
    """ after the user stopped the request"""


class HTTPRequestType(object):
    Duration = _byteblower.HTTPRequestType_Duration
    Size = _byteblower.HTTPRequestType_Size


class HTTPServerStatus(object):
    Error = _byteblower.HTTPServerStatus_Error
    """ Error occurred while initializing"""

    Running = _byteblower.HTTPServerStatus_Running
    """ The HTTP server is active"""

    Stopped = _byteblower.HTTPServerStatus_Stopped
    """ The HTTP server is not running"""

    Unknown = _byteblower.HTTPServerStatus_Unknown
    """ The server status code is not known to the client"""


class IGMPVersion(object):
    IGMPv1 = _byteblower.IGMPVersion_IGMPv1
    IGMPv2 = _byteblower.IGMPVersion_IGMPv2
    IGMPv3 = _byteblower.IGMPVersion_IGMPv3


class LinkStatus(object):
    """Link status object

    """

    Offline = _byteblower.LinkStatus_Offline
    """The ByteBlower interface is offline"""

    Online = _byteblower.LinkStatus_Online
    """ The ByteBlower interface is fully up and running"""

    Unplugged = _byteblower.LinkStatus_Unplugged
    """The ByteBlower Interface is not plugged in"""

    Unknown = _byteblower.LinkStatus_Unknown
    """ The ByteBlower Interface has an unknown status."""


class LinkType(object):
    Ethernet = _byteblower.LinkType_Ethernet
    USB = _byteblower.LinkType_USB


class LogLevel(object):
    Critical = _byteblower.LogLevel_Critical
    Debug = _byteblower.LogLevel_Debug
    Error = _byteblower.LogLevel_Error
    Info = _byteblower.LogLevel_Info
    Warning = _byteblower.LogLevel_Warning


class MLDVersion(object):
    MLDv1 = _byteblower.MLDVersion_MLDv1
    MLDv2 = _byteblower.MLDVersion_MLDv2


class ModifierType(object):
    GrowingSize = _byteblower.ModifierType_GrowingSize
    MultiBurst = _byteblower.ModifierType_MultiBurst
    NormalDistributionTiming = _byteblower.ModifierType_NormalDistributionTiming  # noqa: E501
    RandomSize = _byteblower.ModifierType_RandomSize


class MulticastSourceFilter(object):
    Exclude = _byteblower.MulticastSourceFilter_Exclude
    Include = _byteblower.MulticastSourceFilter_Include


class NetworkInterfaceType(object):
    Unknown = _byteblower.NetworkInterfaceType_Unknown
    Ethernet = _byteblower.NetworkInterfaceType_Ethernet
    Loopback = _byteblower.NetworkInterfaceType_Loopback
    WiFi = _byteblower.NetworkInterfaceType_WiFi


class PhysicalInterfaceType(object):
    NonTrunk = _byteblower.PhysicalInterfaceType_NonTrunk
    NonTrunkUSB = _byteblower.PhysicalInterfaceType_NonTrunkUSB
    Trunk = _byteblower.PhysicalInterfaceType_Trunk


class PPPoEStatus(object):
    Discovering = _byteblower.PPPoEStatus_Discovering
    Initial = _byteblower.PPPoEStatus_Initial
    Requesting = _byteblower.PPPoEStatus_Requesting
    SessionActive = _byteblower.PPPoEStatus_SessionActive
    Terminated = _byteblower.PPPoEStatus_Terminated


class RequestStartType(object):
    Direct = _byteblower.HTTPClient_RequestStartType_Direct
    Scheduled = _byteblower.HTTPClient_RequestStartType_Scheduled


class ResultDataType(object):
    Cumulative = _byteblower.ResultDataType_Cumulative
    Interval = _byteblower.ResultDataType_Interval


class RetransmissionPolicy(object):
    FixedTiming = _byteblower.RetransmissionPolicy_FixedTiming
    RfcSuggested = _byteblower.RetransmissionPolicy_RfcSuggested
    Unknown = _byteblower.RetransmissionPolicy_Unknown


class Role(object):
    Client = _byteblower.HTTPSessionInfo_Role_Client
    Server = _byteblower.HTTPSessionInfo_Role_Server


class ScheduleGroupStatus(object):
    Configuration = _byteblower.ScheduleGroupStatus_Configuration
    Error = _byteblower.ScheduleGroupStatus_Error
    Prepared = _byteblower.ScheduleGroupStatus_Prepared
    Started = _byteblower.ScheduleGroupStatus_Started
    Stopped = _byteblower.ScheduleGroupStatus_Stopped


class SequenceNumberFormat(object):
    SequenceNumber_0 = _byteblower.SequenceNumberFormat_SequenceNumber_0
    SequenceNumber_0_CRC = _byteblower.SequenceNumberFormat_SequenceNumber_0_CRC  # noqa: E501


class TCPCongestionAvoidanceAlgorithm(object):
    NewReno = _byteblower.TCPCongestionAvoidanceAlgorithm_NewReno
    NewRenoWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic  # noqa: E501
    No_Algorithm = _byteblower.TCPCongestionAvoidanceAlgorithm__None
    """ TODO

    .. note:: The algorithm is actually called `None`,
              but python has this as a keyword
    """
    Sack = _byteblower.TCPCongestionAvoidanceAlgorithm_Sack
    SackWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_SackWithCubic


class TCPConnectionState(object):
    """The state of the TCP Connection

    """

    CLOSED = _byteblower.TCPConnectionState_CLOSED
    """ Closed"""

    LISTEN = _byteblower.TCPConnectionState_LISTEN
    """Listen"""

    SYN_RECEIVED = _byteblower.TCPConnectionState_SYN_RECEIVED
    """SYN received"""

    SYN_SENT = _byteblower.TCPConnectionState_SYN_SENT
    """SYN Sent"""

    ESTABLISHED = _byteblower.TCPConnectionState_ESTABLISHED
    """Established"""

    FIN_WAIT_1 = _byteblower.TCPConnectionState_FIN_WAIT_1
    """FIN wait (number 1)"""

    FIN_WAIT_2 = _byteblower.TCPConnectionState_FIN_WAIT_2
    """FIN wait (number 2)"""
    CLOSING = _byteblower.TCPConnectionState_CLOSING
    """Closing"""

    CLOSE_WAIT = _byteblower.TCPConnectionState_CLOSE_WAIT
    LAST_ACK = _byteblower.TCPConnectionState_LAST_ACK
    TIME_WAIT = _byteblower.TCPConnectionState_TIME_WAIT


class TransmitErrorStatus(object):
    """The error status of a :class:`Stream`

    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_status_UNKNOWN
    """Unknown error.

    This can indicate 2 things:

    - The API is outdated
    - The server encountered an error, but does not know what

    """

    NONE = _byteblower.StreamRuntimeStatus_transmit_error_status_NONE
    """No error"""

    OUT_OF_RESOURCES = _byteblower.StreamRuntimeStatus_transmit_error_status_OUT_OF_RESOURCES  # noqa: E501
    """The server went out of resources.

    The origin of the error can be queried by calling
    :meth:`StreamRuntimeStatus.ErrorSourceGet`
    """


class TransmitErrorSource(object):
    """ The source of an error of a :class:`Stream`
    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_source_UNKNOWN
    """The stream does honestly not know where the error came from.

    This can also be returned when you encounter an error with an outdated API.
    """

    NONE = _byteblower.StreamRuntimeStatus_transmit_error_source_NONE
    """Nothing has gone wrong, this is what you want!"""

    INTERFACE_HARDWARE = _byteblower.StreamRuntimeStatus_transmit_error_source_INTERFACE_HARDWARE  # noqa: E501
    """One tries to transmit more than the interface bandwith.

    e.g. One tries to send 2 700Mbps flows on a single 1Gbps interface
    """

    SCHEDULING_CONFLICT = _byteblower.StreamRuntimeStatus_transmit_error_source_SCHEDULING_CONFLICT  # noqa: E501
    """The stream cannot keep up.

    .. deprecated:: 2.9.0
       The stream has issues to schedule all frames on the network interface.
    """

    TXUSER = _byteblower.StreamRuntimeStatus_transmit_error_source_TXUSER
    """The user is requesting too much processing power on the server"""


class TransmitStatus(object):
    """The current transmission status of a class:`Stream`
    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_status_UNKNOWN
    """The server honestly does not know what the stream is doing.

    .. note:: If this happens, please contact the ByteBlower support team.
              It will indicate us that something is going wrong.
    """

    INACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_INACTIVE
    """The stream is inactive and not transmitting frames.

    This can either be because the stream is not started (yet)
    or the stream has transmitted all frames as configured
    by :meth:`.Stream.NumberOfFramesSet`
    """

    ACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_ACTIVE
    """The stream is active and transmitting frames"""


class TimeStampFormat(object):
    Microseconds = _byteblower.TimeStampFormat_Microseconds
    Microseconds_CRC = _byteblower.TimeStampFormat_Microseconds_CRC
    TenNanoseconds = _byteblower.TimeStampFormat_TenNanoseconds


class TimeUnit(object):
    Microseconds = _byteblower.TimeUnit_Microseconds
    Milliseconds = _byteblower.TimeUnit_Milliseconds
    Nanoseconds = _byteblower.TimeUnit_Nanoseconds
    Seconds = _byteblower.TimeUnit_Seconds



